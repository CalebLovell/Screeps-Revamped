{"code":"import * as tslib_1 from \"tslib\";\r\nvar EvolutionChamber_1;\r\nimport { $ } from '../caching/GlobalCache';\r\nimport { log } from '../console/log';\r\nimport { TraderJoe } from '../logistics/TradeNetwork';\r\nimport { Mem } from '../memory/Memory';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { Priority } from '../priorities/priorities';\r\nimport { profile } from '../profiler/decorator';\r\nimport { boostParts, REAGENTS } from '../resources/map_resources';\r\nimport { Stats } from '../stats/stats';\r\nimport { rightArrow } from '../utilities/stringConstants';\r\nimport { exponentialMovingAverage } from '../utilities/utils';\r\nimport { Visualizer } from '../visuals/Visualizer';\r\nimport { HiveCluster } from './_HiveCluster';\r\nconst LabStatus = {\r\n    Idle: 0,\r\n    AcquiringMinerals: 1,\r\n    LoadingLabs: 2,\r\n    Synthesizing: 3,\r\n    UnloadingLabs: 4,\r\n};\r\nconst LabStageTimeouts = {\r\n    Idle: Infinity,\r\n    AcquiringMinerals: 100,\r\n    LoadingLabs: 50,\r\n    Synthesizing: 10000,\r\n    UnloadingLabs: 1000\r\n};\r\nconst LAB_USAGE_WINDOW = 100;\r\nconst EvolutionChamberMemoryDefaults = {\r\n    status: LabStatus.Idle,\r\n    statusTick: 0,\r\n    activeReaction: undefined,\r\n    reactionQueue: [],\r\n    labMineralTypes: {},\r\n    stats: {\r\n        totalProduction: {},\r\n        avgUsage: 1,\r\n    }\r\n};\r\nfunction neighboringLabs(pos) {\r\n    return _.compact(_.map(pos.neighbors, neighbor => neighbor.lookForStructure(STRUCTURE_LAB)));\r\n}\r\nfunction labsAreEmpty(labs) {\r\n    return _.all(labs, lab => lab.mineralAmount == 0);\r\n}\r\n/**\r\n * The evolution chamber handles mineral production and boosting logic, handling resource supply for labs\r\n */\r\nlet EvolutionChamber = EvolutionChamber_1 = class EvolutionChamber extends HiveCluster {\r\n    constructor(colony, terminal) {\r\n        super(colony, terminal, 'evolutionChamber');\r\n        this.memory = Mem.wrap(this.colony.memory, 'evolutionChamber', EvolutionChamberMemoryDefaults);\r\n        // Register physical components\r\n        this.terminal = terminal;\r\n        this.terminalNetwork = Overmind.terminalNetwork;\r\n        this.labs = colony.labs;\r\n        // Reserve some easily-accessible labs which are restricted not to be reagent labs\r\n        const restrictedLabs = this.colony.bunker ?\r\n            _.filter(this.labs, lab => lab.pos.findInRange(this.colony.spawns, 1).length > 0) :\r\n            _.take(_.sortBy(this.labs, lab => Pathing.distance(this.terminal.pos, lab.pos)), 1);\r\n        // Reagent labs are range=2 from all other labs and are not a boosting lab\r\n        const range2Labs = _.filter(this.labs, lab => _.all(this.labs, otherLab => lab.pos.inRangeTo(otherLab, 2)));\r\n        const reagentLabCandidates = _.filter(range2Labs, lab => !_.any(restrictedLabs, l => l.id == lab.id));\r\n        if (this.colony.bunker && this.colony.labs.length == 10) {\r\n            this.reagentLabs = _.take(_.sortBy(reagentLabCandidates, lab => -1 * lab.pos.findInRange(this.boostingLabs, 1).length), 2);\r\n        }\r\n        else {\r\n            this.reagentLabs = _.take(_.sortBy(reagentLabCandidates, lab => -1 * neighboringLabs(lab.pos).length), 2);\r\n        }\r\n        // Product labs are everything that isn't a reagent lab. (boostingLab can also be a productLab)\r\n        this.productLabs = _.difference(this.labs, this.reagentLabs);\r\n        // Boosting labs are product labs sorted by distance to terminal\r\n        const unrestrictedBoostingLabs = _.sortBy(_.difference(this.productLabs, restrictedLabs), lab => Pathing.distance(this.terminal.pos, lab.pos));\r\n        this.boostingLabs = [...restrictedLabs, ...unrestrictedBoostingLabs];\r\n        // This keeps track of reservations for boosting\r\n        this.labReservations = {};\r\n        // this.boostQueue = {};\r\n        this.neededBoosts = {};\r\n        if (this.colony.commandCenter && this.colony.layout == 'twoPart') {\r\n            // in two-part layout, evolution chamber shares a common request group with command center\r\n            this.transportRequests = this.colony.commandCenter.transportRequests;\r\n        }\r\n        else {\r\n            // otherwise (in bunker layout), it uses colony/hatchery transport requests\r\n            this.transportRequests = this.colony.transportRequests;\r\n        }\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(this.colony.memory, 'evolutionChamber', EvolutionChamberMemoryDefaults);\r\n        $.refreshRoom(this);\r\n        $.refresh(this, 'terminal', 'labs', 'boostingLabs', 'reagentLabs', 'productLabs');\r\n        this.labReservations = {};\r\n        this.neededBoosts = {};\r\n    }\r\n    spawnMoarOverlords() {\r\n        // Evolution chamber is attended to by queens; overlord spawned at Hatchery\r\n    }\r\n    statusTimeoutCheck() {\r\n        const ticksInStatus = Game.time - this.memory.statusTick;\r\n        let timeout = false;\r\n        switch (this.memory.status) {\r\n            case LabStatus.Idle:\r\n                timeout = ticksInStatus > LabStageTimeouts.Idle;\r\n                break;\r\n            case LabStatus.AcquiringMinerals:\r\n                timeout = ticksInStatus > LabStageTimeouts.AcquiringMinerals;\r\n                break;\r\n            case LabStatus.LoadingLabs:\r\n                timeout = ticksInStatus > LabStageTimeouts.LoadingLabs;\r\n                break;\r\n            case LabStatus.Synthesizing:\r\n                timeout = ticksInStatus > LabStageTimeouts.Synthesizing;\r\n                break;\r\n            case LabStatus.UnloadingLabs:\r\n                timeout = ticksInStatus > LabStageTimeouts.UnloadingLabs;\r\n                break;\r\n            default:\r\n                log.warning(`Bad lab state at ${this.print}!`);\r\n                this.memory.status = LabStatus.Idle;\r\n                this.memory.statusTick = Game.time;\r\n                break;\r\n        }\r\n        if (timeout) {\r\n            log.warning(`${this.print}: stuck in state ${this.memory.status} for ${ticksInStatus} ticks, ` +\r\n                `rebuilding reaction queue and reverting to idle state!`);\r\n            this.memory.status = LabStatus.Idle;\r\n            this.memory.statusTick = Game.time;\r\n            this.memory.activeReaction = undefined;\r\n            this.memory.reactionQueue = [];\r\n        }\r\n    }\r\n    initLabStatus() {\r\n        if (!this.memory.activeReaction && this.memory.status != LabStatus.Idle) {\r\n            log.warning(`No active reaction at ${this.print}!`);\r\n            this.memory.status = LabStatus.Idle;\r\n        }\r\n        switch (this.memory.status) {\r\n            case LabStatus.Idle:\r\n                if (this.memory.activeReaction) {\r\n                    const [ing1, ing2] = REAGENTS[this.memory.activeReaction.mineralType];\r\n                    log.info(`${this.colony.room.print}: starting synthesis of ${ing1} + ${ing2} ${rightArrow} ` +\r\n                        this.memory.activeReaction.mineralType);\r\n                    this.memory.status = LabStatus.AcquiringMinerals;\r\n                    this.memory.statusTick = Game.time;\r\n                }\r\n                break;\r\n            case LabStatus.AcquiringMinerals: // \"We acquire more mineralzzz\"\r\n                const missingIngredients = this.colony.abathur.getMissingBasicMinerals([this.memory.activeReaction]);\r\n                if (_.all(missingIngredients, amount => amount == 0)) {\r\n                    // Loading labs if all minerals are present but labs not at desired capacity yet\r\n                    this.memory.status = LabStatus.LoadingLabs;\r\n                    this.memory.statusTick = Game.time;\r\n                }\r\n                break;\r\n            case LabStatus.LoadingLabs:\r\n                if (_.all(this.reagentLabs, lab => lab.mineralAmount >= this.memory.activeReaction.amount &&\r\n                    REAGENTS[this.memory.activeReaction.mineralType]\r\n                        .includes(lab.mineralType))) {\r\n                    this.memory.status = LabStatus.Synthesizing;\r\n                    this.memory.statusTick = Game.time;\r\n                }\r\n                break;\r\n            case LabStatus.Synthesizing:\r\n                if (_.any(this.reagentLabs, lab => lab.mineralAmount < LAB_REACTION_AMOUNT)) {\r\n                    this.memory.status = LabStatus.UnloadingLabs;\r\n                    this.memory.statusTick = Game.time;\r\n                }\r\n                break;\r\n            case LabStatus.UnloadingLabs:\r\n                if (_.all([...this.reagentLabs, ...this.productLabs], lab => lab.mineralAmount == 0)) {\r\n                    this.memory.status = LabStatus.Idle;\r\n                    this.memory.statusTick = Game.time;\r\n                }\r\n                break;\r\n            default:\r\n                log.warning(`Bad lab state at ${this.print}!`);\r\n                this.memory.status = LabStatus.Idle;\r\n                this.memory.statusTick = Game.time;\r\n                break;\r\n        }\r\n        this.statusTimeoutCheck();\r\n    }\r\n    reagentLabRequests(reagentLabs) {\r\n        if (this.memory.activeReaction) {\r\n            const { mineralType, amount } = this.memory.activeReaction;\r\n            const [ing1, ing2] = REAGENTS[mineralType];\r\n            const [lab1, lab2] = reagentLabs;\r\n            if (!lab1 || !lab2)\r\n                return;\r\n            // Empty out any incorrect minerals and request the correct reagents\r\n            if (this.memory.status == LabStatus.UnloadingLabs || (lab1.mineralType != ing1 && lab1.mineralAmount > 0)) {\r\n                this.transportRequests.requestOutput(lab1, Priority.Normal, { resourceType: lab1.mineralType });\r\n            }\r\n            else if (this.memory.status == LabStatus.LoadingLabs && lab1.mineralAmount < amount) {\r\n                this.transportRequests.requestInput(lab1, Priority.Normal, {\r\n                    resourceType: ing1,\r\n                    amount: amount - lab1.mineralAmount,\r\n                });\r\n            }\r\n            if (this.memory.status == LabStatus.UnloadingLabs || (lab2.mineralType != ing2 && lab2.mineralAmount > 0)) {\r\n                this.transportRequests.requestOutput(lab2, Priority.Normal, { resourceType: lab2.mineralType });\r\n            }\r\n            else if (this.memory.status == LabStatus.LoadingLabs && lab2.mineralAmount < amount) {\r\n                this.transportRequests.requestInput(lab2, Priority.Normal, {\r\n                    resourceType: ing2,\r\n                    amount: amount - lab2.mineralAmount,\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            // Labs should be empty when no reaction process is currently happening\r\n            for (const lab of reagentLabs) {\r\n                if (lab.mineralType && lab.mineralAmount > 0) {\r\n                    this.transportRequests.requestOutput(lab, Priority.Normal, { resourceType: lab.mineralType });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    productLabRequests(labs) {\r\n        if (this.memory.activeReaction) {\r\n            const { mineralType, amount } = this.memory.activeReaction;\r\n            for (const lab of labs) {\r\n                const labHasWrongMineral = lab.mineralType != mineralType && lab.mineralAmount > 0;\r\n                const labIsFull = lab.mineralAmount == lab.mineralCapacity;\r\n                // Empty out incorrect minerals or if it's time to unload or if lab is full\r\n                if ((this.memory.status == LabStatus.UnloadingLabs && lab.mineralAmount > 0) ||\r\n                    labHasWrongMineral || labIsFull) {\r\n                    this.transportRequests.requestOutput(lab, Priority.NormalLow, { resourceType: lab.mineralType });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // Labs should be empty when no reaction process is currently happening\r\n            for (const lab of labs) {\r\n                if (lab.mineralType && lab.mineralAmount > 0) {\r\n                    this.transportRequests.requestOutput(lab, Priority.NormalLow, { resourceType: lab.mineralType });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    boosterLabRequests(labs) {\r\n        for (const lab of labs) {\r\n            const { mineralType, amount } = this.labReservations[lab.id];\r\n            // Empty out incorrect minerals\r\n            if (lab.mineralType != mineralType && lab.mineralAmount > 0) {\r\n                this.transportRequests.requestOutput(lab, Priority.NormalHigh, { resourceType: lab.mineralType });\r\n            }\r\n            else {\r\n                this.transportRequests.requestInput(lab, Priority.NormalHigh, {\r\n                    resourceType: mineralType,\r\n                    amount: amount - lab.mineralAmount\r\n                });\r\n            }\r\n        }\r\n    }\r\n    registerRequests() {\r\n        // Separate product labs into actively boosting or ready for reaction\r\n        const boostingProductLabs = _.filter(this.productLabs, lab => this.labReservations[lab.id]);\r\n        const reactionProductLabs = _.filter(this.productLabs, lab => !this.labReservations[lab.id]);\r\n        // Handle energy requests for labs with different priorities\r\n        const boostingRefillLabs = _.filter(boostingProductLabs, lab => lab.energy < lab.energyCapacity);\r\n        _.forEach(boostingRefillLabs, lab => this.transportRequests.requestInput(lab, Priority.High));\r\n        const reactionRefillLabs = _.filter(reactionProductLabs, lab => lab.energy < lab.energyCapacity);\r\n        _.forEach(reactionRefillLabs, lab => this.transportRequests.requestInput(lab, Priority.NormalLow));\r\n        const reagentRefillLabs = _.filter(this.reagentLabs, lab => lab.energy < lab.energyCapacity);\r\n        _.forEach(reagentRefillLabs, lab => this.transportRequests.requestInput(lab, Priority.NormalLow));\r\n        // Request resources delivered to / withdrawn from each type of lab\r\n        this.reagentLabRequests(this.reagentLabs);\r\n        this.productLabRequests(reactionProductLabs);\r\n        this.boosterLabRequests(boostingProductLabs);\r\n    }\r\n    // Lab mineral reservations ========================================================================================\r\n    /* Reserves a product lab for boosting with a compound unrelated to production */\r\n    reserveLab(mineralType, amount, lab) {\r\n        // _.remove(this.productLabs, productLab => productLab.id == lab.id);\r\n        this.labReservations[lab.id] = { mineralType: mineralType, amount: amount };\r\n    }\r\n    /* Return the amount of a given resource necessary to fully boost a creep body */\r\n    static requiredBoostAmount(body, boostType) {\r\n        const existingBoostCounts = _.countBy(body, part => part.boost);\r\n        const numPartsToBeBoosted = _.filter(body, part => part.type == boostParts[boostType]).length;\r\n        return LAB_BOOST_MINERAL * (numPartsToBeBoosted - (existingBoostCounts[boostType] || 0));\r\n    }\r\n    /* Return whether you have the resources to fully boost a creep body with a given resource */\r\n    canBoost(body, boostType) {\r\n        const boostAmount = EvolutionChamber_1.requiredBoostAmount(body, boostType);\r\n        if (this.colony.assets[boostType] >= boostAmount) {\r\n            // Does this colony have the needed resources already?\r\n            return true;\r\n        }\r\n        else if (this.terminalNetwork.assets[boostType] >= 2 * boostAmount) {\r\n            // Is there enough of the resource in terminalNetwork?\r\n            return true;\r\n        }\r\n        else {\r\n            // Can you buy the resources on the market?\r\n            return (Game.market.credits > TraderJoe.settings.market.boostCredits +\r\n                boostAmount * Overmind.tradeNetwork.priceOf(boostType));\r\n        }\r\n    }\r\n    /* Request boosts sufficient to fully boost a given creep to be added to the boosting queue */\r\n    requestBoost(creep, boostType) {\r\n        // Add the required amount to the neededBoosts\r\n        const boostAmount = EvolutionChamber_1.requiredBoostAmount(creep.body, boostType);\r\n        if (!this.neededBoosts[boostType]) {\r\n            this.neededBoosts[boostType] = 0;\r\n        }\r\n        this.neededBoosts[boostType] = Math.min(this.neededBoosts[boostType] + boostAmount, LAB_MINERAL_CAPACITY);\r\n    }\r\n    // Initialization and operation ====================================================================================\r\n    init() {\r\n        // Get a reaction queue if needed\r\n        if (this.memory.reactionQueue.length == 0) {\r\n            this.memory.reactionQueue = this.colony.abathur.getReactionQueue();\r\n        }\r\n        // Switch to next reaction on the queue if you are idle\r\n        if (this.memory.status == LabStatus.Idle) {\r\n            this.memory.activeReaction = this.memory.reactionQueue.shift();\r\n        }\r\n        // Set boosting lab reservations and compute needed resources\r\n        for (const mineralType in this.neededBoosts) {\r\n            if (this.neededBoosts[mineralType] == 0)\r\n                continue;\r\n            let boostLab;\r\n            for (const id in this.labReservations) { // find a lab already reserved for this mineral type\r\n                if (this.labReservations[id] && this.labReservations[id].mineralType == mineralType) {\r\n                    boostLab = deref(id);\r\n                }\r\n            }\r\n            if (!boostLab) { // otherwise choose the first unreserved product lab\r\n                boostLab = _.find(this.boostingLabs, lab => !this.labReservations[lab.id]);\r\n            }\r\n            if (boostLab) {\r\n                this.reserveLab(mineralType, this.neededBoosts[mineralType], boostLab);\r\n            }\r\n        }\r\n        this.initLabStatus();\r\n        this.registerRequests();\r\n    }\r\n    run() {\r\n        // Obtain resources for boosting\r\n        for (const resourceType in this.neededBoosts) {\r\n            const needAmount = Math.max(this.neededBoosts[resourceType] - (this.colony.assets[resourceType] || 0), 0);\r\n            if (needAmount > 0) {\r\n                this.terminalNetwork.requestResource(this.terminal, resourceType, needAmount, true, 0);\r\n            }\r\n        }\r\n        // Obtain resources for reaction queue\r\n        let queue = this.memory.reactionQueue;\r\n        if (this.memory.activeReaction && this.memory.status == LabStatus.AcquiringMinerals) {\r\n            queue = [this.memory.activeReaction].concat(queue);\r\n        }\r\n        const missingBasicMinerals = this.colony.abathur.getMissingBasicMinerals(queue);\r\n        for (const resourceType in missingBasicMinerals) {\r\n            if (missingBasicMinerals[resourceType] > 0) {\r\n                this.terminalNetwork.requestResource(this.terminal, resourceType, missingBasicMinerals[resourceType], true);\r\n            }\r\n        }\r\n        // Run the reactions\r\n        if (this.memory.status == LabStatus.Synthesizing) {\r\n            const [lab1, lab2] = this.reagentLabs;\r\n            for (const lab of this.productLabs) {\r\n                if (lab.cooldown == 0 && !this.labReservations[lab.id]) {\r\n                    const result = lab.runReaction(lab1, lab2);\r\n                    if (result == OK) { // update total production amount in memory\r\n                        const product = this.memory.activeReaction ? this.memory.activeReaction.mineralType : 'ERROR';\r\n                        if (!this.memory.stats.totalProduction[product]) {\r\n                            this.memory.stats.totalProduction[product] = 0;\r\n                        }\r\n                        this.memory.stats.totalProduction[product] += LAB_REACTION_AMOUNT;\r\n                    }\r\n                    else {\r\n                        log.debug(`Couldn't run reaction for lab @ ${lab.pos.print}! Result: ${result}`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Record stats\r\n        this.stats();\r\n    }\r\n    drawLabReport(coord) {\r\n        let { x, y } = coord;\r\n        const height = 2;\r\n        const titleCoords = Visualizer.section(`${this.colony.name} Evolution Chamber`, { x, y, roomName: this.room.name }, 9.5, height + .1);\r\n        const boxX = titleCoords.x;\r\n        y = titleCoords.y + 0.25;\r\n        let status;\r\n        switch (this.memory.status) {\r\n            case LabStatus.Idle:\r\n                status = 'IDLE';\r\n                break;\r\n            case LabStatus.AcquiringMinerals:\r\n                status = 'acquire minerals';\r\n                break;\r\n            case LabStatus.LoadingLabs:\r\n                status = 'loading labs';\r\n                break;\r\n            case LabStatus.Synthesizing:\r\n                status = 'synthesizing';\r\n                break;\r\n            case LabStatus.UnloadingLabs:\r\n                status = 'unloading labs';\r\n                break;\r\n            default:\r\n                status = 'INVALID';\r\n                break;\r\n        }\r\n        const activeReaction = this.memory.activeReaction;\r\n        const mineral = activeReaction ? activeReaction.mineralType : 'NONE';\r\n        Visualizer.text(`Status: ${status}`, { x: boxX, y: y, roomName: this.room.name });\r\n        y += 1;\r\n        if (this.memory.status == LabStatus.Synthesizing && activeReaction) {\r\n            const amountDone = _.sum(_.map(this.productLabs, lab => lab.mineralType == activeReaction.mineralType ? lab.mineralAmount : 0));\r\n            Visualizer.text(activeReaction.mineralType, { x: boxX, y: y, roomName: this.room.name });\r\n            Visualizer.barGraph([amountDone, activeReaction.amount], { x: boxX + 4, y: y, roomName: this.room.name }, 5);\r\n            y += 1;\r\n        }\r\n        else {\r\n            Visualizer.text(`Active reaction: ${mineral}`, { x: boxX, y: y, roomName: this.room.name });\r\n            y += 1;\r\n        }\r\n        return { x: x, y: y + .25 };\r\n    }\r\n    visuals(coord) {\r\n        const vis = this.room.visual;\r\n        // Lab visuals\r\n        for (const lab of this.labs) {\r\n            if (lab.mineralType) {\r\n                vis.resource(lab.mineralType, lab.pos.x, lab.pos.y);\r\n            }\r\n        }\r\n        // Draw lab report\r\n        return this.drawLabReport(coord);\r\n    }\r\n    stats() {\r\n        Stats.log(`colonies.${this.colony.name}.evolutionChamber.totalProduction`, this.memory.stats.totalProduction);\r\n        const labUsage = _.sum(this.productLabs, lab => lab.cooldown > 0 ? 1 : 0) / this.productLabs.length;\r\n        this.memory.stats.avgUsage = exponentialMovingAverage(labUsage, this.memory.stats.avgUsage, LAB_USAGE_WINDOW);\r\n        Stats.log(`colonies.${this.colony.name}.evolutionChamber.avgUsage`, this.memory.stats.avgUsage);\r\n    }\r\n};\r\nEvolutionChamber.settings = {};\r\nEvolutionChamber = EvolutionChamber_1 = tslib_1.__decorate([\r\n    profile\r\n], EvolutionChamber);\r\nexport { EvolutionChamber };\r\n","references":["C:/git/Screeps-Revamped/src/caching/GlobalCache.ts","C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/logistics/TerminalNetwork.ts","C:/git/Screeps-Revamped/src/logistics/TradeNetwork.ts","C:/git/Screeps-Revamped/src/logistics/TransportRequestGroup.ts","C:/git/Screeps-Revamped/src/memory/Memory.ts","C:/git/Screeps-Revamped/src/movement/Pathing.ts","C:/git/Screeps-Revamped/src/priorities/priorities.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/resources/Abathur.ts","C:/git/Screeps-Revamped/src/resources/map_resources.ts","C:/git/Screeps-Revamped/src/stats/stats.ts","C:/git/Screeps-Revamped/src/utilities/stringConstants.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts","C:/git/Screeps-Revamped/src/visuals/Visualizer.ts","C:/git/Screeps-Revamped/src/zerg/Zerg.ts","C:/git/Screeps-Revamped/src/hiveClusters/_HiveCluster.ts"]}
