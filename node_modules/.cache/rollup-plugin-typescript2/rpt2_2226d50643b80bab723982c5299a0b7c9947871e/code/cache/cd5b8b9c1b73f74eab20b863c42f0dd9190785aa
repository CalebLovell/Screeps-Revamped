{"code":"import * as tslib_1 from \"tslib\";\r\nvar RoadPlanner_1;\r\nimport { $ } from '../caching/GlobalCache';\r\nimport { getAllColonies } from '../Colony';\r\nimport { log } from '../console/log';\r\nimport { Mem } from '../memory/Memory';\r\nimport { MatrixTypes, Pathing } from '../movement/Pathing';\r\nimport { profile } from '../profiler/decorator';\r\nimport { getCacheExpiration, onPublicServer } from '../utilities/utils';\r\nimport { Visualizer } from '../visuals/Visualizer';\r\nimport { RoomPlanner } from './RoomPlanner';\r\nconst PLAIN_COST = 3;\r\nconst SWAMP_COST = 4;\r\nconst WALL_COST = 15 * PLAIN_COST;\r\nconst EXISTING_PATH_COST = PLAIN_COST - 1;\r\nconst memoryDefaults = {\r\n    roadLookup: {},\r\n    roadCoverage: 0.0,\r\n    roadCoverages: {}\r\n};\r\nlet RoadPlanner = RoadPlanner_1 = class RoadPlanner {\r\n    constructor(roomPlanner) {\r\n        this.roomPlanner = roomPlanner;\r\n        this.colony = roomPlanner.colony;\r\n        this.memory = Mem.wrap(this.colony.memory, 'roadPlanner', memoryDefaults);\r\n        this.costMatrices = {};\r\n        this.roadPositions = [];\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(this.colony.memory, 'roadPlanner', memoryDefaults);\r\n        this.costMatrices = {};\r\n        this.roadPositions = [];\r\n    }\r\n    get roadCoverage() {\r\n        return this.memory.roadCoverage;\r\n    }\r\n    recomputeRoadCoverages(storagePos) {\r\n        // Compute coverage for each path\r\n        for (const destination of this.colony.destinations) {\r\n            const destName = destination.pos.name;\r\n            if (!this.memory.roadCoverages[destName] || Game.time > this.memory.roadCoverages[destName].exp) {\r\n                const roadCoverage = this.computeRoadCoverage(storagePos, destination.pos);\r\n                if (roadCoverage != undefined) {\r\n                    // Set expiration to be longer if road is nearly complete\r\n                    const expiration = roadCoverage.roadCount / roadCoverage.length >= 0.75\r\n                        ? getCacheExpiration(RoadPlanner_1.settings.recomputeCoverageInterval)\r\n                        : getCacheExpiration(3 * RoadPlanner_1.settings.recomputeCoverageInterval);\r\n                    this.memory.roadCoverages[destName] = {\r\n                        roadCount: roadCoverage.roadCount,\r\n                        length: roadCoverage.length,\r\n                        exp: expiration\r\n                    };\r\n                }\r\n                else {\r\n                    if (this.memory.roadCoverages[destName]) {\r\n                        // if you already have some data, use it for a little while\r\n                        const waitTime = onPublicServer() ? 500 : 200;\r\n                        this.memory.roadCoverages[destName].exp += waitTime;\r\n                    }\r\n                    else {\r\n                        // otherwise put in a placeholder\r\n                        const waitTime = onPublicServer() ? 300 : 100;\r\n                        this.memory.roadCoverages[destName] = {\r\n                            roadCount: 0,\r\n                            length: 1,\r\n                            exp: Game.time + waitTime\r\n                        };\r\n                    }\r\n                }\r\n                log.debug(`Recomputing road coverage from ${storagePos.print} to ${destination.pos.print}... ` +\r\n                    `Coverage: ${JSON.stringify(roadCoverage)}`);\r\n            }\r\n        }\r\n        // Store the aggregate roadCoverage score\r\n        let totalRoadCount = 0;\r\n        let totalPathLength = 0;\r\n        for (const destName in this.memory.roadCoverages) {\r\n            const { roadCount, length, exp } = this.memory.roadCoverages[destName];\r\n            totalRoadCount += roadCount;\r\n            totalPathLength += length;\r\n        }\r\n        this.memory.roadCoverage = totalRoadCount / totalPathLength;\r\n    }\r\n    computeRoadCoverage(storagePos, destination) {\r\n        const ret = Pathing.findPath(storagePos, destination, { terrainCosts: { plainCost: 2, swampCost: 10 } });\r\n        const path = ret.path;\r\n        const roomNames = _.unique(_.map(path, pos => pos.roomName));\r\n        // If you have vision or cached vision of the room\r\n        if (_.all(roomNames, roomName => Game.rooms[roomName] || $.costMatrixRecall(roomName, MatrixTypes.default))) {\r\n            let roadCount = 0;\r\n            for (const pos of path) {\r\n                if (Game.rooms[pos.roomName]) {\r\n                    if (pos.lookForStructure(STRUCTURE_ROAD)) {\r\n                        roadCount++;\r\n                    }\r\n                }\r\n                else {\r\n                    const mat = $.costMatrixRecall(pos.roomName, MatrixTypes.default);\r\n                    if (mat) {\r\n                        if (mat.get(pos.x, pos.y) == 1) {\r\n                            roadCount++;\r\n                        }\r\n                    }\r\n                    else { // shouldn't happen\r\n                        log.warning(`No vision or recalled cost matrix in room ${pos.roomName}! (Why?)`);\r\n                    }\r\n                }\r\n            }\r\n            return { roadCount: roadCount, length: path.length };\r\n        }\r\n    }\r\n    recalculateRoadNetwork(storagePos, obstacles) {\r\n        this.buildRoadNetwork(storagePos, obstacles);\r\n        this.finalize();\r\n    }\r\n    // Connect commandCenter to hatchery, upgradeSites, and all miningSites, and place containers\r\n    buildRoadNetwork(storagePos, obstacles) {\r\n        this.costMatrices = {};\r\n        this.roadPositions = [];\r\n        const destinations = _.sortBy(this.colony.destinations, destination => destination.order);\r\n        // Connect commandCenter to each destination in colony\r\n        for (const destination of destinations) {\r\n            this.planRoad(storagePos, destination.pos, obstacles);\r\n        }\r\n        this.formatRoadPositions();\r\n    }\r\n    // Plan a road between two locations avoiding a list of planned obstacles; pos1 should be storage for best results\r\n    planRoad(pos1, pos2, obstacles) {\r\n        // Find the shortest path, preferentially stepping on tiles with road routing flags on them\r\n        const roadPath = this.generateRoadPath(pos1, pos2, obstacles);\r\n        if (roadPath) {\r\n            this.roadPositions = this.roadPositions.concat(roadPath);\r\n        }\r\n    }\r\n    generateRoadPlanningCostMatrix(roomName, obstacles) {\r\n        const matrix = new PathFinder.CostMatrix();\r\n        const terrain = Game.map.getRoomTerrain(roomName);\r\n        for (let y = 0; y < 50; ++y) {\r\n            for (let x = 0; x < 50; ++x) {\r\n                switch (terrain.get(x, y)) {\r\n                    case TERRAIN_MASK_SWAMP:\r\n                        matrix.set(x, y, SWAMP_COST);\r\n                        break;\r\n                    case TERRAIN_MASK_WALL:\r\n                        if (x != 0 && y != 0 && x != 49 && y != 49) {\r\n                            // Can't tunnel through walls on edge tiles\r\n                            matrix.set(x, y, WALL_COST);\r\n                        }\r\n                        break;\r\n                    default: // plain\r\n                        matrix.set(x, y, PLAIN_COST);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        for (const pos of obstacles) {\r\n            if (pos.roomName == roomName) {\r\n                matrix.set(pos.x, pos.y, 0xff);\r\n            }\r\n        }\r\n        const room = Game.rooms[roomName];\r\n        if (room) {\r\n            const impassibleStructures = [];\r\n            _.forEach(room.find(FIND_STRUCTURES), (s) => {\r\n                if (!s.isWalkable) {\r\n                    impassibleStructures.push(s);\r\n                }\r\n            });\r\n            _.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));\r\n            // Set passability of construction sites\r\n            _.forEach(room.find(FIND_MY_CONSTRUCTION_SITES), (site) => {\r\n                if (!site.isWalkable) {\r\n                    matrix.set(site.pos.x, site.pos.y, 0xff);\r\n                }\r\n            });\r\n        }\r\n        return matrix;\r\n    }\r\n    /* Generates a road path and modifies cost matrices to encourage merging with future roads */\r\n    generateRoadPath(origin, destination, obstacles) {\r\n        const callback = (roomName) => {\r\n            if (!this.colony.roomNames.includes(roomName)) { // only route through colony rooms\r\n                return false;\r\n            }\r\n            if (Pathing.shouldAvoid(roomName) && roomName != origin.roomName && roomName != destination.roomName) {\r\n                return false;\r\n            }\r\n            if (!this.costMatrices[roomName]) {\r\n                this.costMatrices[roomName] = this.generateRoadPlanningCostMatrix(roomName, obstacles);\r\n            }\r\n            return this.costMatrices[roomName];\r\n        };\r\n        const ret = PathFinder.search(origin, { pos: destination, range: 1 }, { roomCallback: callback, maxOps: 40000 });\r\n        if (ret.incomplete) {\r\n            log.warning(`Roadplanner for ${this.colony.print}: could not plan road path!`);\r\n            return;\r\n        }\r\n        // Reduce the cost of planned paths to encourage road overlap for future pathing\r\n        if (RoadPlanner_1.settings.encourageRoadMerging) {\r\n            for (const i of _.range(ret.path.length)) {\r\n                const pos = ret.path[i];\r\n                if (i % 2 == 0 && this.costMatrices[pos.roomName] && !pos.isEdge) {\r\n                    this.costMatrices[pos.roomName].set(pos.x, pos.y, EXISTING_PATH_COST);\r\n                }\r\n            }\r\n        }\r\n        // Return the pathfinder results\r\n        return ret.path;\r\n    }\r\n    /* Ensure that the roads doesn't overlap with roads from this.map and that the positions are unique */\r\n    formatRoadPositions() {\r\n        // Make road position list unique\r\n        this.roadPositions = _.unique(this.roadPositions);\r\n        // Remove roads located on exit tiles\r\n        _.remove(this.roadPositions, pos => pos.isEdge);\r\n        // Remove any roads duplicated in this.map\r\n        const roomPlannerRoads = this.roomPlanner.plannedStructurePositions(STRUCTURE_ROAD);\r\n        if (roomPlannerRoads != undefined) {\r\n            _.remove(this.roadPositions, pos => roomPlannerRoads.includes(pos));\r\n        }\r\n    }\r\n    /* Write everything to memory after roomPlanner is closed */\r\n    finalize() {\r\n        // Collect all roads from this and from room planner\r\n        let roomPlannerRoads;\r\n        if (_.keys(this.roomPlanner.map).length > 0) { // use active map\r\n            roomPlannerRoads = this.roomPlanner.map[STRUCTURE_ROAD];\r\n        }\r\n        else { // retrieve from memory\r\n            if (this.roomPlanner.memory.bunkerData && this.roomPlanner.memory.bunkerData.anchor) {\r\n                const layout = this.roomPlanner.getStructureMapForBunkerAt(this.roomPlanner.memory.bunkerData.anchor);\r\n                roomPlannerRoads = layout[STRUCTURE_ROAD];\r\n            }\r\n            else if (this.roomPlanner.memory.mapsByLevel) {\r\n                roomPlannerRoads = _.map(this.roomPlanner.memory.mapsByLevel[8][STRUCTURE_ROAD], protoPos => derefRoomPosition(protoPos));\r\n            }\r\n            else {\r\n                log.error(`RoadPlanner@${this.colony.room.print}: could not get road positions from room planner!`);\r\n                roomPlannerRoads = [];\r\n            }\r\n        }\r\n        const allRoadPos = _.compact(this.roadPositions.concat(roomPlannerRoads));\r\n        // Encode the coordinates of the road as keys in a truthy hash table for fast lookup\r\n        this.memory.roadLookup = {};\r\n        for (const pos of allRoadPos) {\r\n            if (!this.memory.roadLookup[pos.roomName])\r\n                this.memory.roadLookup[pos.roomName] = {};\r\n            this.memory.roadLookup[pos.roomName][pos.coordName] = true;\r\n        }\r\n    }\r\n    init() {\r\n    }\r\n    static shouldBuild(structureType, pos) {\r\n        if (!pos.room)\r\n            return false;\r\n        const buildings = _.filter(pos.lookFor(LOOK_STRUCTURES), s => s && s.structureType == structureType);\r\n        const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);\r\n        if (!buildings || buildings.length == 0) {\r\n            if (!sites || sites.length == 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /* Create construction sites for any buildings that need to be built */\r\n    buildMissing() {\r\n        // Max buildings that can be placed each tick\r\n        let count = RoomPlanner.settings.maxSitesPerColony - this.colony.constructionSites.length;\r\n        // Build missing roads\r\n        let roadPositions = [];\r\n        for (const roomName in this.memory.roadLookup) {\r\n            for (const coords of _.keys(this.memory.roadLookup[roomName])) {\r\n                const [x, y] = coords.split(':');\r\n                roadPositions.push(new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName));\r\n            }\r\n        }\r\n        const origin = (this.colony.storage || this.colony.hatchery || this.colony).pos;\r\n        roadPositions = _.sortBy(roadPositions, pos => pos.getMultiRoomRangeTo(origin));\r\n        for (const pos of roadPositions) {\r\n            if (count > 0 && RoomPlanner.canBuild(STRUCTURE_ROAD, pos)) {\r\n                const ret = pos.createConstructionSite(STRUCTURE_ROAD);\r\n                if (ret != OK) {\r\n                    log.warning(`${this.colony.name}: couldn't create road site at ${pos.print}. Result: ${ret}`);\r\n                }\r\n                else {\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /* Quick lookup for if a road should be in this position. Roads returning false won't be maintained. */\r\n    roadShouldBeHere(pos) {\r\n        // Initial migration code, can delete later\r\n        if (this.memory.roadLookup[pos.roomName]) {\r\n            return this.memory.roadLookup[pos.roomName][pos.coordName];\r\n        }\r\n        return false;\r\n    }\r\n    run() {\r\n        if (this.roomPlanner.active) {\r\n            if (this.roomPlanner.storagePos) {\r\n                this.buildRoadNetwork(this.roomPlanner.storagePos, this.roomPlanner.getObstacles());\r\n            }\r\n            this.visuals();\r\n        }\r\n        else {\r\n            // Once in a blue moon, recalculate the entire network and write to memory to keep it up to date\r\n            if (Game.time % RoadPlanner_1.settings.recalculateRoadNetworkInterval == this.colony.id) {\r\n                if (this.roomPlanner.storagePos) {\r\n                    this.recalculateRoadNetwork(this.roomPlanner.storagePos, this.roomPlanner.getObstacles());\r\n                }\r\n            }\r\n            // Recompute coverage to destinations\r\n            if (Game.time % getAllColonies().length == this.colony.id && this.roomPlanner.storagePos) {\r\n                this.recomputeRoadCoverages(this.roomPlanner.storagePos);\r\n            }\r\n            // Build missing roads\r\n            if (this.colony.level >= RoadPlanner_1.settings.buildRoadsAtRCL && this.roomPlanner.shouldRecheck(3)) {\r\n                this.buildMissing();\r\n            }\r\n        }\r\n    }\r\n    visuals() {\r\n        // Draw the map\r\n        Visualizer.drawRoads(this.roadPositions);\r\n    }\r\n};\r\nRoadPlanner.settings = {\r\n    encourageRoadMerging: true,\r\n    recalculateRoadNetworkInterval: onPublicServer() ? 3000 : 1000,\r\n    recomputeCoverageInterval: onPublicServer() ? 1000 : 500,\r\n    buildRoadsAtRCL: 4,\r\n};\r\nRoadPlanner = RoadPlanner_1 = tslib_1.__decorate([\r\n    profile\r\n], RoadPlanner);\r\nexport { RoadPlanner };\r\n","references":["C:/git/Screeps-Revamped/src/caching/GlobalCache.ts","C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/memory/Memory.ts","C:/git/Screeps-Revamped/src/movement/Pathing.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts","C:/git/Screeps-Revamped/src/visuals/Visualizer.ts","C:/git/Screeps-Revamped/src/roomPlanner/RoomPlanner.ts"]}
