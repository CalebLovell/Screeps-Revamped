{"code":"import * as tslib_1 from \"tslib\";\r\nvar UpgradeSite_1;\r\nimport { $ } from '../caching/GlobalCache';\r\nimport { ColonyStage } from '../Colony';\r\nimport { log } from '../console/log';\r\nimport { Mem } from '../memory/Memory';\r\nimport { UpgradingOverlord } from '../overlords/core/upgrader';\r\nimport { profile } from '../profiler/decorator';\r\nimport { Stats } from '../stats/stats';\r\nimport { hasMinerals } from '../utilities/utils';\r\nimport { HiveCluster } from './_HiveCluster';\r\n/**\r\n * Upgrade sites group upgrade-related structures around a controller, such as an input link and energy container\r\n */\r\nlet UpgradeSite = UpgradeSite_1 = class UpgradeSite extends HiveCluster {\r\n    constructor(colony, controller) {\r\n        super(colony, controller, 'upgradeSite');\r\n        this.controller = controller;\r\n        this.memory = Mem.wrap(this.colony.memory, 'upgradeSite');\r\n        this.upgradePowerNeeded = this.getUpgradePowerNeeded();\r\n        // Register bettery\r\n        $.set(this, 'battery', () => {\r\n            const allowableContainers = _.filter(this.room.containers, container => container.pos.findInRange(FIND_SOURCES, 1).length == 0); // only count containers that aren't near sources\r\n            return this.pos.findClosestByLimitedRange(allowableContainers, 3);\r\n        });\r\n        this.batteryPos = $.pos(this, 'batteryPos', () => {\r\n            if (this.battery) {\r\n                return this.battery.pos;\r\n            }\r\n            const inputSite = this.findInputConstructionSite();\r\n            if (inputSite) {\r\n                return inputSite.pos;\r\n            }\r\n            return this.calculateBatteryPos() || log.alert(`Upgrade site at ${this.pos.print}: no batteryPos!`);\r\n        });\r\n        if (this.batteryPos)\r\n            this.colony.destinations.push({ pos: this.batteryPos, order: 0 });\r\n        // Register link\r\n        $.set(this, 'link', () => this.pos.findClosestByLimitedRange(colony.availableLinks, 3));\r\n        this.colony.linkNetwork.claimLink(this.link);\r\n        // // Energy per tick is sum of upgrader body parts and nearby worker body parts\r\n        // this.energyPerTick = $.number(this, 'energyPerTick', () =>\r\n        // \t_.sum(this.overlord.upgraders, upgrader => upgrader.getActiveBodyparts(WORK)) +\r\n        // \t_.sum(_.filter(this.colony.getCreepsByRole(WorkerSetup.role), worker =>\r\n        // \t\t\t  worker.pos.inRangeTo((this.link || this.battery || this).pos, 2)),\r\n        // \t\t  worker => worker.getActiveBodyparts(WORK)));\r\n        // Compute stats\r\n        this.stats();\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(this.colony.memory, 'upgradeSite');\r\n        $.refreshRoom(this);\r\n        $.refresh(this, 'controller', 'battery', 'link');\r\n    }\r\n    spawnMoarOverlords() {\r\n        // Register overlord\r\n        this.overlord = new UpgradingOverlord(this);\r\n    }\r\n    findInputConstructionSite() {\r\n        const nearbyInputSites = this.pos.findInRange(this.room.constructionSites, 4, {\r\n            filter: (s) => s.structureType == STRUCTURE_CONTAINER ||\r\n                s.structureType == STRUCTURE_LINK,\r\n        });\r\n        return _.first(nearbyInputSites);\r\n    }\r\n    getUpgradePowerNeeded() {\r\n        return $.number(this, 'upgradePowerNeeded', () => {\r\n            if (this.room.storage) { // Workers perform upgrading until storage is set up\r\n                const amountOver = Math.max(this.colony.assets.energy - UpgradeSite_1.settings.energyBuffer, 0);\r\n                let upgradePower = 1 + Math.floor(amountOver / UpgradeSite_1.settings.energyPerBodyUnit);\r\n                if (amountOver > 800000) {\r\n                    upgradePower *= 4; // double upgrade power if we have lots of surplus energy\r\n                }\r\n                else if (amountOver > 500000) {\r\n                    upgradePower *= 2;\r\n                }\r\n                if (this.controller.level == 8) {\r\n                    upgradePower = Math.min(upgradePower, 15); // don't go above 15 work parts at RCL 8\r\n                }\r\n                return upgradePower;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        });\r\n    }\r\n    init() {\r\n        // Register energy requests\r\n        if (this.link && this.link.energy < UpgradeSite_1.settings.linksRequestBelow) {\r\n            this.colony.linkNetwork.requestReceive(this.link);\r\n        }\r\n        const inThreshold = this.colony.stage > ColonyStage.Larva ? 0.5 : 0.75;\r\n        if (this.battery) {\r\n            if (this.battery.energy < inThreshold * this.battery.storeCapacity) {\r\n                const energyPerTick = UPGRADE_CONTROLLER_POWER * this.upgradePowerNeeded;\r\n                this.colony.logisticsNetwork.requestInput(this.battery, { dAmountdt: energyPerTick });\r\n            }\r\n            if (hasMinerals(this.battery.store)) { // get rid of any minerals in the container if present\r\n                this.colony.logisticsNetwork.requestOutputMinerals(this.battery);\r\n            }\r\n        }\r\n    }\r\n    /* Calculate where the input will be built for this site */\r\n    calculateBatteryPos() {\r\n        let originPos;\r\n        if (this.colony.storage) {\r\n            originPos = this.colony.storage.pos;\r\n        }\r\n        else if (this.colony.roomPlanner.storagePos) {\r\n            originPos = this.colony.roomPlanner.storagePos;\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        // Find all positions at range 2 from controller\r\n        let inputLocations = [];\r\n        for (const pos of this.pos.getPositionsAtRange(2)) {\r\n            if (pos.isWalkable(true)) {\r\n                inputLocations.push(pos);\r\n            }\r\n        }\r\n        // Try to find locations where there is maximal standing room\r\n        const maxNeighbors = _.max(_.map(inputLocations, pos => pos.availableNeighbors(true).length));\r\n        inputLocations = _.filter(inputLocations, pos => pos.availableNeighbors(true).length >= maxNeighbors);\r\n        // Return location closest to storage by path\r\n        const inputPos = originPos.findClosestByPath(inputLocations);\r\n        if (inputPos) {\r\n            return inputPos;\r\n        }\r\n    }\r\n    /* Build a container output at the optimal location */\r\n    buildBatteryIfMissing() {\r\n        if (!this.battery && !this.findInputConstructionSite()) {\r\n            const buildHere = this.batteryPos;\r\n            if (buildHere) {\r\n                const result = buildHere.createConstructionSite(STRUCTURE_CONTAINER);\r\n                if (result == OK) {\r\n                    return;\r\n                }\r\n                else {\r\n                    log.warning(`Upgrade site at ${this.pos.print}: cannot build battery! Result: ${result}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    stats() {\r\n        const defaults = {\r\n            downtime: 0,\r\n        };\r\n        if (!this.memory.stats)\r\n            this.memory.stats = defaults;\r\n        _.defaults(this.memory.stats, defaults);\r\n        // Compute downtime\r\n        this.memory.stats.downtime = (this.memory.stats.downtime * (CREEP_LIFE_TIME - 1) +\r\n            (this.battery ? +this.battery.isEmpty : 0)) / CREEP_LIFE_TIME;\r\n        Stats.log(`colonies.${this.colony.name}.upgradeSite.downtime`, this.memory.stats.downtime);\r\n    }\r\n    run() {\r\n        if (Game.time % 25 == 7 && this.colony.level >= 2) {\r\n            this.buildBatteryIfMissing();\r\n        }\r\n    }\r\n    visuals() {\r\n        // let info = [];\r\n        // if (this.controller.level != 8) {\r\n        // \tlet progress = `${Math.floor(this.controller.progress / 1000)}K`;\r\n        // \tlet progressTotal = `${Math.floor(this.controller.progressTotal / 1000)}K`;\r\n        // \tlet percent = `${Math.floor(100 * this.controller.progress / this.controller.progressTotal)}`;\r\n        // \tinfo.push(`Progress: ${progress}/${progressTotal} (${percent}%)`);\r\n        //\r\n        // }\r\n        // info.push(`Downtime: ${this.memory.stats.downtime.toPercent()}`);\r\n        // Visualizer.showInfo(info, this);\r\n    }\r\n};\r\n// energyPerTick: number;\r\nUpgradeSite.settings = {\r\n    energyBuffer: 100000,\r\n    energyPerBodyUnit: 10000,\r\n    minLinkDistance: 10,\r\n    linksRequestBelow: 200,\r\n};\r\nUpgradeSite = UpgradeSite_1 = tslib_1.__decorate([\r\n    profile\r\n], UpgradeSite);\r\nexport { UpgradeSite };\r\n","references":["C:/git/Screeps-Revamped/src/caching/GlobalCache.ts","C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/memory/Memory.ts","C:/git/Screeps-Revamped/src/overlords/core/upgrader.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/stats/stats.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts","C:/git/Screeps-Revamped/src/hiveClusters/_HiveCluster.ts"]}
