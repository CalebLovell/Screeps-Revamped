{"code":"import * as tslib_1 from \"tslib\";\r\nimport { assimilationLocked } from '../assimilation/decorator';\r\nimport { getAllColonies } from '../Colony';\r\nimport { log } from '../console/log';\r\nimport { DirectiveColonize } from '../directives/colony/colonize';\r\nimport { Autonomy, getAutonomyLevel, Mem } from '../memory/Memory';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { profile } from '../profiler/decorator';\r\nimport { Cartographer } from '../utilities/Cartographer';\r\nimport { maxBy } from '../utilities/utils';\r\nimport { MAX_OWNED_ROOMS, SHARD3_MAX_OWNED_ROOMS } from '../~settings';\r\nimport { MIN_EXPANSION_DISTANCE } from './ExpansionEvaluator';\r\nconst CHECK_EXPANSION_FREQUENCY = 1000;\r\nconst UNOWNED_MINERAL_BONUS = 100;\r\nconst CATALYST_BONUS = 75;\r\nconst MAX_SCORE_BONUS = _.sum([UNOWNED_MINERAL_BONUS, CATALYST_BONUS]);\r\nconst TOO_CLOSE_PENALTY = 100;\r\nconst defaultExpansionPlannerMemory = {};\r\nlet ExpansionPlanner = class ExpansionPlanner {\r\n    constructor() {\r\n        this.memory = Mem.wrap(Memory, 'expansionPlanner', defaultExpansionPlannerMemory);\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(Memory, 'expansionPlanner', defaultExpansionPlannerMemory);\r\n    }\r\n    handleExpansion() {\r\n        const allColonies = getAllColonies();\r\n        // If you already have max number of colonies, ignore\r\n        if (allColonies.length >= Math.min(Game.gcl.level, MAX_OWNED_ROOMS)) {\r\n            return;\r\n        }\r\n        // If you are on shard3, limit to 3 owned rooms // TODO: use CPU-based limiting metric\r\n        if (Game.shard.name == 'shard3') {\r\n            if (allColonies.length >= SHARD3_MAX_OWNED_ROOMS) {\r\n                return;\r\n            }\r\n        }\r\n        const roomName = this.chooseNextColonyRoom();\r\n        if (roomName) {\r\n            const pos = Pathing.findPathablePosition(roomName);\r\n            DirectiveColonize.createIfNotPresent(pos, 'room');\r\n            log.notify(`Room ${roomName} selected as next colony! Creating colonization directive.`);\r\n        }\r\n    }\r\n    chooseNextColonyRoom() {\r\n        // Generate a list of possible colonies to expand from based on level and whether they are already expanding\r\n        // let possibleIncubators: Colony[] = []; // TODO: support incubation\r\n        const possibleColonizers = [];\r\n        for (const colony of getAllColonies()) {\r\n            // if (colony.level >= DirectiveIncubate.requiredRCL\r\n            // \t&& _.filter(colony.flags, flag => DirectiveIncubate.filter(flag)).length == 0) {\r\n            // \tpossibleIncubators.push(colony);\r\n            // }\r\n            if (colony.level >= DirectiveColonize.requiredRCL\r\n                && _.filter(colony.flags, flag => DirectiveColonize.filter(flag)).length == 0) {\r\n                possibleColonizers.push(colony);\r\n            }\r\n        }\r\n        const possibleBestExpansions = _.compact(_.map(possibleColonizers, col => this.getBestExpansionRoomFor(col)));\r\n        log.debug(JSON.stringify(possibleBestExpansions));\r\n        const bestExpansion = maxBy(possibleBestExpansions, choice => choice.score);\r\n        if (bestExpansion) {\r\n            log.alert(`Next expansion chosen: ${bestExpansion.roomName} with score ${bestExpansion.score}`);\r\n            return bestExpansion.roomName;\r\n        }\r\n        else {\r\n            log.alert(`No viable expansion rooms found!`);\r\n        }\r\n    }\r\n    getBestExpansionRoomFor(colony) {\r\n        const allColonyRooms = _.zipObject(_.map(getAllColonies(), col => [col.room.name, true]));\r\n        const allOwnedMinerals = _.map(getAllColonies(), col => col.room.mineral.mineralType);\r\n        let bestRoom = '';\r\n        let bestScore = -Infinity;\r\n        for (const roomName in colony.memory.expansionData.possibleExpansions) {\r\n            let score = colony.memory.expansionData.possibleExpansions[roomName];\r\n            if (typeof score != 'number')\r\n                continue;\r\n            // Compute modified score\r\n            if (score + MAX_SCORE_BONUS > bestScore) {\r\n                // Is the room too close to an existing colony?\r\n                const range2Rooms = Cartographer.findRoomsInRange(roomName, MIN_EXPANSION_DISTANCE);\r\n                if (_.any(range2Rooms, roomName => allColonyRooms[roomName])) {\r\n                    continue; // too close to another colony\r\n                }\r\n                const range3Rooms = Cartographer.findRoomsInRange(roomName, MIN_EXPANSION_DISTANCE + 1);\r\n                if (_.any(range3Rooms, roomName => allColonyRooms[roomName])) {\r\n                    score -= TOO_CLOSE_PENALTY;\r\n                }\r\n                // Are there powerful hostile rooms nearby?\r\n                const adjacentRooms = Cartographer.findRoomsInRange(roomName, 1);\r\n                if (_.any(adjacentRooms, roomName => Memory.rooms[roomName][\"a\" /* AVOID */])) {\r\n                    continue;\r\n                }\r\n                // Reward new minerals and catalyst rooms\r\n                const mineralType = Memory.rooms[roomName][\"m\" /* MINERAL */]\r\n                    ? Memory.rooms[roomName][\"m\" /* MINERAL */][\"t\" /* MINERALTYPE */]\r\n                    : undefined;\r\n                if (mineralType) {\r\n                    if (!allOwnedMinerals.includes(mineralType)) {\r\n                        score += UNOWNED_MINERAL_BONUS;\r\n                    }\r\n                    if (mineralType == RESOURCE_CATALYST) {\r\n                        score += CATALYST_BONUS;\r\n                    }\r\n                }\r\n                // Update best choices\r\n                if (score > bestScore && Game.map.isRoomAvailable(roomName)) {\r\n                    bestScore = score;\r\n                    bestRoom = roomName;\r\n                }\r\n            }\r\n        }\r\n        if (bestRoom != '') {\r\n            return { roomName: bestRoom, score: bestScore };\r\n        }\r\n    }\r\n    init() {\r\n    }\r\n    run() {\r\n        if (Game.time % CHECK_EXPANSION_FREQUENCY == 17 && getAutonomyLevel() == Autonomy.Automatic) {\r\n            this.handleExpansion();\r\n        }\r\n    }\r\n};\r\nExpansionPlanner = tslib_1.__decorate([\r\n    assimilationLocked,\r\n    profile\r\n], ExpansionPlanner);\r\nexport { ExpansionPlanner };\r\n","references":["C:/git/Screeps-Revamped/src/assimilation/decorator.ts","C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/directives/colony/colonize.ts","C:/git/Screeps-Revamped/src/memory/Memory.ts","C:/git/Screeps-Revamped/src/movement/Pathing.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/utilities/Cartographer.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts","C:/git/Screeps-Revamped/src/~settings.ts","C:/git/Screeps-Revamped/src/strategy/ExpansionEvaluator.ts"]}
