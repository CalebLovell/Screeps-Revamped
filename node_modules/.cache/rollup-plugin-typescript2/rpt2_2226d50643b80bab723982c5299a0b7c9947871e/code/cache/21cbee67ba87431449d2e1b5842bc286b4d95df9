{"code":"import * as tslib_1 from \"tslib\";\r\nimport { profile } from '../profiler/decorator';\r\nimport { asciiLogo, logoComponents, logoText } from './logos';\r\nconst TEXT_COLOR = '#c9c9c9';\r\nconst TEXT_SIZE = .8;\r\nconst CHAR_WIDTH = TEXT_SIZE * 0.4;\r\nconst CHAR_HEIGHT = TEXT_SIZE * 0.9;\r\n/**\r\n * The Visualizer contains many static methods for drawing room visuals and displaying information through a GUI\r\n */\r\nlet Visualizer = class Visualizer {\r\n    static get enabled() {\r\n        return Memory.settings.enableVisuals;\r\n    }\r\n    static textStyle(size = 1, style = {}) {\r\n        return _.defaults(style, {\r\n            color: TEXT_COLOR,\r\n            align: 'left',\r\n            font: `${size * TEXT_SIZE} Trebuchet MS`,\r\n            opacity: 0.8,\r\n        });\r\n    }\r\n    static circle(pos, color = 'red', opts = {}) {\r\n        _.defaults(opts, {\r\n            fill: color,\r\n            radius: 0.35,\r\n            opacity: 0.5,\r\n        });\r\n        return new RoomVisual(pos.roomName).circle(pos.x, pos.y, opts);\r\n    }\r\n    static marker(pos, opts = {}) {\r\n        return new RoomVisual(pos.roomName).animatedPosition(pos.x, pos.y, opts);\r\n    }\r\n    static drawStructureMap(structureMap) {\r\n        if (!this.enabled)\r\n            return;\r\n        const vis = {};\r\n        for (const structureType in structureMap) {\r\n            for (const pos of structureMap[structureType]) {\r\n                if (!vis[pos.roomName]) {\r\n                    vis[pos.roomName] = new RoomVisual(pos.roomName);\r\n                }\r\n                vis[pos.roomName].structure(pos.x, pos.y, structureType);\r\n            }\r\n        }\r\n        for (const roomName in vis) {\r\n            vis[roomName].connectRoads();\r\n        }\r\n    }\r\n    static drawLayout(layout, anchor, opts = {}) {\r\n        _.defaults(opts, { opacity: 0.5 });\r\n        if (!this.enabled)\r\n            return;\r\n        const vis = new RoomVisual(anchor.roomName);\r\n        for (const structureType in layout[8].buildings) {\r\n            for (const pos of layout[8].buildings[structureType].pos) {\r\n                const dx = pos.x - layout.data.anchor.x;\r\n                const dy = pos.y - layout.data.anchor.y;\r\n                vis.structure(anchor.x + dx, anchor.y + dy, structureType, opts);\r\n            }\r\n        }\r\n        vis.connectRoads(opts);\r\n    }\r\n    static drawRoads(positoins) {\r\n        const pointsByRoom = _.groupBy(positoins, pos => pos.roomName);\r\n        for (const roomName in pointsByRoom) {\r\n            const vis = new RoomVisual(roomName);\r\n            for (const pos of pointsByRoom[roomName]) {\r\n                vis.structure(pos.x, pos.y, STRUCTURE_ROAD);\r\n            }\r\n            vis.connectRoads();\r\n        }\r\n    }\r\n    static drawPath(path, style) {\r\n        const pointsByRoom = _.groupBy(path, pos => pos.roomName);\r\n        for (const roomName in pointsByRoom) {\r\n            new RoomVisual(roomName).poly(pointsByRoom[roomName], style);\r\n        }\r\n    }\r\n    static displayCostMatrix(costMatrix, roomName, dots = true, color = '#ff0000') {\r\n        const vis = new RoomVisual(roomName);\r\n        let x, y;\r\n        if (dots) {\r\n            let cost;\r\n            let max = 1;\r\n            for (y = 0; y < 50; ++y) {\r\n                for (x = 0; x < 50; ++x) {\r\n                    max = Math.max(max, costMatrix.get(x, y));\r\n                }\r\n            }\r\n            for (y = 0; y < 50; ++y) {\r\n                for (x = 0; x < 50; ++x) {\r\n                    cost = costMatrix.get(x, y);\r\n                    if (cost > 0) {\r\n                        vis.circle(x, y, { radius: costMatrix.get(x, y) / max / 2, fill: color });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (y = 0; y < 50; ++y) {\r\n                for (x = 0; x < 50; ++x) {\r\n                    vis.text(costMatrix.get(x, y).toString(), x, y, { color: color });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static showInfo(info, calledFrom, opts = {}) {\r\n        if (calledFrom.room) {\r\n            return calledFrom.room.visual.infoBox(info, calledFrom.pos.x, calledFrom.pos.y, opts);\r\n        }\r\n        else {\r\n            return new RoomVisual(calledFrom.pos.roomName).infoBox(info, calledFrom.pos.x, calledFrom.pos.y, opts);\r\n        }\r\n    }\r\n    static section(title, pos, width, height) {\r\n        const vis = new RoomVisual(pos.roomName);\r\n        vis.rect(pos.x, pos.y - CHAR_HEIGHT, width, 1.1 * CHAR_HEIGHT, { opacity: 0.15 });\r\n        vis.box(pos.x, pos.y - CHAR_HEIGHT, width, height + (1.1 + .25) * CHAR_HEIGHT, { color: TEXT_COLOR });\r\n        vis.text(title, pos.x + .25, pos.y - .05, this.textStyle());\r\n        return { x: pos.x + 0.25, y: pos.y + 1.1 * CHAR_HEIGHT };\r\n    }\r\n    static infoBox(header, content, pos, width) {\r\n        // const vis = new RoomVisual(pos.roomName);\r\n        // vis.rect(pos.x, pos.y - charHeight, width, 1.1 * charHeight, {opacity: 0.15});\r\n        // vis.box(pos.x, pos.y - charHeight, width, ((content.length || 1) + 1.1 + .25) * charHeight,\r\n        // \t\t{color: textColor});\r\n        // vis.text(header, pos.x + .25, pos.y - .05, this.textStyle());\r\n        const height = CHAR_HEIGHT * (content.length || 1);\r\n        const { x, y } = this.section(header, pos, width, height);\r\n        if (content.length > 0) {\r\n            if (_.isArray(content[0])) {\r\n                this.table(content, {\r\n                    x: x,\r\n                    y: y,\r\n                    roomName: pos.roomName\r\n                });\r\n            }\r\n            else {\r\n                this.multitext(content, {\r\n                    x: x,\r\n                    y: y,\r\n                    roomName: pos.roomName\r\n                });\r\n            }\r\n        }\r\n        // return pos.y - charHeight + ((content.length || 1) + 1.1 + .25) * charHeight + 0.1;\r\n        const spaceBuffer = 0.5;\r\n        return y + height + spaceBuffer;\r\n    }\r\n    static text(text, pos, size = 1, style = {}) {\r\n        new RoomVisual(pos.roomName).text(text, pos.x, pos.y, this.textStyle(size, style));\r\n    }\r\n    static barGraph(progress, pos, width = 7, scale = 1) {\r\n        const vis = new RoomVisual(pos.roomName);\r\n        let percent;\r\n        let mode;\r\n        if (typeof progress === 'number') {\r\n            percent = progress;\r\n            mode = 'percent';\r\n        }\r\n        else {\r\n            percent = progress[0] / progress[1];\r\n            mode = 'fraction';\r\n        }\r\n        // Draw frame\r\n        vis.box(pos.x, pos.y - CHAR_HEIGHT * scale, width, 1.1 * scale * CHAR_HEIGHT, { color: TEXT_COLOR });\r\n        vis.rect(pos.x, pos.y - CHAR_HEIGHT * scale, percent * width, 1.1 * scale * CHAR_HEIGHT, {\r\n            fill: TEXT_COLOR,\r\n            opacity: 0.4,\r\n            strokeWidth: 0\r\n        });\r\n        // Draw text\r\n        if (mode == 'percent') {\r\n            vis.text(`${Math.round(100 * percent)}%`, pos.x + width / 2, pos.y - .1 * CHAR_HEIGHT, this.textStyle(1, { align: 'center' }));\r\n        }\r\n        else {\r\n            const [num, den] = progress;\r\n            vis.text(`${num}/${den}`, pos.x + width / 2, pos.y - .1 * CHAR_HEIGHT, this.textStyle(1, { align: 'center' }));\r\n        }\r\n    }\r\n    static table(data, pos) {\r\n        if (data.length == 0) {\r\n            return;\r\n        }\r\n        const colPadding = 4;\r\n        const vis = new RoomVisual(pos.roomName);\r\n        const style = this.textStyle();\r\n        // Determine column locations\r\n        const columns = Array(_.first(data).length).fill(0);\r\n        for (const entries of data) {\r\n            for (let i = 0; i < entries.length - 1; i++) {\r\n                columns[i] = Math.max(columns[i], entries[i].length);\r\n            }\r\n        }\r\n        // // Draw header and underline\r\n        // vis.text(header, pos.x, pos.y, style);\r\n        // vis.line(pos.x, pos.y + .3 * charHeight,\r\n        // \tpos.x + charWidth * _.sum(columns) + colPadding * columns.length, pos.y + .25 * charHeight, {\r\n        // \t\t\t color: textColor\r\n        // \t\t });\r\n        // Draw text\r\n        // let dy = 1.5 * charHeight;\r\n        let dy = 0;\r\n        for (const entries of data) {\r\n            let dx = 0;\r\n            for (const i in entries) {\r\n                vis.text(entries[i], pos.x + dx, pos.y + dy, style);\r\n                dx += CHAR_WIDTH * (columns[i] + colPadding);\r\n            }\r\n            dy += CHAR_HEIGHT;\r\n        }\r\n    }\r\n    static multitext(lines, pos) {\r\n        if (lines.length == 0) {\r\n            return;\r\n        }\r\n        const vis = new RoomVisual(pos.roomName);\r\n        const style = this.textStyle();\r\n        // Draw text\r\n        let dy = 0;\r\n        for (const line of lines) {\r\n            vis.text(line, pos.x, pos.y + dy, style);\r\n            dy += CHAR_HEIGHT;\r\n        }\r\n    }\r\n    static drawHUD() {\r\n        // Draw Overmind logo\r\n        new RoomVisual().multitext(asciiLogo, 0, 0, { textfont: 'monospace' });\r\n        // // Display CPU Information\r\n        // new RoomVisual().text('CPU:' + ' bucket:' + Game.cpu.bucket +\r\n        // \t\t\t\t\t  ' tickLimit:' + Game.cpu.tickLimit, column, row, style);\r\n    }\r\n    /* Draws the Overmind logo using component coordinates extracted with Mathematica. This  uses about 0.2 CPU/tick */\r\n    static drawLogo() {\r\n        new RoomVisual().poly(logoComponents.black.points, logoComponents.black.style)\r\n            .poly(logoComponents.dgray.points, logoComponents.dgray.style)\r\n            .poly(logoComponents.lgray.points, logoComponents.lgray.style)\r\n            .poly(logoComponents.blue.points, logoComponents.blue.style)\r\n            .poly(logoComponents.red.points, logoComponents.red.style)\r\n            .poly(logoComponents.purple.points, logoComponents.purple.style)\r\n            .poly(logoComponents.pink.points, logoComponents.pink.style)\r\n            .poly(logoText.V.points, logoText.V.style)\r\n            .poly(logoText.E.points, logoText.E.style)\r\n            .poly(logoText.R1.points, logoText.R1.style)\r\n            .poly(logoText.R2.points, logoText.R2.style)\r\n            .poly(logoText.M.points, logoText.M.style)\r\n            .poly(logoText.I.points, logoText.I.style)\r\n            .poly(logoText.N.points, logoText.N.style)\r\n            .poly(logoText.D.points, logoText.D.style);\r\n    }\r\n    static drawNotifications(notificationMessages) {\r\n        // const vis = new RoomVisual();\r\n        const x = 10.5;\r\n        const y = 7;\r\n        if (notificationMessages.length == 0) {\r\n            notificationMessages = ['No notifications'];\r\n        }\r\n        const maxStringLength = _.max(_.map(notificationMessages, msg => msg.length));\r\n        const width = Math.max(11, 1.2 * CHAR_WIDTH * maxStringLength);\r\n        this.infoBox('Notifications', notificationMessages, { x, y }, width);\r\n    }\r\n    // static colonyReport(colonyName: string, text: string[]) {\r\n    // \tif (!this.enabled) return;\r\n    // \tnew RoomVisual(colonyName).multitext(text, 0, 4, {textfont: 'monospace', textsize: 0.75});\r\n    // }\r\n    static drawGraphs() {\r\n        this.text(`CPU`, { x: 1, y: 7 });\r\n        this.barGraph(Memory.stats.persistent.avgCPU / Game.cpu.limit, { x: 2.75, y: 7 });\r\n        this.text(`BKT`, { x: 1, y: 8 });\r\n        this.barGraph(Game.cpu.bucket / 10000, { x: 2.75, y: 8 });\r\n        this.text(`GCL`, { x: 1, y: 9 });\r\n        this.barGraph(Game.gcl.progress / Game.gcl.progressTotal, { x: 2.75, y: 9 });\r\n    }\r\n    static summary() {\r\n        this.text(`Colonies: ${_.keys(Overmind.colonies).length} | Creeps: ${_.keys(Game.creeps).length}`, {\r\n            x: 1,\r\n            y: 10\r\n        }, .93);\r\n    }\r\n    // This typically takes about 0.3-0.6 CPU in total\r\n    static visuals() {\r\n        this.drawLogo();\r\n        this.drawGraphs();\r\n        // this.drawNotifications();\r\n        this.summary();\r\n    }\r\n};\r\nVisualizer = tslib_1.__decorate([\r\n    profile\r\n], Visualizer);\r\nexport { Visualizer };\r\n","references":["C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/roomPlanner/RoomPlanner.ts","C:/git/Screeps-Revamped/src/visuals/logos.ts"]}
