{"code":"import * as tslib_1 from \"tslib\";\r\nimport { log } from '../console/log';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { profile } from '../profiler/decorator';\r\nimport { boostParts } from '../resources/map_resources';\r\nimport { MIN_LIFETIME_FOR_BOOST } from '../tasks/instances/getBoosted';\r\nimport { Tasks } from '../tasks/Tasks';\r\nimport { CombatZerg } from '../zerg/CombatZerg';\r\nimport { Zerg } from '../zerg/Zerg';\r\nexport function hasColony(initializer) {\r\n    return initializer.colony != undefined;\r\n}\r\nexport const DEFAULT_PRESPAWN = 50;\r\nexport const MAX_SPAWN_REQUESTS = 100; // this stops division by zero or related errors from sending infinite requests\r\nconst OverlordMemoryDefaults = {};\r\n/**\r\n * An Overlord is roughly analogous to a process in an OS: it is a generalization of a set of related things that need\r\n * to be done in a colony, like mining from a site, bootstrapping a new colony, guarding against invaders, or building\r\n * construction sites. Overlords handle spawning or obtaining suitable creeps to do these things and contain the actual\r\n * implementation of doing them.\r\n */\r\nlet Overlord = class Overlord {\r\n    constructor(initializer, name, priority) {\r\n        this.initializer = initializer;\r\n        // this.memory = Mem.wrap(initializer.memory, name, OverlordMemoryDefaults);\r\n        this.room = initializer.room;\r\n        this.priority = priority;\r\n        this.name = name;\r\n        this.ref = initializer.ref + '>' + name;\r\n        this.pos = initializer.pos;\r\n        this.colony = hasColony(initializer) ? initializer.colony : initializer;\r\n        this.spawnGroup = undefined;\r\n        this._zerg = {};\r\n        this._combatZerg = {};\r\n        this.recalculateCreeps();\r\n        this.creepUsageReport = _.mapValues(this._creeps, creep => undefined);\r\n        this.boosts = _.mapValues(this._creeps, creep => undefined);\r\n        // Register the overlord on the colony overseer and on the overmind\r\n        Overmind.overlords[this.ref] = this;\r\n        Overmind.overseer.registerOverlord(this);\r\n    }\r\n    get isSuspended() {\r\n        return Overmind.overseer.isOverlordSuspended(this);\r\n    }\r\n    suspendFor(ticks) {\r\n        return Overmind.overseer.suspendOverlordFor(this, ticks);\r\n    }\r\n    suspendUntil(untilTick) {\r\n        return Overmind.overseer.suspendOverlordUntil(this, untilTick);\r\n    }\r\n    /**\r\n     * Refreshes overlord, recalculating creeps and refreshing existing Zerg. New creeps are automatically added,\r\n     * and the corresponding role groups (e.g. 'queens') are automatically updated. Child methods do not need to\r\n     * refresh their zerg properties, only other room objects stored on the Overlord.\r\n     */\r\n    refresh() {\r\n        // // Handle suspension // TODO: finish this\r\n        // if (this.memory.suspendUntil) {\r\n        // \tif (Game.time < this.memory.suspendUntil) {\r\n        // \t\treturn;\r\n        // \t} else {\r\n        // \t\tdelete this.memory.suspendUntil;\r\n        // \t}\r\n        // }\r\n        // Refresh room\r\n        this.room = Game.rooms[this.pos.roomName];\r\n        // Refresh zerg\r\n        this.recalculateCreeps();\r\n        for (const role in this._creeps) {\r\n            for (const creep of this._creeps[role]) {\r\n                if (Overmind.zerg[creep.name]) {\r\n                    // log.debug(`Refreshing creep ${creep.name}`)\r\n                    Overmind.zerg[creep.name].refresh();\r\n                }\r\n                else {\r\n                    log.warning(`${this.print}: could not find and refresh zerg with name ${creep.name}!`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    get print() {\r\n        return '<a href=\"#!/room/' + Game.shard.name + '/' + this.pos.roomName + '\">[' + this.ref + ']</a>';\r\n    }\r\n    recalculateCreeps() {\r\n        // Recalculate the sets of creeps for each role in this overlord\r\n        this._creeps = _.mapValues(Overmind.cache.overlords[this.ref], creepsOfRole => _.map(creepsOfRole, creepName => Game.creeps[creepName]));\r\n        // Update zerg and combatZerg records\r\n        for (const role in this._zerg) {\r\n            this.synchronizeZerg(role);\r\n        }\r\n        for (const role in this._combatZerg) {\r\n            this.synchronizeCombatZerg(role);\r\n        }\r\n    }\r\n    /**\r\n     * Wraps all creeps of a given role to Zerg objects and updates the contents in future ticks to avoid having to\r\n     * explicitly refresh groups of Zerg\r\n     */\r\n    zerg(role, opts = {}) {\r\n        if (!this._zerg[role]) {\r\n            this._zerg[role] = [];\r\n            this.synchronizeZerg(role, opts.notifyWhenAttacked);\r\n        }\r\n        if (opts.boostWishlist) {\r\n            this.boosts[role] = opts.boostWishlist;\r\n        }\r\n        return this._zerg[role];\r\n    }\r\n    synchronizeZerg(role, notifyWhenAttacked) {\r\n        // Synchronize the corresponding sets of Zerg\r\n        const zergNames = _.zipObject(_.map(this._zerg[role] || [], zerg => [zerg.name, true]));\r\n        const creepNames = _.zipObject(_.map(this._creeps[role] || [], creep => [creep.name, true]));\r\n        // Add new creeps which aren't in the _zerg record\r\n        for (const creep of this._creeps[role] || []) {\r\n            if (!zergNames[creep.name]) {\r\n                this._zerg[role].push(Overmind.zerg[creep.name] || new Zerg(creep, notifyWhenAttacked));\r\n            }\r\n        }\r\n        // Remove dead/reassigned creeps from the _zerg record\r\n        for (const zerg of this._zerg[role]) {\r\n            if (!creepNames[zerg.name]) {\r\n                _.remove(this._zerg[role], z => z.name == zerg.name);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Wraps all creeps of a given role to CombatZerg objects and updates the contents in future ticks\r\n     */\r\n    combatZerg(role, opts = {}) {\r\n        if (!this._combatZerg[role]) {\r\n            this._combatZerg[role] = [];\r\n            this.synchronizeCombatZerg(role, opts.notifyWhenAttacked);\r\n        }\r\n        if (opts.boostWishlist) {\r\n            this.boosts[role] = opts.boostWishlist;\r\n        }\r\n        return this._combatZerg[role];\r\n    }\r\n    synchronizeCombatZerg(role, notifyWhenAttacked) {\r\n        // Synchronize the corresponding sets of CombatZerg\r\n        const zergNames = _.zipObject(_.map(this._combatZerg[role] || [], zerg => [zerg.name, true]));\r\n        const creepNames = _.zipObject(_.map(this._creeps[role] || [], creep => [creep.name, true]));\r\n        // Add new creeps which aren't in the _combatZerg record\r\n        for (const creep of this._creeps[role] || []) {\r\n            if (!zergNames[creep.name]) {\r\n                if (Overmind.zerg[creep.name] && Overmind.zerg[creep.name].isCombatZerg) {\r\n                    this._combatZerg[role].push(Overmind.zerg[creep.name]);\r\n                }\r\n                else {\r\n                    this._combatZerg[role].push(new CombatZerg(creep, notifyWhenAttacked));\r\n                }\r\n            }\r\n        }\r\n        // Remove dead/reassigned creeps from the _combatZerg record\r\n        for (const zerg of this._combatZerg[role]) {\r\n            if (!creepNames[zerg.name]) {\r\n                _.remove(this._combatZerg[role], z => z.name == zerg.name);\r\n            }\r\n        }\r\n    }\r\n    /* Gets the \"ID\" of the outpost this overlord is operating in. 0 for owned rooms, >= 1 for outposts, -1 for other */\r\n    get outpostIndex() {\r\n        return _.findIndex(this.colony.roomNames, roomName => roomName == this.pos.roomName);\r\n    }\r\n    reassignIdleCreeps(role) {\r\n        // Find all creeps without an overlord\r\n        const idleCreeps = _.filter(this.colony.getCreepsByRole(role), creep => !getOverlord(creep));\r\n        // Reassign them all to this flag\r\n        for (const creep of idleCreeps) {\r\n            setOverlord(creep, this);\r\n        }\r\n    }\r\n    // /* Returns all creeps of a specified role */\r\n    // protected creeps(role: string): Creep[] {\r\n    // \tif (this._creeps[role]) {\r\n    // \t\treturn this._creeps[role];\r\n    // \t} else {\r\n    // \t\treturn [];\r\n    // \t}\r\n    // }\r\n    creepReport(role, currentAmt, neededAmt) {\r\n        this.creepUsageReport[role] = [currentAmt, neededAmt];\r\n    }\r\n    // TODO: include creep move speed\r\n    lifetimeFilter(creeps, prespawn = DEFAULT_PRESPAWN, spawnDistance) {\r\n        if (!spawnDistance) {\r\n            spawnDistance = 0;\r\n            if (this.spawnGroup) {\r\n                const distances = _.take(_.sortBy(this.spawnGroup.memory.distances), 2);\r\n                spawnDistance = (_.sum(distances) / distances.length) || 0;\r\n            }\r\n            else if (this.colony.hatchery) {\r\n                // Use distance or 0 (in case distance returns something undefined due to incomplete pathfinding)\r\n                spawnDistance = Pathing.distance(this.pos, this.colony.hatchery.pos) || 0;\r\n            }\r\n            if (this.colony.isIncubating && this.colony.spawnGroup) {\r\n                spawnDistance += this.colony.spawnGroup.stats.avgDistance;\r\n            }\r\n        }\r\n        /* The last condition fixes a bug only present on private servers that took me a fucking week to isolate.\r\n         * At the tick of birth, creep.spawning = false and creep.ticksTolive = undefined\r\n         * See: https://screeps.com/forum/topic/443/creep-spawning-is-not-updated-correctly-after-spawn-process */\r\n        return _.filter(creeps, creep => creep.ticksToLive > CREEP_SPAWN_TIME * creep.body.length + spawnDistance + prespawn ||\r\n            creep.spawning || (!creep.spawning && !creep.ticksToLive));\r\n    }\r\n    parkCreepsIfIdle(creeps, outsideHatchery = true) {\r\n        for (const creep of creeps) {\r\n            if (!creep) {\r\n                console.log(`creeps: ${_.map(creeps, creep => creep.name)}`);\r\n                continue;\r\n            }\r\n            if (creep.isIdle && creep.canExecute('move')) {\r\n                if (this.colony.hatchery) {\r\n                    const hatcheryRestrictedRange = 6;\r\n                    if (creep.pos.getRangeTo(this.colony.hatchery.pos) < hatcheryRestrictedRange) {\r\n                        const hatcheryBorder = this.colony.hatchery.pos.getPositionsAtRange(hatcheryRestrictedRange);\r\n                        const moveToPos = creep.pos.findClosestByRange(hatcheryBorder);\r\n                        if (moveToPos)\r\n                            creep.goTo(moveToPos);\r\n                    }\r\n                    else {\r\n                        creep.park();\r\n                    }\r\n                }\r\n                else {\r\n                    creep.park();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Requests a group of (2-3) creeps from a hatchery to be spawned at the same time. Using this with low-priority\r\n     * operations can result in a long time\r\n     */\r\n    requestSquad(setups, opts = {}) {\r\n        log.warning(`Overlord.requestSquad() is not finished yet!`); // TODO: finish\r\n        _.defaults(opts, { priority: this.priority, prespawn: DEFAULT_PRESPAWN });\r\n        const spawner = this.spawnGroup || this.colony.spawnGroup || this.colony.hatchery;\r\n        if (spawner) {\r\n            if (setups.length > 3) {\r\n                log.warning(`Requesting squads of >3 is not advisable`);\r\n            }\r\n            const request = {\r\n                setup: _.head(setups),\r\n                overlord: this,\r\n                priority: opts.priority,\r\n                partners: _.tail(setups),\r\n            };\r\n            if (opts.options) {\r\n                request.options = opts.options;\r\n            }\r\n            spawner.enqueue(request);\r\n        }\r\n        else {\r\n            if (Game.time % 100 == 0) {\r\n                log.warning(`Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Create a creep setup and enqueue it to the Hatchery; does not include automatic reporting\r\n     */\r\n    requestCreep(setup, opts = {}) {\r\n        _.defaults(opts, { priority: this.priority, prespawn: DEFAULT_PRESPAWN });\r\n        const spawner = this.spawnGroup || this.colony.spawnGroup || this.colony.hatchery;\r\n        if (spawner) {\r\n            const request = {\r\n                setup: setup,\r\n                overlord: this,\r\n                priority: opts.priority,\r\n            };\r\n            if (opts.partners) {\r\n                request.partners = opts.partners;\r\n            }\r\n            if (opts.options) {\r\n                request.options = opts.options;\r\n            }\r\n            spawner.enqueue(request);\r\n        }\r\n        else {\r\n            if (Game.time % 100 == 0) {\r\n                log.warning(`Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Wishlist of creeps to simplify spawning logic; includes automatic reporting\r\n     */\r\n    wishlist(quantity, setup, opts = {}) {\r\n        _.defaults(opts, { priority: this.priority, prespawn: DEFAULT_PRESPAWN, reassignIdle: false });\r\n        let creepQuantity;\r\n        if (opts.noLifetimeFilter) {\r\n            creepQuantity = (this._creeps[setup.role] || []).length;\r\n        }\r\n        else if (_.has(this.initializer, 'waypoints')) {\r\n            // TODO: replace hardcoded distance with distance computed through portals\r\n            creepQuantity = this.lifetimeFilter(this._creeps[setup.role] || [], opts.prespawn, 500).length;\r\n        }\r\n        else {\r\n            creepQuantity = this.lifetimeFilter(this._creeps[setup.role] || [], opts.prespawn).length;\r\n        }\r\n        let spawnQuantity = quantity - creepQuantity;\r\n        if (opts.reassignIdle && spawnQuantity > 0) {\r\n            const idleCreeps = _.filter(this.colony.getCreepsByRole(setup.role), creep => !getOverlord(creep));\r\n            for (let i = 0; i < Math.min(idleCreeps.length, spawnQuantity); i++) {\r\n                setOverlord(idleCreeps[i], this);\r\n                spawnQuantity--;\r\n            }\r\n        }\r\n        // A bug in outpostDefenseOverlord caused infinite requests and cost me two botarena rounds before I found it...\r\n        if (spawnQuantity > MAX_SPAWN_REQUESTS) {\r\n            log.warning(`Too many requests for ${setup.role}s submitted by ${this.print}! (Check for errors.)`);\r\n        }\r\n        else {\r\n            for (let i = 0; i < spawnQuantity; i++) {\r\n                this.requestCreep(setup, opts);\r\n            }\r\n        }\r\n        this.creepReport(setup.role, creepQuantity, quantity);\r\n    }\r\n    // TODO: finish this; currently requires host colony to have evolution chamber\r\n    canBoostSetup(setup) {\r\n        if (this.colony.evolutionChamber && this.boosts[setup.role] && this.boosts[setup.role].length > 0) {\r\n            let energyCapacityAvailable;\r\n            if (this.spawnGroup) {\r\n                energyCapacityAvailable = this.spawnGroup.energyCapacityAvailable;\r\n            }\r\n            else if (this.colony.spawnGroup) {\r\n                energyCapacityAvailable = this.colony.spawnGroup.energyCapacityAvailable;\r\n            }\r\n            else if (this.colony.hatchery) {\r\n                energyCapacityAvailable = this.colony.hatchery.room.energyCapacityAvailable;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n            const body = _.map(setup.generateBody(energyCapacityAvailable), part => ({ type: part, hits: 100 }));\r\n            if (body.length == 0)\r\n                return false;\r\n            return _.all(this.boosts[setup.role], boost => this.colony.evolutionChamber.canBoost(body, boost));\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Return whether you are capable of boosting a creep to the desired specifications\r\n     */\r\n    shouldBoost(creep, onlyBoostInSpawn = false) {\r\n        // Can't boost if there's no evolution chamber or TTL is less than threshold\r\n        const colony = Overmind.colonies[creep.room.name];\r\n        const evolutionChamber = colony ? colony.evolutionChamber : undefined;\r\n        if (!evolutionChamber ||\r\n            (creep.ticksToLive && creep.ticksToLive < MIN_LIFETIME_FOR_BOOST * creep.lifetime)) {\r\n            return false;\r\n        }\r\n        // EDIT: they removed in-spawn boosting... RIP :(\r\n        // // If you're in a bunker layout at level 8 with max labs, only boost while spawning\r\n        // if (onlyBoostInSpawn && this.colony.bunker && this.colony.level == 8 && this.colony.labs.length == 10) {\r\n        // \tif (!creep.spawning) {\r\n        // \t\treturn false;\r\n        // \t}\r\n        // }\r\n        // Otherwise just boost if you need it and can get the resources\r\n        if (this.boosts[creep.roleName]) {\r\n            const boosts = _.filter(this.boosts[creep.roleName], boost => (creep.boostCounts[boost] || 0) < creep.getActiveBodyparts(boostParts[boost]));\r\n            if (boosts.length > 0) {\r\n                return _.all(boosts, boost => evolutionChamber.canBoost(creep.body, boost));\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Request a boost from the evolution chamber; should be called during init()\r\n     */\r\n    requestBoostsForCreep(creep) {\r\n        const colony = Overmind.colonies[creep.room.name];\r\n        const evolutionChamber = colony ? colony.evolutionChamber : undefined;\r\n        if (evolutionChamber && this.boosts[creep.roleName]) {\r\n            const boosts = _.filter(this.boosts[creep.roleName], boost => (creep.boostCounts[boost] || 0) < creep.getActiveBodyparts(boostParts[boost]));\r\n            for (const boost of boosts) {\r\n                evolutionChamber.requestBoost(creep, boost);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Handle boosting of a creep; should be called during run()\r\n     */\r\n    handleBoosting(creep) {\r\n        const colony = Overmind.colonies[creep.room.name];\r\n        const evolutionChamber = colony ? colony.evolutionChamber : undefined;\r\n        if (this.boosts[creep.roleName] && evolutionChamber) {\r\n            const boosts = _.filter(this.boosts[creep.roleName], boost => (creep.boostCounts[boost] || 0) < creep.getActiveBodyparts(boostParts[boost]));\r\n            for (const boost of boosts) {\r\n                const boostLab = _.find(evolutionChamber.boostingLabs, lab => lab.mineralType == boost);\r\n                if (boostLab) {\r\n                    creep.task = Tasks.getBoosted(boostLab, boost);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Request any needed boosting resources from terminal network\r\n     */\r\n    requestBoosts(creeps) {\r\n        for (const creep of creeps) {\r\n            if (this.shouldBoost(creep)) {\r\n                this.requestBoostsForCreep(creep);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Requests that should be handled for all overlords prior to the init() phase\r\n     */\r\n    preInit() {\r\n        // Handle resource requests for boosts\r\n        for (const role in this.boosts) {\r\n            if (this.boosts[role] && this._creeps[role]) {\r\n                this.requestBoosts(_.compact(_.map(this._creeps[role], creep => Overmind.zerg[creep.name])));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Standard sequence of actions for running task-based creeps\r\n     */\r\n    autoRun(roleCreeps, taskHandler, fleeCallback) {\r\n        for (const creep of roleCreeps) {\r\n            if (!!fleeCallback) {\r\n                if (fleeCallback(creep))\r\n                    continue;\r\n            }\r\n            if (creep.isIdle) {\r\n                if (this.shouldBoost(creep)) {\r\n                    this.handleBoosting(creep);\r\n                }\r\n                else {\r\n                    taskHandler(creep);\r\n                }\r\n            }\r\n            creep.run();\r\n        }\r\n    }\r\n    visuals() {\r\n    }\r\n};\r\nOverlord = tslib_1.__decorate([\r\n    profile\r\n], Overlord);\r\nexport { Overlord };\r\nexport function getOverlord(creep) {\r\n    if (creep.memory[\"O\" /* OVERLORD */]) {\r\n        return Overmind.overlords[creep.memory[\"O\" /* OVERLORD */]] || null;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexport function setOverlord(creep, newOverlord) {\r\n    // Remove cache references to old assignments\r\n    const roleName = creep.memory.role;\r\n    const ref = creep.memory[\"O\" /* OVERLORD */];\r\n    const oldOverlord = ref ? Overmind.overlords[ref] : null;\r\n    if (ref && Overmind.cache.overlords[ref] && Overmind.cache.overlords[ref][roleName]) {\r\n        _.remove(Overmind.cache.overlords[ref][roleName], name => name == creep.name);\r\n    }\r\n    if (newOverlord) {\r\n        // Change to the new overlord's colony\r\n        creep.memory[\"C\" /* COLONY */] = newOverlord.colony.name;\r\n        // Change assignments in memory\r\n        creep.memory[\"O\" /* OVERLORD */] = newOverlord.ref;\r\n        // Update the cache references\r\n        if (!Overmind.cache.overlords[newOverlord.ref]) {\r\n            Overmind.cache.overlords[newOverlord.ref] = {};\r\n        }\r\n        if (!Overmind.cache.overlords[newOverlord.ref][roleName]) {\r\n            Overmind.cache.overlords[newOverlord.ref][roleName] = [];\r\n        }\r\n        Overmind.cache.overlords[newOverlord.ref][roleName].push(creep.name);\r\n    }\r\n    else {\r\n        creep.memory[\"O\" /* OVERLORD */] = null;\r\n    }\r\n    if (oldOverlord)\r\n        oldOverlord.recalculateCreeps();\r\n    if (newOverlord)\r\n        newOverlord.recalculateCreeps();\r\n    log.info(`${creep.name} has been reassigned from ${oldOverlord ? oldOverlord.print : 'IDLE'} ` +\r\n        `to ${newOverlord ? newOverlord.print : 'IDLE'}`);\r\n}\r\n","references":["C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/creepSetups/CreepSetup.ts","C:/git/Screeps-Revamped/src/hiveClusters/hatchery.ts","C:/git/Screeps-Revamped/src/logistics/SpawnGroup.ts","C:/git/Screeps-Revamped/src/movement/Pathing.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/resources/map_resources.ts","C:/git/Screeps-Revamped/src/tasks/instances/getBoosted.ts","C:/git/Screeps-Revamped/src/tasks/Tasks.ts","C:/git/Screeps-Revamped/src/zerg/CombatZerg.ts","C:/git/Screeps-Revamped/src/zerg/Zerg.ts"]}
