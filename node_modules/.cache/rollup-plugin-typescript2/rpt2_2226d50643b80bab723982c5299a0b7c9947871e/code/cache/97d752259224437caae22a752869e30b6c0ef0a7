{"code":"import * as tslib_1 from \"tslib\";\r\nimport { profile } from '../profiler/decorator';\r\nimport { getCacheExpiration } from '../utilities/utils';\r\nconst CACHE_TIMEOUT = 50;\r\nconst SHORT_CACHE_TIMEOUT = 10;\r\n/**\r\n * The GlobalCache ($) module saves frequently accessed deserialized objects in temporary, volatile global memory\r\n */\r\nlet $ = class $ {\r\n    static structures(saver, key, callback, timeout = CACHE_TIMEOUT) {\r\n        const cacheKey = saver.ref + 's' + key;\r\n        if (!_cache.structures[cacheKey] || Game.time > _cache.expiration[cacheKey]) {\r\n            // Recache if new entry or entry is expired\r\n            _cache.structures[cacheKey] = callback();\r\n            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));\r\n        }\r\n        else {\r\n            // Refresh structure list by ID if not already done on current tick\r\n            if ((_cache.accessed[cacheKey] || 0) < Game.time) {\r\n                _cache.structures[cacheKey] = _.compact(_.map(_cache.structures[cacheKey] || [], s => Game.getObjectById(s.id)));\r\n                _cache.accessed[cacheKey] = Game.time;\r\n            }\r\n        }\r\n        return _cache.structures[cacheKey];\r\n    }\r\n    static number(saver, key, callback, timeout = SHORT_CACHE_TIMEOUT) {\r\n        const cacheKey = saver.ref + '#' + key;\r\n        if (_cache.numbers[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {\r\n            // Recache if new entry or entry is expired\r\n            _cache.numbers[cacheKey] = callback();\r\n            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));\r\n        }\r\n        return _cache.numbers[cacheKey];\r\n    }\r\n    // TODO: for some reason overloading isn't working here...\r\n    // static pos(saver: { ref: string }, key: string, callback: () => RoomPosition, timeout ?: number): RoomPosition;\r\n    static pos(saver, key, callback, timeout) {\r\n        const cacheKey = saver.ref + 'p' + key;\r\n        if (_cache.roomPositions[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {\r\n            // Recache if new entry or entry is expired\r\n            _cache.roomPositions[cacheKey] = callback();\r\n            if (!timeout)\r\n                timeout = CACHE_TIMEOUT;\r\n            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));\r\n        }\r\n        return _cache.roomPositions[cacheKey];\r\n    }\r\n    static list(saver, key, callback, timeout = CACHE_TIMEOUT) {\r\n        const cacheKey = saver.ref + 'l' + key;\r\n        if (_cache.lists[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {\r\n            // Recache if new entry or entry is expired\r\n            _cache.lists[cacheKey] = callback();\r\n            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));\r\n        }\r\n        return _cache.lists[cacheKey];\r\n    }\r\n    static costMatrix(roomName, key, callback, timeout = SHORT_CACHE_TIMEOUT) {\r\n        const cacheKey = roomName + 'm' + key;\r\n        if (_cache.costMatrices[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {\r\n            // Recache if new entry or entry is expired\r\n            _cache.costMatrices[cacheKey] = callback();\r\n            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));\r\n        }\r\n        return _cache.costMatrices[cacheKey];\r\n    }\r\n    static costMatrixRecall(roomName, key) {\r\n        const cacheKey = roomName + ':' + key;\r\n        return _cache.costMatrices[cacheKey];\r\n    }\r\n    static set(thing, key, callback, timeout = CACHE_TIMEOUT) {\r\n        const cacheKey = thing.ref + '$' + key;\r\n        if (!_cache.things[cacheKey] || Game.time > _cache.expiration[cacheKey]) {\r\n            // Recache if new entry or entry is expired\r\n            _cache.things[cacheKey] = callback();\r\n            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));\r\n        }\r\n        else {\r\n            // Refresh structure list by ID if not already done on current tick\r\n            if ((_cache.accessed[cacheKey] || 0) < Game.time) {\r\n                if (_.isArray(_cache.things[cacheKey])) {\r\n                    _cache.things[cacheKey] = _.compact(_.map(_cache.things[cacheKey], s => Game.getObjectById(s.id)));\r\n                }\r\n                else {\r\n                    _cache.things[cacheKey] = Game.getObjectById(_cache.things[cacheKey].id);\r\n                }\r\n                _cache.accessed[cacheKey] = Game.time;\r\n            }\r\n        }\r\n        thing[key] = _cache.things[cacheKey];\r\n    }\r\n    static refresh(thing, ...keys) {\r\n        _.forEach(keys, function (key) {\r\n            if (thing[key]) {\r\n                if (_.isArray(thing[key])) {\r\n                    thing[key] = _.compact(_.map(thing[key], s => Game.getObjectById(s.id)));\r\n                }\r\n                else {\r\n                    thing[key] = Game.getObjectById(thing[key].id);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    static refreshObject(thing, ...keys) {\r\n        _.forEach(keys, function (key) {\r\n            if (_.isObject(thing[key])) {\r\n                for (const prop in thing[key]) {\r\n                    if (_.isArray(thing[key][prop])) {\r\n                        thing[key][prop] = _.compact(_.map(thing[key][prop], s => Game.getObjectById(s.id)));\r\n                    }\r\n                    else {\r\n                        thing[key][prop] = Game.getObjectById(thing[key][prop].id);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    static refreshRoom(thing) {\r\n        thing.room = Game.rooms[thing.room.name];\r\n    }\r\n};\r\n$ = tslib_1.__decorate([\r\n    profile\r\n], $);\r\nexport { $ };\r\n","references":["C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts"]}
