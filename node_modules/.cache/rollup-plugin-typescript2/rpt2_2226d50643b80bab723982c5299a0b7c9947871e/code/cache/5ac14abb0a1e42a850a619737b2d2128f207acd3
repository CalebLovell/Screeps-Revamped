{"code":"import * as tslib_1 from \"tslib\";\r\nimport { distanceTransform } from '../algorithms/distanceTransform';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { profile } from '../profiler/decorator';\r\nimport { coordName, minBy } from '../utilities/utils';\r\nimport { allBunkerCoords, BUNKER_RADIUS, bunkerCoordLookup, bunkerLayout } from './layouts/bunker';\r\nconst MAX_SAMPLE = 10;\r\nconst MAX_TOTAL_PATH_LENGTH = 25 * 3;\r\nlet BasePlanner = class BasePlanner {\r\n    static getBunkerLocation(room, visualize = true) {\r\n        const colony = Overmind.colonies[room.name];\r\n        if (colony && colony.bunker && colony.bunker.anchor) {\r\n            return colony.bunker.anchor;\r\n        }\r\n        let allowableLocations = this.getAllowableBunkerLocations(room, visualize);\r\n        if (allowableLocations.length > MAX_SAMPLE) {\r\n            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);\r\n        }\r\n        const minimizePathLengthTo = _.map(_.compact([...room.sources, room.controller]), obj => obj.pos);\r\n        const totalPathLength = function (anchor) {\r\n            let totalDistance = 0;\r\n            for (const pos of minimizePathLengthTo) {\r\n                const ret = Pathing.findShortestPath(anchor, pos, { ignoreStructures: true });\r\n                if (!ret.incomplete) {\r\n                    totalDistance += ret.path.length;\r\n                }\r\n                else {\r\n                    totalDistance += Infinity;\r\n                }\r\n            }\r\n            return totalDistance;\r\n        };\r\n        const bestAnchor = minBy(allowableLocations, pos => totalPathLength(pos));\r\n        if (bestAnchor && totalPathLength(bestAnchor) <= MAX_TOTAL_PATH_LENGTH) {\r\n            return bestAnchor;\r\n        }\r\n    }\r\n    static getAllowableBunkerLocations(room, visualize = true) {\r\n        let allowableLocations = this.getNonIntersectingBunkerLocations(room.name, visualize);\r\n        if (allowableLocations.length > MAX_SAMPLE) {\r\n            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);\r\n        }\r\n        // Filter intersection with controller\r\n        if (!room.controller)\r\n            return [];\r\n        allowableLocations = _.filter(allowableLocations, anchor => !this.bunkerIntersectsWith(anchor, room.controller.pos, 3));\r\n        // Filter intersection with miningSites\r\n        const sitesAndMineral = _.map(_.compact([...room.sources, room.mineral]), obj => obj.pos);\r\n        allowableLocations = _.filter(allowableLocations, anchor => !_.any(sitesAndMineral, pos => this.bunkerIntersectsWith(anchor, pos, 1)));\r\n        if (visualize) {\r\n            const vis = room.visual;\r\n            for (const pos of allowableLocations) {\r\n                vis.circle(pos.x, pos.y, { fill: 'purple' });\r\n            }\r\n        }\r\n        return allowableLocations;\r\n    }\r\n    static getNonIntersectingBunkerLocations(roomName, visualize = true) {\r\n        const dt = distanceTransform(roomName);\r\n        const coords = [];\r\n        let x, y;\r\n        for (y of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {\r\n            for (x of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {\r\n                if (dt.get(x, y) >= BUNKER_RADIUS + 1) {\r\n                    // If it fits, I sits\r\n                    coords.push({ x, y });\r\n                }\r\n                else if (dt.get(x, y) >= (BUNKER_RADIUS - 1) && !this.terrainIntersectsWithBunker({ x, y }, dt)) {\r\n                    // If it might not fits, check that it fits before I sits\r\n                    coords.push({ x, y });\r\n                }\r\n            }\r\n        }\r\n        if (visualize) {\r\n            const vis = new RoomVisual(roomName);\r\n            for (const coord of coords) {\r\n                vis.text(dt.get(coord.x, coord.y).toString(), coord.x, coord.y);\r\n            }\r\n        }\r\n        return _.map(coords, coord => new RoomPosition(coord.x, coord.y, roomName));\r\n    }\r\n    static terrainIntersectsWithBunker(anchor, distanceMatrix) {\r\n        const dx = anchor.x - bunkerLayout.data.anchor.x;\r\n        const dy = anchor.y - bunkerLayout.data.anchor.y;\r\n        const bunkerCoordsAtAnchor = _.map(allBunkerCoords[8], function (coord) {\r\n            return { x: coord.x + dx, y: coord.y + dy };\r\n        });\r\n        return _.any(bunkerCoordsAtAnchor, coord => distanceMatrix.get(coord.x, coord.y) == 0);\r\n    }\r\n    static bunkerIntersectsWith(anchor, obstacle, padding = 1) {\r\n        const dx = bunkerLayout.data.anchor.x - anchor.x;\r\n        const dy = bunkerLayout.data.anchor.y - anchor.y;\r\n        let x, y;\r\n        for (x of _.range(obstacle.x + dx - padding, obstacle.x + dx + padding + 1)) {\r\n            for (y of _.range(obstacle.y + dy - padding, obstacle.y + dy + padding + 1)) {\r\n                if (bunkerCoordLookup[8][coordName({ x, y })]) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};\r\nBasePlanner = tslib_1.__decorate([\r\n    profile\r\n], BasePlanner);\r\nexport { BasePlanner };\r\n","references":["C:/git/Screeps-Revamped/src/algorithms/distanceTransform.ts","C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/movement/Pathing.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts","C:/git/Screeps-Revamped/src/roomPlanner/layouts/bunker.ts"]}
