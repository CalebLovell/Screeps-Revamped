{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Colony } from '../Colony';\r\nimport { log } from '../console/log';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { profile } from '../profiler/decorator';\r\nimport { BasePlanner } from '../roomPlanner/BasePlanner';\r\nimport { Cartographer, ROOMTYPE_ALLEY, ROOMTYPE_CONTROLLER, ROOMTYPE_CORE, ROOMTYPE_SOURCEKEEPER } from '../utilities/Cartographer';\r\nimport { derefCoords } from '../utilities/utils';\r\nexport const EXPANSION_EVALUATION_FREQ = 500;\r\nexport const MIN_EXPANSION_DISTANCE = 2;\r\nlet ExpansionEvaluator = class ExpansionEvaluator {\r\n    static refreshExpansionData(colony) {\r\n        // This only gets run once per colony\r\n        if (_.keys(colony.memory.expansionData.possibleExpansions).length == 0\r\n            || Game.time > colony.memory.expansionData.expiration) {\r\n            // Generate a list of rooms which can possibly be settled in\r\n            const nearbyRooms = Cartographer.recursiveRoomSearch(colony.room.name, 5);\r\n            let possibleExpansions = [];\r\n            for (const depth in nearbyRooms) {\r\n                if (parseInt(depth, 10) <= MIN_EXPANSION_DISTANCE)\r\n                    continue;\r\n                possibleExpansions = possibleExpansions.concat(nearbyRooms[depth]);\r\n            }\r\n            for (const roomName of possibleExpansions) {\r\n                if (Cartographer.roomType(roomName) == ROOMTYPE_CONTROLLER) {\r\n                    colony.memory.expansionData.possibleExpansions[roomName] = true;\r\n                }\r\n            }\r\n        }\r\n        // This gets run whenever function is called\r\n        for (const roomName in colony.memory.expansionData.possibleExpansions) {\r\n            if (colony.memory.expansionData.possibleExpansions[roomName] == true) {\r\n                if (Memory.rooms[roomName]) {\r\n                    const expansionData = Memory.rooms[roomName][\"e\" /* EXPANSION_DATA */];\r\n                    if (expansionData == false) {\r\n                        colony.memory.expansionData.possibleExpansions[roomName] = false;\r\n                    }\r\n                    else if (expansionData && expansionData.score) {\r\n                        colony.memory.expansionData.possibleExpansions[roomName] = expansionData.score;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Compute the total score for a room\r\n    static computeExpansionData(room, verbose = false) {\r\n        if (verbose)\r\n            log.info(`Computing score for ${room.print}...`);\r\n        if (!room.controller) {\r\n            room.memory[\"e\" /* EXPANSION_DATA */] = false;\r\n            return false;\r\n        }\r\n        // compute possible outposts (includes host room)\r\n        const possibleOutposts = Cartographer.findRoomsInRange(room.name, 2);\r\n        // find source positions\r\n        const outpostSourcePositions = {};\r\n        for (const roomName of possibleOutposts) {\r\n            if (Cartographer.roomType(roomName) == ROOMTYPE_ALLEY)\r\n                continue;\r\n            const roomMemory = Memory.rooms[roomName];\r\n            if (!roomMemory || !roomMemory[\"s\" /* SOURCES */]) {\r\n                if (verbose)\r\n                    log.info(`No memory of neighbor: ${roomName}. Aborting score calculation!`);\r\n                return false;\r\n            }\r\n            outpostSourcePositions[roomName] = _.map(roomMemory[\"s\" /* SOURCES */], obj => derefCoords(obj.c, roomName));\r\n        }\r\n        // compute a possible bunker position\r\n        const bunkerLocation = BasePlanner.getBunkerLocation(room, false);\r\n        if (!bunkerLocation) {\r\n            room.memory[\"e\" /* EXPANSION_DATA */] = false;\r\n            log.info(`Room ${room.name} is uninhabitable because a bunker can't be built here!`);\r\n            return false;\r\n        }\r\n        // evaluate energy contribution and compute outpost scores\r\n        if (verbose)\r\n            log.info(`Origin: ${bunkerLocation.print}`);\r\n        const outpostScores = {};\r\n        for (const roomName in outpostSourcePositions) {\r\n            if (verbose)\r\n                log.info(`Analyzing neighbor ${roomName}`);\r\n            const sourcePositions = outpostSourcePositions[roomName];\r\n            let valid = true;\r\n            const roomType = Cartographer.roomType(roomName);\r\n            let energyPerSource = SOURCE_ENERGY_CAPACITY;\r\n            if (roomType == ROOMTYPE_SOURCEKEEPER) {\r\n                energyPerSource = 0.6 * SOURCE_ENERGY_KEEPER_CAPACITY; // don't favor SK rooms too heavily -- more CPU\r\n            }\r\n            else if (roomType == ROOMTYPE_CORE) {\r\n                energyPerSource = SOURCE_ENERGY_KEEPER_CAPACITY;\r\n            }\r\n            let roomScore = 0;\r\n            for (const position of sourcePositions) {\r\n                const msg = verbose ? `Computing distance from ${bunkerLocation.print} to ${position.print}... ` : '';\r\n                const ret = Pathing.findShortestPath(bunkerLocation, position, { ignoreStructures: true, allowHostile: true });\r\n                if (ret.incomplete || ret.path.length > Colony.settings.maxSourceDistance) {\r\n                    if (verbose)\r\n                        log.info(msg + 'incomplete path!');\r\n                    valid = false;\r\n                    break;\r\n                }\r\n                if (verbose)\r\n                    log.info(msg + ret.path.length);\r\n                const offset = 25; // prevents over-sensitivity to very close sources\r\n                roomScore += energyPerSource / (ret.path.length + offset);\r\n            }\r\n            if (valid) {\r\n                outpostScores[roomName] = Math.floor(roomScore);\r\n            }\r\n        }\r\n        // Compute the total score of the room as the maximum energy score of max number of sources harvestable\r\n        let totalScore = 0;\r\n        let sourceCount = 0;\r\n        const roomsByScore = _.sortBy(_.keys(outpostScores), roomName => -1 * outpostScores[roomName]);\r\n        for (const roomName of roomsByScore) {\r\n            if (sourceCount > Colony.settings.remoteSourcesByLevel[8])\r\n                break;\r\n            const factor = roomName == room.name ? 2 : 1; // weight owned room scores more heavily\r\n            totalScore += outpostScores[roomName];\r\n            sourceCount += outpostSourcePositions[roomName].length;\r\n        }\r\n        totalScore = Math.floor(totalScore);\r\n        if (verbose)\r\n            log.info(`Score: ${totalScore}`);\r\n        if (!room.memory[\"e\" /* EXPANSION_DATA */] ||\r\n            totalScore > room.memory[\"e\" /* EXPANSION_DATA */].score) {\r\n            room.memory[\"e\" /* EXPANSION_DATA */] = {\r\n                score: totalScore,\r\n                bunkerAnchor: bunkerLocation.coordName,\r\n                outposts: outpostScores,\r\n            };\r\n        }\r\n        return true;\r\n    }\r\n};\r\nExpansionEvaluator = tslib_1.__decorate([\r\n    profile\r\n], ExpansionEvaluator);\r\nexport { ExpansionEvaluator };\r\n","references":["C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/movement/Pathing.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/roomPlanner/BasePlanner.ts","C:/git/Screeps-Revamped/src/utilities/Cartographer.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts"]}
