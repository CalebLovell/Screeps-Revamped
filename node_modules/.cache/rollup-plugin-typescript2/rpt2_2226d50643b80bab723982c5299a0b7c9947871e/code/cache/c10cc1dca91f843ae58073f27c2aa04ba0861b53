{"code":"import * as tslib_1 from \"tslib\";\r\nimport { profile } from '../profiler/decorator';\r\nexport const ROOMTYPE_SOURCEKEEPER = 'SK';\r\nexport const ROOMTYPE_CORE = 'CORE';\r\nexport const ROOMTYPE_CONTROLLER = 'CTRL';\r\nexport const ROOMTYPE_ALLEY = 'ALLEY';\r\n/**\r\n * Cartographer: provides helper methods related to Game.map. A few of these methods have been modified from BonzAI\r\n * codebase, although I have introduced new methods of my own over time as well.\r\n */\r\nlet Cartographer = class Cartographer {\r\n    /**\r\n     * Lists all rooms up to a given distance away, including roomName\r\n     */\r\n    static findRoomsInRange(roomName, depth) {\r\n        return _.flatten(_.values(this.recursiveRoomSearch(roomName, depth)));\r\n    }\r\n    /**\r\n     * Lists all rooms up at a given distance away, including roomName\r\n     */\r\n    static findRoomsAtRange(roomName, depth) {\r\n        return this.recursiveRoomSearch(roomName, depth)[depth];\r\n    }\r\n    /**\r\n     * Recursively enumerate all rooms from a root node using depth first search to a maximum depth\r\n     */\r\n    static recursiveRoomSearch(roomName, maxDepth) {\r\n        const visitedRooms = this._recursiveRoomSearch(roomName, 0, maxDepth, {});\r\n        const roomDepths = {};\r\n        for (const room in visitedRooms) {\r\n            const depth = visitedRooms[room];\r\n            if (!roomDepths[depth]) {\r\n                roomDepths[depth] = [];\r\n            }\r\n            roomDepths[depth].push(room);\r\n        }\r\n        return roomDepths;\r\n    }\r\n    /**\r\n     * The recursive part of recursiveRoomSearch. Yields inverted results mapping roomName to depth.\r\n     */\r\n    static _recursiveRoomSearch(roomName, depth, maxDepth, visited) {\r\n        if (visited[roomName] == undefined) {\r\n            visited[roomName] = depth;\r\n        }\r\n        else {\r\n            visited[roomName] = Math.min(depth, visited[roomName]);\r\n        }\r\n        const neighbors = _.values(Game.map.describeExits(roomName));\r\n        if (depth < maxDepth) {\r\n            for (const neighbor of neighbors) {\r\n                // Visit the neighbor if not already done or if this would be a more direct route\r\n                if (visited[neighbor] == undefined || depth + 1 < visited[neighbor]) {\r\n                    this._recursiveRoomSearch(neighbor, depth + 1, maxDepth, visited);\r\n                }\r\n            }\r\n        }\r\n        return visited;\r\n    }\r\n    /**\r\n     * Get the type of the room\r\n     */\r\n    static roomType(roomName) {\r\n        const coords = this.getRoomCoordinates(roomName);\r\n        if (coords.x % 10 === 0 || coords.y % 10 === 0) {\r\n            return ROOMTYPE_ALLEY;\r\n        }\r\n        else if (coords.x % 10 != 0 && coords.x % 5 === 0 && coords.y % 10 != 0 && coords.y % 5 === 0) {\r\n            return ROOMTYPE_CORE;\r\n        }\r\n        else if (coords.x % 10 <= 6 && coords.x % 10 >= 4 && coords.y % 10 <= 6 && coords.y % 10 >= 4) {\r\n            return ROOMTYPE_SOURCEKEEPER;\r\n        }\r\n        else {\r\n            return ROOMTYPE_CONTROLLER;\r\n        }\r\n    }\r\n    /**\r\n     * Get the name of a room offset from the anchor room\r\n     */\r\n    static findRelativeRoomName(roomName, xDelta, yDelta) {\r\n        const coords = this.getRoomCoordinates(roomName);\r\n        let xDir = coords.xDir;\r\n        if (xDir === 'W') {\r\n            xDelta = -xDelta;\r\n        }\r\n        let yDir = coords.yDir;\r\n        if (yDir === 'N') {\r\n            yDelta = -yDelta;\r\n        }\r\n        let x = coords.x + xDelta;\r\n        let y = coords.y + yDelta;\r\n        if (x < 0) {\r\n            x = Math.abs(x) - 1;\r\n            xDir = this.oppositeDir(xDir);\r\n        }\r\n        if (y < 0) {\r\n            // noinspection JSSuspiciousNameCombination\r\n            y = Math.abs(y) - 1;\r\n            yDir = this.oppositeDir(yDir);\r\n        }\r\n        return xDir + x + yDir + y;\r\n    }\r\n    /**\r\n     * Find the relative x and y offsets of two rooms\r\n     */\r\n    static findRoomCoordDeltas(origin, otherRoom) {\r\n        const originCoords = this.getRoomCoordinates(origin);\r\n        const otherCoords = this.getRoomCoordinates(otherRoom);\r\n        let xDelta = otherCoords.x - originCoords.x;\r\n        if (originCoords.xDir !== otherCoords.xDir) {\r\n            xDelta = otherCoords.x + originCoords.x + 1;\r\n        }\r\n        let yDelta = otherCoords.y - originCoords.y;\r\n        if (originCoords.yDir !== otherCoords.yDir) {\r\n            yDelta = otherCoords.y + originCoords.y + 1;\r\n        }\r\n        // normalize direction\r\n        if (originCoords.xDir === 'W') {\r\n            xDelta = -xDelta;\r\n        }\r\n        if (originCoords.yDir === 'N') {\r\n            yDelta = -yDelta;\r\n        }\r\n        return { x: xDelta, y: yDelta };\r\n    }\r\n    /**\r\n     * Returns the direction (not magnitude) of a room from an origin room\r\n     */\r\n    static findRelativeRoomDir(origin, otherRoom) {\r\n        const coordDeltas = this.findRoomCoordDeltas(origin, otherRoom);\r\n        // noinspection JSSuspiciousNameCombination\r\n        if (Math.abs(coordDeltas.x) == Math.abs(coordDeltas.y)) {\r\n            if (coordDeltas.x > 0) {\r\n                if (coordDeltas.y > 0) {\r\n                    return 2;\r\n                }\r\n                else {\r\n                    return 4;\r\n                }\r\n            }\r\n            else if (coordDeltas.x < 0) {\r\n                if (coordDeltas.y > 0) {\r\n                    return 8;\r\n                }\r\n                else {\r\n                    return 6;\r\n                }\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        }\r\n        else {\r\n            // noinspection JSSuspiciousNameCombination\r\n            if (Math.abs(coordDeltas.x) > Math.abs(coordDeltas.y)) {\r\n                if (coordDeltas.x > 0) {\r\n                    return 3;\r\n                }\r\n                else {\r\n                    return 7;\r\n                }\r\n            }\r\n            else {\r\n                if (coordDeltas.y > 0) {\r\n                    return 1;\r\n                }\r\n                else {\r\n                    return 5;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Return the opposite direction, e.g. \"W\" => \"E\"\r\n     */\r\n    static oppositeDir(dir) {\r\n        switch (dir) {\r\n            case 'W':\r\n                return 'E';\r\n            case 'E':\r\n                return 'W';\r\n            case 'N':\r\n                return 'S';\r\n            case 'S':\r\n                return 'N';\r\n            default:\r\n                return 'error';\r\n        }\r\n    }\r\n    /**\r\n     * Get the coordinates from a room name\r\n     */\r\n    static getRoomCoordinates(roomName) {\r\n        const coordinateRegex = /(E|W)(\\d+)(N|S)(\\d+)/g;\r\n        const match = coordinateRegex.exec(roomName);\r\n        const xDir = match[1];\r\n        const x = match[2];\r\n        const yDir = match[3];\r\n        const y = match[4];\r\n        return {\r\n            x: Number(x),\r\n            y: Number(y),\r\n            xDir: xDir,\r\n            yDir: yDir,\r\n        };\r\n    }\r\n};\r\nCartographer = tslib_1.__decorate([\r\n    profile\r\n], Cartographer);\r\nexport { Cartographer };\r\n","references":["C:/git/Screeps-Revamped/src/profiler/decorator.ts"]}
