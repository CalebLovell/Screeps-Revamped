{"code":"import * as tslib_1 from \"tslib\";\r\nimport { log } from '../console/log';\r\nimport { hasPos } from '../declarations/typeGuards';\r\nimport { CombatIntel } from '../intel/CombatIntel';\r\nimport { Mem } from '../memory/Memory';\r\nimport { normalizePos } from '../movement/helpers';\r\nimport { Movement, NO_ACTION } from '../movement/Movement';\r\nimport { profile } from '../profiler/decorator';\r\nimport { CombatTargeting } from '../targeting/CombatTargeting';\r\nimport { GoalFinder } from '../targeting/GoalFinder';\r\nimport { getCacheExpiration, rotatedMatrix } from '../utilities/utils';\r\nimport { DEFAULT_SWARM_TICK_DIFFERENCE } from './CombatZerg';\r\nconst SwarmMemoryDefaults = {\r\n    creeps: [],\r\n    orientation: TOP,\r\n    numRetreats: 0,\r\n};\r\nconst ERR_NOT_ALL_OK = -7;\r\nconst DEBUG = true;\r\n/**\r\n * Swarms represent a coordinated group of creeps moving as a single unit and use special-purpose pathing and movement\r\n * functions to ensure they don't get separated\r\n */\r\nlet Swarm = class Swarm {\r\n    constructor(overlord, ref, creeps, width = 2, height = 2) {\r\n        this.overlord = overlord;\r\n        this.ref = ref;\r\n        this.memory = Mem.wrap(overlord.memory, `swarm:${ref}`, SwarmMemoryDefaults);\r\n        // Build the static formation by putting attackers at the front and healers at the rear\r\n        const paddedCreeps = _.clone(creeps);\r\n        for (let i = paddedCreeps.length; i < width * height; i++) {\r\n            paddedCreeps.push(undefined); // fill in remaining positions with undefined\r\n        }\r\n        const creepScores = this.getCreepScores(paddedCreeps);\r\n        const sortedCreeps = _.sortBy(paddedCreeps, creep => creepScores[creep != undefined ? creep.name : 'undefined']);\r\n        this.uniformCreepType = (_.unique(_.filter(_.values(creepScores), score => score != 0)).length <= 1);\r\n        this.staticFormation = _.chunk(sortedCreeps, width);\r\n        this.width = width;\r\n        this.height = height;\r\n        const firstCreepIndex = _.findIndex(sortedCreeps);\r\n        let leadPos; // upper left corner of formation when in TOP orientation\r\n        if (firstCreepIndex != -1) {\r\n            const firstCreepPos = sortedCreeps[firstCreepIndex].pos;\r\n            const dx = firstCreepIndex % width;\r\n            const dy = Math.floor(firstCreepIndex / width);\r\n            leadPos = firstCreepPos.getOffsetPos(-dx, -dy);\r\n        }\r\n        else {\r\n            leadPos = this.overlord.pos;\r\n        }\r\n        switch (this.orientation) {\r\n            case TOP:\r\n                this.anchor = leadPos;\r\n                break;\r\n            case RIGHT:\r\n                this.anchor = leadPos.getOffsetPos(-1 * (height - 1), 0);\r\n                break;\r\n            case BOTTOM:\r\n                this.anchor = leadPos.getOffsetPos(-1 * (width - 1), -1 * (height - 1));\r\n                break;\r\n            case LEFT:\r\n                this.anchor = leadPos.getOffsetPos(0, -1 * (width - 1));\r\n                break;\r\n        }\r\n        this.formation = rotatedMatrix(this.staticFormation, this.rotationsFromOrientation(this.orientation));\r\n        this.creeps = creeps;\r\n        this.rooms = _.unique(_.map(this.creeps, creep => creep.room), room => room.name);\r\n        this.roomsByName = _.zipObject(_.map(this.rooms, room => [room.name, room]));\r\n        this.fatigue = _.max(_.map(this.creeps, creep => creep.fatigue));\r\n        this.debug(`\\n${this.print} tick ${Game.time} ========================================`);\r\n        // this.debug(`Orientation: ${this.orientation}, anchor: ${this.anchor.print}, leadPos: ${leadPos.print}`);\r\n        // this.debug(`Formation: ${this.printFormation(this.formation)}`);\r\n        // this.debug(`StaticFormation: ${this.printFormation(this.staticFormation)}`);\r\n    }\r\n    getCreepScores(creeps) {\r\n        const keys = _.map(creeps, c => c != undefined ? c.name : 'undefined');\r\n        const values = _.map(creeps, z => {\r\n            if (z == undefined) {\r\n                return 0;\r\n            }\r\n            else {\r\n                const score = CombatIntel.getAttackPotential(z.creep) + CombatIntel.getRangedAttackPotential(z.creep)\r\n                    + CombatIntel.getDismantlePotential(z.creep) - CombatIntel.getHealPotential(z.creep);\r\n                return (-1 * score) || 1;\r\n            }\r\n        });\r\n        return _.zipObject(keys, values);\r\n    }\r\n    printFormation(formation) {\r\n        const names = _.map(formation, creeps => _.map(creeps, creep => creep ? creep.name : 'NONE'));\r\n        const SPACE = '    ';\r\n        let msg = '';\r\n        for (const row of names) {\r\n            msg += '\\n' + SPACE;\r\n            for (const name of row) {\r\n                if (name != 'NONE') {\r\n                    const role = name.split('_')[0];\r\n                    const num = name.split('_')[1];\r\n                    const shortName = role.slice(0, 4 - num.length) + num;\r\n                    msg += shortName;\r\n                }\r\n                else {\r\n                    msg += name;\r\n                }\r\n                msg += ' ';\r\n            }\r\n        }\r\n        return msg;\r\n    }\r\n    get print() {\r\n        return '<a href=\"#!/room/' + Game.shard.name + '/' + this.anchor.roomName + '\">[' + `Swarm ` + this.ref + ']</a>';\r\n    }\r\n    debug(...args) {\r\n        if (DEBUG) {\r\n            console.log(args);\r\n        }\r\n    }\r\n    // This should occasionally be executed at run() phase\r\n    static cleanMemory(overlord) {\r\n        for (const ref in overlord.swarms) {\r\n            // TODO\r\n        }\r\n    }\r\n    get target() {\r\n        if (this.memory.target && this.memory.target.exp > Game.time) {\r\n            const target = Game.getObjectById(this.memory.target.id);\r\n            if (target) {\r\n                return target;\r\n            }\r\n        }\r\n        // If nothing found\r\n        delete this.memory.target;\r\n    }\r\n    set target(targ) {\r\n        if (targ) {\r\n            this.memory.target = { id: targ.id, exp: getCacheExpiration(100) };\r\n        }\r\n        else {\r\n            delete this.memory.target;\r\n        }\r\n    }\r\n    get orientation() {\r\n        return this.memory.orientation;\r\n    }\r\n    set orientation(direction) {\r\n        this.memory.orientation = direction;\r\n        this.formation = rotatedMatrix(this.staticFormation, this.rotationsFromOrientation(direction));\r\n    }\r\n    /**\r\n     * Pivots the swarm formation clockwise or counterclockwise\r\n     */\r\n    pivot(direction) {\r\n        if (this.fatigue > 0) {\r\n            return ERR_TIRED;\r\n        }\r\n        this.debug(`Rotating ${direction}`);\r\n        const [[c1, c2], [c3, c4]] = this.formation;\r\n        this.debug(`c1...c4: ${this.printFormation([\r\n            [c1, c2],\r\n            [c3, c4]\r\n        ])}`);\r\n        let r1, r2, r3, r4 = OK;\r\n        if (direction == 'clockwise') {\r\n            if (c1)\r\n                r1 = c1.move(RIGHT);\r\n            if (c2)\r\n                r2 = c2.move(BOTTOM);\r\n            if (c3)\r\n                r3 = c3.move(TOP);\r\n            if (c4)\r\n                r4 = c4.move(LEFT);\r\n        }\r\n        else {\r\n            if (c1)\r\n                r1 = c1.move(BOTTOM);\r\n            if (c2)\r\n                r2 = c2.move(LEFT);\r\n            if (c3)\r\n                r3 = c3.move(RIGHT);\r\n            if (c4)\r\n                r4 = c4.move(TOP);\r\n        }\r\n        const allMoved = _.all([r1, r2, r3, r4], r => r == OK);\r\n        if (allMoved) {\r\n            return OK;\r\n        }\r\n        else {\r\n            for (const creep of this.creeps) {\r\n                creep.cancelOrder('move');\r\n            }\r\n            return -1 * (_.findIndex([r1, r2, r3, r4], r => r != OK) || 899) - 100;\r\n        }\r\n    }\r\n    /**\r\n     * Reverses the orientation of the swarm formation in an X pattern to preserve the reflective parity of the\r\n     * original formation\r\n     */\r\n    swap(direction) {\r\n        if (this.fatigue > 0) {\r\n            return ERR_TIRED;\r\n        }\r\n        this.debug(`Swapping ${direction}ly`);\r\n        const [[c1, c2], [c3, c4]] = this.formation;\r\n        this.debug(`c1...c4: ${this.printFormation([\r\n            [c1, c2],\r\n            [c3, c4]\r\n        ])}`);\r\n        let r1, r2, r3, r4 = OK;\r\n        // This operation is actually the same for both horizontal and vertical swaps\r\n        if (c1)\r\n            r1 = c1.move(BOTTOM_RIGHT);\r\n        if (c2)\r\n            r2 = c2.move(BOTTOM_LEFT);\r\n        if (c3)\r\n            r3 = c3.move(TOP_RIGHT);\r\n        if (c4)\r\n            r4 = c4.move(TOP_LEFT);\r\n        const allMoved = _.all([r1, r2, r3, r4], r => r == OK);\r\n        if (allMoved) {\r\n            return OK;\r\n        }\r\n        else {\r\n            for (const creep of this.creeps) {\r\n                creep.cancelOrder('move');\r\n            }\r\n            return -1 * (_.findIndex([r1, r2, r3, r4], r => r != OK) || 899) - 100;\r\n        }\r\n    }\r\n    rotate(direction) {\r\n        if (direction == this.orientation) {\r\n            // do nothing\r\n            return NO_ACTION;\r\n        }\r\n        if (!(this.width == 2 && this.height == 2)) {\r\n            console.log('NOT IMPLEMENTED FOR LARGER SWARMS YET');\r\n            return -100;\r\n        }\r\n        let ret = -777;\r\n        if (this.fatigue > 0) {\r\n            ret = ERR_TIRED;\r\n        }\r\n        else {\r\n            const prevDirection = this.orientation;\r\n            const prevFormation = this.formation;\r\n            const prevAngle = this.rotationsFromOrientation(prevDirection);\r\n            const newAngle = this.rotationsFromOrientation(direction);\r\n            const rotateAngle = newAngle - prevAngle;\r\n            if (rotateAngle == 3 || rotateAngle == -1) {\r\n                ret = this.pivot('counterclockwise');\r\n            }\r\n            else if (rotateAngle == 1 || rotateAngle == -3) {\r\n                ret = this.pivot('clockwise');\r\n            }\r\n            else if (rotateAngle == 2 || rotateAngle == -2) {\r\n                if (newAngle % 2 == 0) {\r\n                    ret = this.swap('vertical');\r\n                }\r\n                else {\r\n                    ret = this.swap('horizontal');\r\n                }\r\n            }\r\n            if (ret == OK) {\r\n                this.orientation = direction;\r\n            }\r\n        }\r\n        this.debug(`Rotating to ${direction}, result: ${ret}`);\r\n        return ret;\r\n    }\r\n    /**\r\n     * Number of clockwise 90 degree turns corresponding to an orientation\r\n     */\r\n    rotationsFromOrientation(direction) {\r\n        switch (direction) {\r\n            case TOP:\r\n                return 0;\r\n            case RIGHT:\r\n                return 1;\r\n            case BOTTOM:\r\n                return 2;\r\n            case LEFT:\r\n                return 3;\r\n        }\r\n    }\r\n    // Swarm assignment ================================================================================================\r\n    // Range finding methods ===========================================================================================\r\n    minRangeTo(obj) {\r\n        if (hasPos(obj)) {\r\n            return _.min(_.map(this.creeps, creep => creep.pos.roomName === obj.pos.roomName ? creep.pos.getRangeToXY(obj.pos.x, obj.pos.y) : Infinity));\r\n        }\r\n        else {\r\n            return _.min(_.map(this.creeps, creep => creep.pos.roomName === obj.roomName ? creep.pos.getRangeToXY(obj.x, obj.y) : Infinity));\r\n        }\r\n    }\r\n    maxRangeTo(obj) {\r\n        if (hasPos(obj)) {\r\n            return _.max(_.map(this.creeps, creep => creep.pos.roomName === obj.pos.roomName ? creep.pos.getRangeToXY(obj.pos.x, obj.pos.y) : Infinity));\r\n        }\r\n        else {\r\n            return _.max(_.map(this.creeps, creep => creep.pos.roomName === obj.roomName ? creep.pos.getRangeToXY(obj.x, obj.y) : Infinity));\r\n        }\r\n    }\r\n    findInMinRange(targets, range) {\r\n        const initialRange = range + Math.max(this.width, this.height) - 1;\r\n        const targetsInRange = _.filter(targets, t => this.anchor.inRangeToXY(t.pos.x, t.pos.y, initialRange));\r\n        return _.filter(targetsInRange, t => this.minRangeTo(t) <= range);\r\n    }\r\n    /**\r\n     * Compute the \"average\" direction to a target\r\n     */\r\n    getDirectionTo(obj) {\r\n        const pos = normalizePos(obj);\r\n        const directions = _.map(this.creeps, creep => creep.pos.getDirectionTo(obj));\r\n        // TODO\r\n        log.warning(`NOT IMPLEMENTED`);\r\n        return TOP;\r\n    }\r\n    // Formation methods ===============================================================================================\r\n    /**\r\n     * Generates a table of formation positions for each creep\r\n     */\r\n    getFormationPositionsFromAnchor(anchor) {\r\n        const formationPositions = {};\r\n        for (let dy = 0; dy < this.formation.length; dy++) {\r\n            for (let dx = 0; dx < this.formation[dy].length; dx++) {\r\n                if (this.formation[dy][dx]) {\r\n                    formationPositions[this.formation[dy][dx].name] = anchor.getOffsetPos(dx, dy);\r\n                }\r\n            }\r\n        }\r\n        // this.debug(`Formation positions: `, JSON.stringify(formationPositions));\r\n        return formationPositions;\r\n    }\r\n    /**\r\n     * Returtn whether every creep in the swarm is in the position dictated by formation\r\n     */\r\n    isInFormation(anchor = this.anchor) {\r\n        const formationPositions = this.getFormationPositionsFromAnchor(anchor);\r\n        return _.all(this.creeps, creep => creep.pos.isEqualTo(formationPositions[creep.name]));\r\n    }\r\n    get hasMaxCreeps() {\r\n        return this.creeps.length == this.width * this.height;\r\n    }\r\n    /**\r\n     * Returns true if the swarm has lost a creep and the oldest living creep is too old to partner with a new one\r\n     */\r\n    get isExpired() {\r\n        if (!this.hasMaxCreeps) {\r\n            const minTicksToLive = _.min(_.map(this.creeps, creep => creep.ticksToLive || 9999)) || 0;\r\n            const spawnBuffer = 150 + 25;\r\n            const newCreepTicksToLive = CREEP_LIFE_TIME + spawnBuffer; // TTL of a creep spawned right now\r\n            return newCreepTicksToLive - minTicksToLive >= DEFAULT_SWARM_TICK_DIFFERENCE;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    get inMultipleRooms() {\r\n        return _.keys(this.roomsByName).length > 1;\r\n    }\r\n    /**\r\n     * Assemble the swarm at the target location\r\n     */\r\n    assemble(assemblyPoint, allowIdleCombat = true) {\r\n        if (this.isInFormation(assemblyPoint) && this.hasMaxCreeps) {\r\n            this.memory.initialAssembly = true;\r\n            return true;\r\n        }\r\n        else {\r\n            // Creeps travel to their relative formation positions\r\n            const formationPositions = this.getFormationPositionsFromAnchor(assemblyPoint);\r\n            console.log(JSON.stringify(formationPositions));\r\n            for (const creep of this.creeps) {\r\n                if (creep.hasValidTask) {\r\n                    // Ignore creeps which have tasks (usually getting boosted)\r\n                    continue;\r\n                }\r\n                if (allowIdleCombat && creep.room.dangerousPlayerHostiles.length > 0 && !this.hasMaxCreeps) {\r\n                    creep.autoSkirmish(creep.room.name);\r\n                }\r\n                else {\r\n                    const destination = formationPositions[creep.name];\r\n                    const ret = creep.goTo(destination, {\r\n                        noPush: creep.pos.inRangeToPos(destination, 5),\r\n                        ignoreCreepsOnDestination: true,\r\n                    });\r\n                    console.log(`${creep.print} moves to ${destination.print}, response: ${ret}`);\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    findRegroupPosition() {\r\n        let x, y;\r\n        const MAX_RADIUS = 10;\r\n        for (let radius = 0; radius < MAX_RADIUS; radius++) {\r\n            for (let dx = -radius; dx <= radius; dx++) {\r\n                for (let dy = -radius; dy <= radius; dy++) {\r\n                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {\r\n                        continue;\r\n                    }\r\n                    x = this.anchor.x + dx;\r\n                    y = this.anchor.y + dy;\r\n                    if (x < 0 || x > 49 || y < 0 || y > 49) {\r\n                        continue;\r\n                    }\r\n                    let allPathable = true;\r\n                    const pos = new RoomPosition(x, y, this.anchor.roomName);\r\n                    for (let i = 0; i < this.formation.length; i++) {\r\n                        for (let j = 0; j < this.formation[i].length; j++) {\r\n                            if (!pos.getOffsetPos(i, j).isWalkable(true)) {\r\n                                allPathable = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (allPathable) {\r\n                        return pos;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Should never reach here!\r\n        return new RoomPosition(-10, -10, 'cannotFindLocationPosition');\r\n    }\r\n    /**\r\n     * Try to re-assemble the swarm at the nearest possible location in case it broke formation\r\n     */\r\n    regroup() {\r\n        if (this.isInFormation(this.anchor)) {\r\n            return true;\r\n        }\r\n        else {\r\n            const regroupPosition = this.findRegroupPosition();\r\n            this.debug(`Reassembling at ${regroupPosition.print}`);\r\n            return this.assemble(regroupPosition, false);\r\n        }\r\n    }\r\n    // Movement methods ================================================================================================\r\n    move(direction) {\r\n        let allMoved = true;\r\n        for (const creep of this.creeps) {\r\n            const result = creep.move(direction);\r\n            this.debug(`${creep.print} move ${direction}, result: ${result}`);\r\n            if (result != OK) {\r\n                allMoved = false;\r\n            }\r\n        }\r\n        if (!allMoved) {\r\n            for (const creep of this.creeps) {\r\n                creep.cancelOrder('move');\r\n            }\r\n        }\r\n        return allMoved ? OK : ERR_NOT_ALL_OK;\r\n    }\r\n    goTo(destination, options = {}) {\r\n        // if (DEBUG) {\r\n        // \toptions.displayCostMatrix = true;\r\n        // }\r\n        return Movement.swarmMove(this, destination, options);\r\n    }\r\n    goToRoom(roomName, options = {}) {\r\n        // if (DEBUG) {\r\n        // \toptions.displayCostMatrix = true;\r\n        // }\r\n        return Movement.goToRoom_swarm(this, roomName, options);\r\n    }\r\n    combatMove(approach, avoid, options = {}) {\r\n        // if (DEBUG) {\r\n        // \toptions.displayAvoid = true;\r\n        // }\r\n        const ret = Movement.swarmCombatMove(this, approach, avoid, options);\r\n        this.debug(`Moving... Result: ${ret}`);\r\n        return ret;\r\n    }\r\n    safelyInRoom(roomName) {\r\n        return _.all(this.creeps, creep => creep.safelyInRoom(roomName));\r\n    }\r\n    // private getBestSiegeOrientation(room: Room): TOP | RIGHT | BOTTOM | LEFT {\r\n    // \tlet targets: HasPos[] = [];\r\n    // \tlet structureTargets = this.findInMinRange(room.hostileStructures, 1);\r\n    // \tfor (let structure of structureTargets) {\r\n    // \t\ttargets.push(structure);\r\n    // \t}\r\n    // \tthis.debug(`Targets: `, _.map(targets, t => t.pos.print));\r\n    // \tif (targets.length == 0) {\r\n    // \t\treturn this.orientation;\r\n    // \t}\r\n    // \tlet dxList = _.flatten(_.map(this.creeps,\r\n    // \t\t\t\t\t\t\t\t creep => _.map(targets,\r\n    // \t\t\t\t\t\t\t\t\t\t\t\ttarget => target.pos.x - creep.pos.x))) as number[];\r\n    // \tlet dyList = _.flatten(_.map(this.creeps,\r\n    // \t\t\t\t\t\t\t\t creep => _.map(targets,\r\n    // \t\t\t\t\t\t\t\t\t\t\t\ttarget => target.pos.y - creep.pos.y))) as number[];\r\n    // \tlet dx = _.sum(dxList) / dxList.length || 0;\r\n    // \tlet dy = _.sum(dyList) / dyList.length || 0;\r\n    // \tthis.debug(`dx: ${dx}, dy: ${dy}`);\r\n    // \tif (Math.abs(dx) > Math.abs(dy)) {\r\n    // \t\treturn dx > 0 ? RIGHT : LEFT;\r\n    // \t} else {\r\n    // \t\treturn dy > 0 ? BOTTOM : TOP;\r\n    // \t}\r\n    // }\r\n    reorient(includeStructures = true, includeCreeps = false) {\r\n        if (this.uniformCreepType) {\r\n            return NO_ACTION;\r\n        }\r\n        const targetRoom = _.find(this.rooms, room => room.owner && !room.my);\r\n        if (targetRoom) {\r\n            const orientation = this.getBestOrientation(targetRoom, includeStructures, includeCreeps);\r\n            if (orientation != this.orientation && this.fatigue == 0) {\r\n                this.debug(`Reorienting to ${orientation}!`);\r\n                return this.rotate(orientation);\r\n            }\r\n        }\r\n        return NO_ACTION;\r\n    }\r\n    getBestOrientation(room, includeStructures = true, includeCreeps = false) {\r\n        const targets = [];\r\n        if (includeStructures) {\r\n            const structureTargets = this.findInMinRange(room.hostileStructures, 1);\r\n            for (const structure of structureTargets) {\r\n                targets.push(structure);\r\n            }\r\n        }\r\n        if (includeCreeps) {\r\n            const creepTargets = this.findInMinRange(room.dangerousHostiles, 2);\r\n            for (const creep of creepTargets) {\r\n                targets.push(creep);\r\n            }\r\n        }\r\n        this.debug(`Targets: `, _.map(targets, t => t.pos.print));\r\n        if (targets.length == 0) {\r\n            return this.orientation;\r\n        }\r\n        const dxList = _.flatten(_.map(this.creeps, creep => _.map(targets, target => target.pos.x - creep.pos.x)));\r\n        const dyList = _.flatten(_.map(this.creeps, creep => _.map(targets, target => target.pos.y - creep.pos.y)));\r\n        const dx = _.sum(dxList) / dxList.length || 0;\r\n        const dy = _.sum(dyList) / dyList.length || 0;\r\n        this.debug(`dx: ${dx}, dy: ${dy}`);\r\n        if (Math.abs(dx) > Math.abs(dy)) {\r\n            return dx > 0 ? RIGHT : LEFT;\r\n        }\r\n        else {\r\n            return dy > 0 ? BOTTOM : TOP;\r\n        }\r\n    }\r\n    // Auto-combat methods =============================================================================================\r\n    /**\r\n     * Automatically melee-attack the best creep in range\r\n     */\r\n    autoMelee() {\r\n        for (const creep of this.creeps) {\r\n            if (creep.getActiveBodyparts(ATTACK) > 0) {\r\n                creep.autoMelee();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Automatically ranged-attack the best creep in range\r\n     */\r\n    autoRanged() {\r\n        for (const creep of this.creeps) {\r\n            if (creep.getActiveBodyparts(RANGED_ATTACK) > 0) {\r\n                creep.autoRanged();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Automatically heal the best creep in range\r\n     */\r\n    autoHeal(allowRangedHeal = true) {\r\n        for (const creep of this.creeps) {\r\n            if (creep.getActiveBodyparts(HEAL) > 0) {\r\n                creep.autoHeal(allowRangedHeal);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Standard sequence of actions for sieging a room. Assumes the swarm has already initially assembled.\r\n     */\r\n    autoSiege(roomName, waypoint) {\r\n        this.autoMelee();\r\n        this.autoRanged();\r\n        this.autoHeal();\r\n        if (!this.isInFormation()) {\r\n            this.debug(`Regrouping!`);\r\n            if (!_.any(this.creeps, creep => creep.pos.isEdge)) {\r\n                return this.regroup();\r\n            }\r\n        }\r\n        // Handle recovery if low on HP\r\n        if (this.needsToRecover()) {\r\n            this.debug(`Recovering!`);\r\n            this.target = undefined; // invalidate target\r\n            return this.recover();\r\n        }\r\n        // Travel to the target room\r\n        if (!this.safelyInRoom(roomName)) {\r\n            if (waypoint) {\r\n                return this.goTo(waypoint);\r\n            }\r\n            else {\r\n                return this.goToRoom(roomName);\r\n            }\r\n        }\r\n        // Find a target if needed\r\n        if (!this.target) {\r\n            const displayCostMatrix = DEBUG;\r\n            this.target = CombatTargeting.findBestSwarmStructureTarget(this, roomName, 10 * this.memory.numRetreats, displayCostMatrix);\r\n            this.debug(this.target);\r\n        }\r\n        // Approach the siege target\r\n        if (this.target) {\r\n            // let approach = _.map(Pathing.getPosWindow(this.target.pos, -this.width, -this.height),\r\n            // \t\t\t\t\t pos => ({pos: pos, range: 1}));\r\n            const result = this.combatMove([{ pos: this.target.pos, range: 1 }], []);\r\n            if (result != NO_ACTION) {\r\n                this.debug(`Moving to target ${this.target}: ${result}`);\r\n                return result;\r\n            }\r\n            else {\r\n                // Move to best damage spot\r\n                // TODO\r\n            }\r\n        }\r\n        else {\r\n            log.warning(`No target for swarm ${this.ref}!`);\r\n        }\r\n        // Orient yourself to face structure targets\r\n        this.reorient(true, false);\r\n    }\r\n    /**\r\n     * Standard sequence of actions for fighting within a room. Assumes the swarm has already initially assembled.\r\n     */\r\n    autoCombat(roomName, waypoint) {\r\n        this.debug(`Running autocombat!`);\r\n        this.autoMelee();\r\n        this.autoRanged();\r\n        this.autoHeal();\r\n        if (!this.isInFormation()) {\r\n            this.debug(`Regrouping!`);\r\n            if (!_.any(this.creeps, creep => creep.pos.isEdge)) {\r\n                return this.regroup();\r\n            }\r\n        }\r\n        // Handle recovery if low on HP\r\n        if (this.needsToRecover()) {\r\n            this.debug(`Recovering!`);\r\n            this.target = undefined; // invalidate target\r\n            return this.recover();\r\n        }\r\n        // Travel to the target room\r\n        if (!this.safelyInRoom(roomName)) {\r\n            this.debug(`Going to room!`);\r\n            // if (this.rooms[0].dangerousHostiles.length > 0) {\r\n            //\r\n            // } else {\r\n            //\r\n            // }\r\n            if (waypoint) {\r\n                return this.goTo(waypoint);\r\n            }\r\n            else {\r\n                return this.goToRoom(roomName);\r\n            }\r\n        }\r\n        // Maneuver around the room\r\n        const goals = GoalFinder.swarmCombatGoals(this, true);\r\n        this.debug(`Goals: ${JSON.stringify(goals)}`);\r\n        if (_.any(goals.avoid, goal => this.minRangeTo(goal) <= goal.range)) {\r\n            // If creeps nearby, try to flee first, then reorient\r\n            let result = this.combatMove(goals.approach, goals.avoid);\r\n            if (result != OK) {\r\n                result = this.reorient(true, true);\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            // Otherwise try to reorient first then move\r\n            let result = this.reorient(true, true);\r\n            if (result != OK) {\r\n                result = this.combatMove(goals.approach, goals.avoid);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    needsToRecover(recoverThreshold = 0.75, reengageThreshold = 1.0) {\r\n        let recovering;\r\n        if (this.memory.recovering) {\r\n            recovering = _.any(this.creeps, creep => creep.hits < creep.hitsMax * reengageThreshold);\r\n        }\r\n        else {\r\n            recovering = _.any(this.creeps, creep => creep.hits < creep.hitsMax * recoverThreshold);\r\n        }\r\n        if (recovering && recovering != this.memory.recovering) {\r\n            this.memory.numRetreats++;\r\n        }\r\n        this.memory.recovering = recovering;\r\n        return recovering;\r\n    }\r\n    recover() {\r\n        const allHostiles = _.flatten(_.map(this.rooms, room => room.hostiles));\r\n        const allTowers = _.flatten(_.map(this.rooms, room => room.owner && !room.my ? room.towers : []));\r\n        if (_.filter(allHostiles, h => this.minRangeTo(h)).length > 0 || allTowers.length > 0) {\r\n            this.memory.lastInDanger = Game.time;\r\n        }\r\n        const allAvoidGoals = _.flatten(_.map(this.rooms, room => GoalFinder.retreatGoalsForRoom(room).avoid));\r\n        const result = Movement.swarmCombatMove(this, [], allAvoidGoals);\r\n        if (result == NO_ACTION) {\r\n            const safeRoom = _.first(_.filter(this.rooms, room => !room.owner || room.my));\r\n            if (safeRoom && !this.safelyInRoom(safeRoom.name)) {\r\n                if (Game.time < (this.memory.lastInDanger || 0) + 3) {\r\n                    return this.goToRoom(safeRoom.name);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // Simulated swarms ================================================================================================\r\n    /**\r\n     * Groups enemies into proto-swarms based on proximity to each other\r\n     */\r\n    static findEnemySwarms(room, anchor, maxClumpSize = 3) {\r\n        const enemySwarms = [];\r\n        const origin = anchor || _.first(room.spawns) || room.controller || { pos: new RoomPosition(25, 25, room.name) };\r\n        let attackers = _.sortBy(room.dangerousHostiles, creep => origin.pos.getRangeTo(creep));\r\n        while (attackers.length > 0) {\r\n            const clump = _.first(attackers).pos.findInRange(attackers, maxClumpSize);\r\n            attackers = _.difference(attackers, clump);\r\n            enemySwarms.push({ creeps: clump });\r\n        }\r\n        return enemySwarms;\r\n    }\r\n};\r\nSwarm = tslib_1.__decorate([\r\n    profile\r\n], Swarm);\r\nexport { Swarm };\r\n","references":["C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/declarations/typeGuards.ts","C:/git/Screeps-Revamped/src/intel/CombatIntel.ts","C:/git/Screeps-Revamped/src/memory/Memory.ts","C:/git/Screeps-Revamped/src/movement/helpers.ts","C:/git/Screeps-Revamped/src/movement/Movement.ts","C:/git/Screeps-Revamped/src/overlords/CombatOverlord.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/targeting/CombatTargeting.ts","C:/git/Screeps-Revamped/src/targeting/GoalFinder.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts","C:/git/Screeps-Revamped/src/zerg/CombatZerg.ts"]}
