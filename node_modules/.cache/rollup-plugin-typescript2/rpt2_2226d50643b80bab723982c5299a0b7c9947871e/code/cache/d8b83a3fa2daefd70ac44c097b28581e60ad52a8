{"code":"import * as tslib_1 from \"tslib\";\r\nimport { CombatIntel } from '../../intel/CombatIntel';\r\nimport { BunkerDefenseOverlord } from '../../overlords/defense/bunkerDefense';\r\nimport { MeleeDefenseOverlord } from '../../overlords/defense/meleeDefense';\r\nimport { RangedDefenseOverlord } from '../../overlords/defense/rangedDefense';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { ColonyStage } from '../../Colony';\r\nimport { Directive } from '../Directive';\r\nimport { NotifierPriority } from '../Notifier';\r\n/**\r\n * Defend an owned room against an incoming player invasion\r\n */\r\nlet DirectiveInvasionDefense = class DirectiveInvasionDefense extends Directive {\r\n    constructor(flag) {\r\n        super(flag, colony => colony.level >= 1 && colony.spawns.length > 0);\r\n    }\r\n    spawnMoarOverlords() {\r\n        if (!this.room) {\r\n            return;\r\n        }\r\n        const expectedDamage = CombatIntel.maxDamageByCreeps(this.room.dangerousPlayerHostiles);\r\n        const expectedHealing = CombatIntel.maxHealingByCreeps(this.room.dangerousPlayerHostiles);\r\n        const useBoosts = (expectedDamage > ATTACK_POWER * 50) || (expectedHealing > RANGED_ATTACK_POWER * 100)\r\n            && !!this.colony.terminal\r\n            && !!this.colony.evolutionChamber;\r\n        const percentWalls = _.filter(this.room.barriers, s => s.structureType == STRUCTURE_WALL).length /\r\n            this.room.barriers.length;\r\n        const meleeHostiles = _.filter(this.room.hostiles, hostile => hostile.getActiveBodyparts(ATTACK) > 0 ||\r\n            hostile.getActiveBodyparts(WORK) > 0);\r\n        const rangedHostiles = _.filter(this.room.hostiles, hostile => hostile.getActiveBodyparts(RANGED_ATTACK) > 0);\r\n        if (this.colony.stage > ColonyStage.Larva) {\r\n            this.overlords.rangedDefense = new RangedDefenseOverlord(this, useBoosts);\r\n        }\r\n        else {\r\n            this.overlords.meleeDefense = new MeleeDefenseOverlord(this, useBoosts);\r\n        }\r\n        // If serious bunker busting attempt, spawn lurkers\r\n        // TODO understand dismantlers damage output\r\n        if (meleeHostiles.length > 0 && (expectedDamage > ATTACK_POWER * 70)) {\r\n            this.overlords.bunkerDefense = new BunkerDefenseOverlord(this, false);\r\n        }\r\n    }\r\n    init() {\r\n        const numHostiles = this.room ? this.room.hostiles.length.toString() : '???';\r\n        this.alert(`Invasion (hostiles: ${numHostiles})`, NotifierPriority.Critical);\r\n    }\r\n    run() {\r\n        if (!this.room || this.room.hostiles.length > 0) {\r\n            this.memory.safeSince = Game.time;\r\n        }\r\n        // If there are no hostiles left in the room and everyone's healed, then remove the flag\r\n        if (this.room && this.room.hostiles.length == 0 &&\r\n            Game.time - this.memory.safeSince > 100 && this.room.hostileStructures.length == 0) {\r\n            if (_.filter(this.room.creeps, creep => creep.hits < creep.hitsMax).length == 0) {\r\n                this.remove();\r\n            }\r\n        }\r\n    }\r\n};\r\nDirectiveInvasionDefense.directiveName = 'invasionDefense';\r\nDirectiveInvasionDefense.color = COLOR_BLUE;\r\nDirectiveInvasionDefense.secondaryColor = COLOR_PURPLE;\r\nDirectiveInvasionDefense = tslib_1.__decorate([\r\n    profile\r\n], DirectiveInvasionDefense);\r\nexport { DirectiveInvasionDefense };\r\n","references":["C:/git/Screeps-Revamped/src/intel/CombatIntel.ts","C:/git/Screeps-Revamped/src/overlords/defense/bunkerDefense.ts","C:/git/Screeps-Revamped/src/overlords/defense/meleeDefense.ts","C:/git/Screeps-Revamped/src/overlords/defense/rangedDefense.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/directives/Directive.ts","C:/git/Screeps-Revamped/src/directives/Notifier.ts"]}
