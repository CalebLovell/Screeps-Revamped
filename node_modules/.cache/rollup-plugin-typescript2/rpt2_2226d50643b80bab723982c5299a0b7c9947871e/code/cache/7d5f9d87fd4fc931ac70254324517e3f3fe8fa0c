{"code":"/* tslint:disable:variable-name */\r\nimport * as tslib_1 from \"tslib\";\r\nvar LogisticsNetwork_1;\r\nimport columnify from 'columnify';\r\nimport { Matcher } from '../algorithms/galeShapley';\r\nimport { log } from '../console/log';\r\nimport { Roles } from '../creepSetups/setups';\r\nimport { isEnergyStructure, isResource, isStoreStructure, isTombstone } from '../declarations/typeGuards';\r\nimport { Mem } from '../memory/Memory';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { profile } from '../profiler/decorator';\r\nimport { minMax } from '../utilities/utils';\r\nexport const ALL_RESOURCE_TYPE_ERROR = `Improper logistics request: 'all' can only be used for store structure or tombstone!`;\r\nconst LogisticsNetworkMemoryDefaults = {\r\n    transporterCache: {},\r\n};\r\n/**\r\n * Logistics network: efficiently partners resource requests with transporters using a stable matching algorithm to\r\n * provide general-purpose resource transport. For a better explanation of how this system works, see my blog post:\r\n * https://bencbartlett.wordpress.com/2018/03/28/screeps-4-hauling-is-np-hard/\r\n */\r\nlet LogisticsNetwork = LogisticsNetwork_1 = class LogisticsNetwork {\r\n    constructor(colony) {\r\n        this.memory = Mem.wrap(colony.memory, 'logisticsNetwork', LogisticsNetworkMemoryDefaults);\r\n        this.requests = [];\r\n        this.targetToRequest = {};\r\n        this.colony = colony;\r\n        // this.transporters = _.filter(colony.getCreepsByRole(TransporterSetup.role),\r\n        // \t\t\t\t\t\t\t creep => !creep.spawning &&\r\n        // \t\t\t\t\t\t\t\t\t  creep.carryCapacity >= LogisticsNetwork.settings.carryThreshold);\r\n        this.buffers = _.compact([colony.storage, colony.terminal]);\r\n        this.cache = {\r\n            nextAvailability: {},\r\n            predictedTransporterCarry: {},\r\n            resourceChangeRate: {}\r\n        };\r\n        // this.logisticPositions = {};\r\n        // for (let room of this.colony.rooms) {\r\n        // \tthis.logisticPositions[room.name] = _.map([...room.storageUnits, ...room.links], s => s.pos);\r\n        // }\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(this.colony.memory, 'logisticsNetwork', LogisticsNetworkMemoryDefaults);\r\n        this.requests = [];\r\n        this.targetToRequest = {};\r\n        this._matching = undefined;\r\n        this.cache = {\r\n            nextAvailability: {},\r\n            predictedTransporterCarry: {},\r\n            resourceChangeRate: {}\r\n        };\r\n    }\r\n    // Request and provide functions ===================================================================================\r\n    /**\r\n     * Request for resources to be deposited into this target\r\n     */\r\n    requestInput(target, opts = {}) {\r\n        _.defaults(opts, {\r\n            resourceType: RESOURCE_ENERGY,\r\n            multiplier: 1,\r\n            dAmountdt: 0,\r\n        });\r\n        if (target.room != this.colony.room) {\r\n            log.warning(`${target.ref} at ${target.pos.print} is outside colony room; shouldn't request!`);\r\n            return;\r\n        }\r\n        if (opts.resourceType == 'all') {\r\n            log.warning(`Logistics request error: 'all' can only be used for output requests`);\r\n            return;\r\n        }\r\n        if (!opts.amount) {\r\n            opts.amount = this.getInputAmount(target, opts.resourceType);\r\n        }\r\n        // Register the request\r\n        const requestID = this.requests.length;\r\n        const req = {\r\n            id: requestID.toString(),\r\n            target: target,\r\n            amount: opts.amount,\r\n            dAmountdt: opts.dAmountdt,\r\n            resourceType: opts.resourceType,\r\n            multiplier: opts.multiplier,\r\n        };\r\n        this.requests.push(req);\r\n        this.targetToRequest[req.target.ref] = requestID;\r\n    }\r\n    /**\r\n     * Request for resources to be withdrawn from this target\r\n     */\r\n    requestOutput(target, opts = {}) {\r\n        _.defaults(opts, {\r\n            resourceType: RESOURCE_ENERGY,\r\n            multiplier: 1,\r\n            dAmountdt: 0,\r\n        });\r\n        if (opts.resourceType == 'all' && (isStoreStructure(target) || isTombstone(target))) {\r\n            if (_.sum(target.store) == target.store.energy) {\r\n                opts.resourceType = RESOURCE_ENERGY; // convert \"all\" requests to energy if that's all they have\r\n            }\r\n        }\r\n        if (!opts.amount) {\r\n            opts.amount = this.getOutputAmount(target, opts.resourceType);\r\n        }\r\n        opts.amount *= -1;\r\n        (opts.dAmountdt) *= -1;\r\n        // Register the request\r\n        const requestID = this.requests.length;\r\n        const req = {\r\n            id: requestID.toString(),\r\n            target: target,\r\n            amount: opts.amount,\r\n            dAmountdt: opts.dAmountdt,\r\n            resourceType: opts.resourceType,\r\n            multiplier: opts.multiplier,\r\n        };\r\n        this.requests.push(req);\r\n        this.targetToRequest[req.target.ref] = requestID;\r\n    }\r\n    /**\r\n     * Requests output for every mineral in a requestor object\r\n     */\r\n    requestOutputMinerals(target, opts = {}) {\r\n        for (const resourceType in target.store) {\r\n            if (resourceType == RESOURCE_ENERGY)\r\n                continue;\r\n            const amount = target.store[resourceType] || 0;\r\n            if (amount > 0) {\r\n                opts.resourceType = resourceType;\r\n                this.requestOutput(target, opts);\r\n            }\r\n        }\r\n    }\r\n    getInputAmount(target, resourceType) {\r\n        // if (target instanceof DirectivePickup) {\r\n        // \treturn target.storeCapacity - _.sum(target.store);\r\n        // } else\r\n        if (isResource(target) || isTombstone(target)) {\r\n            log.error(`Improper logistics request: should not request input for resource or tombstone!`);\r\n            return 0;\r\n        }\r\n        else if (isStoreStructure(target)) {\r\n            return target.storeCapacity - _.sum(target.store);\r\n        }\r\n        else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {\r\n            return target.energyCapacity - target.energy;\r\n        }\r\n        // else if (target instanceof Zerg) {\r\n        // \treturn target.carryCapacity - _.sum(target.carry);\r\n        // }\r\n        else {\r\n            if (target instanceof StructureLab) {\r\n                if (resourceType == target.mineralType) {\r\n                    return target.mineralCapacity - target.mineralAmount;\r\n                }\r\n                else if (resourceType == RESOURCE_ENERGY) {\r\n                    return target.energyCapacity - target.energy;\r\n                }\r\n            }\r\n            else if (target instanceof StructureNuker) {\r\n                if (resourceType == RESOURCE_GHODIUM) {\r\n                    return target.ghodiumCapacity - target.ghodium;\r\n                }\r\n                else if (resourceType == RESOURCE_ENERGY) {\r\n                    return target.energyCapacity - target.energy;\r\n                }\r\n            }\r\n            else if (target instanceof StructurePowerSpawn) {\r\n                if (resourceType == RESOURCE_POWER) {\r\n                    return target.powerCapacity - target.power;\r\n                }\r\n                else if (resourceType == RESOURCE_ENERGY) {\r\n                    return target.energyCapacity - target.energy;\r\n                }\r\n            }\r\n        }\r\n        log.warning('Could not determine input amount!');\r\n        return 0;\r\n    }\r\n    getOutputAmount(target, resourceType) {\r\n        if (resourceType == 'all') {\r\n            if (isTombstone(target) || isStoreStructure(target)) {\r\n                return _.sum(target.store);\r\n            }\r\n            else {\r\n                log.error(ALL_RESOURCE_TYPE_ERROR);\r\n                return 0;\r\n            }\r\n        }\r\n        else {\r\n            if (isResource(target)) {\r\n                return target.amount;\r\n            }\r\n            else if (isTombstone(target)) {\r\n                return target.store[resourceType] || 0;\r\n            }\r\n            else if (isStoreStructure(target)) {\r\n                return target.store[resourceType] || 0;\r\n            }\r\n            else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {\r\n                return target.energy;\r\n            }\r\n            // else if (target instanceof Zerg) {\r\n            // \treturn target.carry[resourceType]!;\r\n            // }\r\n            else {\r\n                if (target instanceof StructureLab) {\r\n                    if (resourceType == target.mineralType) {\r\n                        return target.mineralAmount;\r\n                    }\r\n                    else if (resourceType == RESOURCE_ENERGY) {\r\n                        return target.energy;\r\n                    }\r\n                }\r\n                else if (target instanceof StructureNuker) {\r\n                    if (resourceType == RESOURCE_GHODIUM) {\r\n                        return target.ghodium;\r\n                    }\r\n                    else if (resourceType == RESOURCE_ENERGY) {\r\n                        return target.energy;\r\n                    }\r\n                }\r\n                else if (target instanceof StructurePowerSpawn) {\r\n                    if (resourceType == RESOURCE_POWER) {\r\n                        return target.power;\r\n                    }\r\n                    else if (resourceType == RESOURCE_ENERGY) {\r\n                        return target.energy;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        log.warning('Could not determine output amount!');\r\n        return 0;\r\n    }\r\n    // Transporter availability and predictive functions ===============================================================\r\n    computeNextAvailability(transporter) {\r\n        if (transporter.task) {\r\n            let approximateDistance = transporter.task.eta;\r\n            let pos = transporter.pos;\r\n            const targetPositions = transporter.task.targetPosManifest;\r\n            // If there is a well-defined task ETA, use that as the first leg, else set dist to zero and use range\r\n            if (approximateDistance) {\r\n                for (const targetPos of targetPositions.slice(1)) {\r\n                    // The path lengths between any two logistics targets should be well-memorized\r\n                    approximateDistance += Math.ceil(pos.getMultiRoomRangeTo(targetPos)\r\n                        * LogisticsNetwork_1.settings.rangeToPathHeuristic);\r\n                    // approximateDistance += Pathing.distance(pos, targetPos);\r\n                    pos = targetPos;\r\n                }\r\n            }\r\n            else {\r\n                // This probably shouldn't happen...\r\n                approximateDistance = 0;\r\n                for (const targetPos of targetPositions) {\r\n                    approximateDistance += Math.ceil(pos.getMultiRoomRangeTo(targetPos)\r\n                        * LogisticsNetwork_1.settings.rangeToPathHeuristic);\r\n                    // approximateDistance += Pathing.distance(pos, targetPos);\r\n                    pos = targetPos;\r\n                }\r\n            }\r\n            return [approximateDistance, pos];\r\n        }\r\n        else {\r\n            // Report the transporter as being near a logistics target so that Pathing.distance() won't waste CPU\r\n            // let nearbyLogisticPositions = transporter.pos.findInRange(this.logisticPositions[transporter.room.name], 2);\r\n            return [0, transporter.pos];\r\n        }\r\n    }\r\n    /**\r\n     * Number of ticks until the transporter is available and where it will be\r\n     */\r\n    nextAvailability(transporter) {\r\n        if (!this.cache.nextAvailability[transporter.name]) {\r\n            this.cache.nextAvailability[transporter.name] = this.computeNextAvailability(transporter);\r\n        }\r\n        return this.cache.nextAvailability[transporter.name];\r\n    }\r\n    static targetingTransporters(target, excludedTransporter) {\r\n        const targetingZerg = _.map(target.targetedBy, name => Overmind.zerg[name]);\r\n        const targetingTransporters = _.filter(targetingZerg, zerg => zerg.roleName == Roles.transport);\r\n        if (excludedTransporter) {\r\n            _.remove(targetingTransporters, transporter => transporter.name == excludedTransporter.name);\r\n        }\r\n        return targetingTransporters;\r\n    }\r\n    /**\r\n     * Returns the predicted state of the transporter's carry after completing its current task\r\n     */\r\n    computePredictedTransporterCarry(transporter, nextAvailability) {\r\n        if (transporter.task && transporter.task.target) {\r\n            const requestID = this.targetToRequest[transporter.task.target.ref];\r\n            if (requestID) {\r\n                const request = this.requests[requestID];\r\n                if (request) {\r\n                    const carry = transporter.carry;\r\n                    const remainingCapacity = transporter.carryCapacity - _.sum(carry);\r\n                    const resourceAmount = -1 * this.predictedRequestAmount(transporter, request, nextAvailability);\r\n                    // ^ need to multiply amount by -1 since transporter is doing complement of what request needs\r\n                    if (request.resourceType == 'all') {\r\n                        if (!isStoreStructure(request.target) && !isTombstone(request.target)) {\r\n                            log.error(ALL_RESOURCE_TYPE_ERROR);\r\n                            return { energy: 0 };\r\n                        }\r\n                        for (const resourceType in request.target.store) {\r\n                            const resourceFraction = (request.target.store[resourceType] || 0)\r\n                                / _.sum(request.target.store);\r\n                            if (carry[resourceType]) {\r\n                                carry[resourceType] += resourceAmount * resourceFraction;\r\n                                carry[resourceType] = minMax(carry[resourceType], 0, remainingCapacity);\r\n                            }\r\n                            else {\r\n                                carry[resourceType] = minMax(resourceAmount, 0, remainingCapacity);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (carry[request.resourceType]) {\r\n                            carry[request.resourceType] += resourceAmount;\r\n                            carry[request.resourceType] = minMax(carry[request.resourceType], 0, remainingCapacity);\r\n                        }\r\n                        else {\r\n                            carry[request.resourceType] = minMax(resourceAmount, 0, remainingCapacity);\r\n                        }\r\n                    }\r\n                    return carry;\r\n                }\r\n            }\r\n        }\r\n        return transporter.carry;\r\n    }\r\n    /**\r\n     * Returns the predicted state of the transporter's carry after completing its task\r\n     */\r\n    predictedTransporterCarry(transporter) {\r\n        if (!this.cache.predictedTransporterCarry[transporter.name]) {\r\n            this.cache.predictedTransporterCarry[transporter.name] = this.computePredictedTransporterCarry(transporter);\r\n        }\r\n        return this.cache.predictedTransporterCarry[transporter.name];\r\n    }\r\n    /**\r\n     * Returns the effective amount that a transporter will see upon arrival, accounting for other targeting creeps\r\n     */\r\n    predictedRequestAmount(transporter, request, nextAvailability) {\r\n        // Figure out when/where the transporter will be free\r\n        let busyUntil;\r\n        let newPos;\r\n        if (!nextAvailability) {\r\n            [busyUntil, newPos] = this.nextAvailability(transporter);\r\n        }\r\n        else {\r\n            [busyUntil, newPos] = nextAvailability;\r\n        }\r\n        // let eta = busyUntil + Pathing.distance(newPos, request.target.pos);\r\n        const eta = busyUntil + LogisticsNetwork_1.settings.rangeToPathHeuristic *\r\n            newPos.getMultiRoomRangeTo(request.target.pos);\r\n        const predictedDifference = request.dAmountdt * eta; // dAmountdt has same sign as amount\r\n        // Account for other transporters targeting the target\r\n        const otherTargetingTransporters = LogisticsNetwork_1.targetingTransporters(request.target, transporter);\r\n        // let closerTargetingTransporters = _.filter(otherTargetingTransporters,\r\n        // \t\t\t\t\t\t\t\t\t\t   transporter => this.nextAvailability(transporter)[0] < eta);\r\n        if (request.amount > 0) { // input state, resources into target\r\n            let predictedAmount = request.amount + predictedDifference;\r\n            if (isStoreStructure(request.target)) { // cap predicted amount at storeCapacity\r\n                predictedAmount = Math.min(predictedAmount, request.target.storeCapacity);\r\n            }\r\n            else if (isEnergyStructure(request.target)) {\r\n                predictedAmount = Math.min(predictedAmount, request.target.energyCapacity);\r\n            }\r\n            const resourceInflux = _.sum(_.map(otherTargetingTransporters, other => (other.carry[request.resourceType] || 0)));\r\n            predictedAmount = Math.max(predictedAmount - resourceInflux, 0);\r\n            return predictedAmount;\r\n        }\r\n        else { // output state, resources withdrawn from target\r\n            let predictedAmount = request.amount + predictedDifference;\r\n            if (isStoreStructure(request.target)) { // cap predicted amount at -1 * storeCapacity\r\n                predictedAmount = Math.max(predictedAmount, -1 * request.target.storeCapacity);\r\n            }\r\n            else if (isEnergyStructure(request.target)) {\r\n                predictedAmount = Math.min(predictedAmount, -1 * request.target.energyCapacity);\r\n            }\r\n            const resourceOutflux = _.sum(_.map(otherTargetingTransporters, other => other.carryCapacity - _.sum(other.carry)));\r\n            predictedAmount = Math.min(predictedAmount + resourceOutflux, 0);\r\n            return predictedAmount;\r\n        }\r\n    }\r\n    // Functions for computing resource change rate ====================================================================\r\n    /**\r\n     * Consider all possibilities of buffer structures to visit on the way to fulfilling the request\r\n     */\r\n    bufferChoices(transporter, request) {\r\n        const [ticksUntilFree, newPos] = this.nextAvailability(transporter);\r\n        const choices = [];\r\n        const amount = this.predictedRequestAmount(transporter, request, [ticksUntilFree, newPos]);\r\n        let carry;\r\n        if (!transporter.task || transporter.task.target != request.target) {\r\n            // If you are not targeting the requestor, use predicted carry after completing current task\r\n            carry = this.predictedTransporterCarry(transporter);\r\n        }\r\n        else {\r\n            // If you are targeting the requestor, use current carry for computations\r\n            carry = transporter.carry;\r\n        }\r\n        if (amount > 0) { // requestInput instance, needs refilling\r\n            if (request.resourceType == 'all') {\r\n                log.warning(`Improper resourceType in bufferChoices! Type 'all' is only allowable for outputs!`);\r\n                return [];\r\n            }\r\n            // Change in resources if transporter goes straight to the input\r\n            const dQ_direct = Math.min(amount, carry[request.resourceType] || 0);\r\n            // let dt_direct = Pathing.distance(newPos, request.target.pos) + ticksUntilFree;\r\n            const dt_direct = ticksUntilFree + newPos.getMultiRoomRangeTo(request.target.pos)\r\n                * LogisticsNetwork_1.settings.rangeToPathHeuristic;\r\n            choices.push({\r\n                dQ: dQ_direct,\r\n                dt: dt_direct,\r\n                targetRef: request.target.ref\r\n            });\r\n            if ((carry[request.resourceType] || 0) > amount || _.sum(carry) == transporter.carryCapacity) {\r\n                return choices; // Return early if you already have enough resources to go direct or are already full\r\n            }\r\n            // Change in resources if transporter picks up resources from a buffer first\r\n            for (const buffer of this.buffers) {\r\n                const dQ_buffer = Math.min(amount, transporter.carryCapacity, buffer.store[request.resourceType] || 0);\r\n                const dt_buffer = newPos.getMultiRoomRangeTo(buffer.pos) * LogisticsNetwork_1.settings.rangeToPathHeuristic\r\n                    + Pathing.distance(buffer.pos, request.target.pos) + ticksUntilFree;\r\n                choices.push({\r\n                    dQ: dQ_buffer,\r\n                    dt: dt_buffer,\r\n                    targetRef: buffer.ref\r\n                });\r\n            }\r\n        }\r\n        else if (amount < 0) { // requestOutput instance, needs pickup\r\n            // Change in resources if transporter goes straight to the output\r\n            const remainingCarryCapacity = transporter.carryCapacity - _.sum(carry);\r\n            const dQ_direct = Math.min(Math.abs(amount), remainingCarryCapacity);\r\n            const dt_direct = newPos.getMultiRoomRangeTo(request.target.pos)\r\n                * LogisticsNetwork_1.settings.rangeToPathHeuristic + ticksUntilFree;\r\n            choices.push({\r\n                dQ: dQ_direct,\r\n                dt: dt_direct,\r\n                targetRef: request.target.ref\r\n            });\r\n            if (remainingCarryCapacity >= Math.abs(amount) || remainingCarryCapacity == transporter.carryCapacity) {\r\n                return choices; // Return early you have sufficient free space or are empty\r\n            }\r\n            // Change in resources if transporter drops off resources at a buffer first\r\n            for (const buffer of this.buffers) {\r\n                const dQ_buffer = Math.min(Math.abs(amount), transporter.carryCapacity, buffer.storeCapacity - _.sum(buffer.store));\r\n                const dt_buffer = newPos.getMultiRoomRangeTo(buffer.pos) * LogisticsNetwork_1.settings.rangeToPathHeuristic\r\n                    + Pathing.distance(buffer.pos, request.target.pos) + ticksUntilFree;\r\n                choices.push({\r\n                    dQ: dQ_buffer,\r\n                    dt: dt_buffer,\r\n                    targetRef: buffer.ref\r\n                });\r\n            }\r\n            // if (store.resourceType == RESOURCE_ENERGY) {\r\n            // \t// Only for when you're picking up more energy: check to see if you can put to available links\r\n            // \tfor (let link of this.colony.dropoffLinks) {\r\n            // \t\tlet linkDeltaResource = Math.min(Math.abs(amount), transporter.carryCapacity,\r\n            // \t\t\t2 * link.energyCapacity);\r\n            // \t\tlet ticksUntilDropoff = Math.max(Pathing.distance(newPos, link.pos),\r\n            // \t\t\t\t\t\t\t\t\t\t this.colony.linkNetwork.getDropoffAvailability(link));\r\n            // \t\tlet linkDistance = ticksUntilDropoff +\r\n            // \t\t\t\t\t\t   Pathing.distance(link.pos, store.target.pos) + ticksUntilFree;\r\n            // \t\tchoices.push({\r\n            // \t\t\t\t\t\t deltaResource: linkDeltaResource,\r\n            // \t\t\t\t\t\t deltaTicks   : linkDistance,\r\n            // \t\t\t\t\t\t targetRef    : link.ref\r\n            // \t\t\t\t\t });\r\n            // \t}\r\n            // }\r\n        }\r\n        return choices;\r\n    }\r\n    /**\r\n     * Compute the best possible value of |dResource / dt|\r\n     */\r\n    resourceChangeRate(transporter, request) {\r\n        if (!this.cache.resourceChangeRate[request.id]) {\r\n            this.cache.resourceChangeRate[request.id] = {};\r\n        }\r\n        if (!this.cache.resourceChangeRate[request.id][transporter.name]) {\r\n            const choices = this.bufferChoices(transporter, request);\r\n            const dQ_dt = _.map(choices, choice => request.multiplier * choice.dQ / Math.max(choice.dt, 0.1));\r\n            this.cache.resourceChangeRate[request.id][transporter.name] = _.max(dQ_dt);\r\n        }\r\n        return this.cache.resourceChangeRate[request.id][transporter.name];\r\n    }\r\n    /**\r\n     * Generate requestor preferences in terms of transporters\r\n     */\r\n    requestPreferences(request, transporters) {\r\n        // Requestors priortize transporters by change in resources per tick until pickup/delivery\r\n        return _.sortBy(transporters, transporter => -1 * this.resourceChangeRate(transporter, request)); // -1 -> desc\r\n    }\r\n    /**\r\n     * Generate transporter preferences in terms of store structures\r\n     */\r\n    transporterPreferences(transporter) {\r\n        // Transporters prioritize requestors by change in resources per tick until pickup/delivery\r\n        return _.sortBy(this.requests, request => -1 * this.resourceChangeRate(transporter, request)); // -1 -> desc\r\n    }\r\n    /**\r\n     * Invalidates relevant portions of the cache once a transporter is assigned to a task\r\n     */\r\n    invalidateCache(transporter, request) {\r\n        delete this.cache.nextAvailability[transporter.name];\r\n        delete this.cache.predictedTransporterCarry[transporter.name];\r\n        delete this.cache.resourceChangeRate[request.id][transporter.name];\r\n    }\r\n    /**\r\n     * Logs the output of the stable matching result\r\n     */\r\n    summarizeMatching() {\r\n        const requests = this.requests.slice();\r\n        const transporters = _.filter(this.colony.getCreepsByRole(Roles.transport), creep => !creep.spawning);\r\n        const unmatchedTransporters = _.remove(transporters, transporter => !_.keys(this._matching).includes(transporter.name));\r\n        const unmatchedRequests = _.remove(requests, request => !_.values(this._matching).includes(request));\r\n        console.log(`Stable matching for ${this.colony.name} at ${Game.time}`);\r\n        for (const transporter of transporters) {\r\n            const transporterStr = transporter.name + ' ' + transporter.pos;\r\n            const request = this._matching[transporter.name];\r\n            const requestStr = request.target.ref + ' ' + request.target.pos.print;\r\n            console.log(`${transporterStr.padRight(30)} : ${requestStr}`);\r\n        }\r\n        for (const transporter of unmatchedTransporters) {\r\n            const transporterStr = transporter.name + ' ' + transporter.pos;\r\n            console.log(`${transporterStr.padRight(30)} : ${''}`);\r\n        }\r\n        for (const request of unmatchedRequests) {\r\n            const requestStr = request.target.ref + ' ' + request.target.pos;\r\n            console.log(`${''.padRight(30)} : ${requestStr}`);\r\n        }\r\n        console.log();\r\n    }\r\n    /**\r\n     * Logs the current state of the logistics group to the console; useful for debugging\r\n     */\r\n    summarize() {\r\n        // console.log(`Summary of logistics group for ${this.colony.name} at time ${Game.time}`);\r\n        let info = [];\r\n        for (const request of this.requests) {\r\n            let targetType;\r\n            if (request.target instanceof Resource) {\r\n                targetType = 'resource';\r\n            }\r\n            else if (request.target instanceof Tombstone) {\r\n                targetType = 'tombstone';\r\n            }\r\n            else {\r\n                targetType = request.target.structureType;\r\n            }\r\n            let amount = 0;\r\n            if (isResource(request.target)) {\r\n                amount = request.target.amount;\r\n            }\r\n            else {\r\n                if (request.resourceType == 'all') {\r\n                    if (isTombstone(request.target) || isStoreStructure(request.target)) {\r\n                        amount = _.sum(request.target.store);\r\n                    }\r\n                    else if (isEnergyStructure(request.target)) {\r\n                        amount = -0.001;\r\n                    }\r\n                }\r\n                else {\r\n                    if (isTombstone(request.target) || isStoreStructure(request.target)) {\r\n                        amount = request.target.store[request.resourceType] || 0;\r\n                    }\r\n                    else if (isEnergyStructure(request.target)) {\r\n                        amount = request.target.energy;\r\n                    }\r\n                }\r\n            }\r\n            const targetingTprtrNames = _.map(LogisticsNetwork_1.targetingTransporters(request.target), c => c.name);\r\n            info.push({\r\n                target: targetType,\r\n                resourceType: request.resourceType,\r\n                requestAmount: request.amount,\r\n                currentAmount: amount,\r\n                targetedBy: targetingTprtrNames,\r\n                pos: request.target.pos.print,\r\n            });\r\n        }\r\n        console.log('Requests: \\n' + columnify(info) + '\\n');\r\n        info = [];\r\n        for (const transporter of this.colony.overlords.logistics.transporters) {\r\n            const task = transporter.task ? transporter.task.name : 'none';\r\n            const target = transporter.task ?\r\n                transporter.task.proto._target.ref + ' ' + transporter.task.targetPos.printPlain : 'none';\r\n            const nextAvailability = this.nextAvailability(transporter);\r\n            info.push({\r\n                creep: transporter.name,\r\n                pos: transporter.pos.printPlain,\r\n                task: task,\r\n                target: target,\r\n                availability: `available in ${nextAvailability[0]} ticks at ${nextAvailability[1].print}`,\r\n            });\r\n        }\r\n        console.log('Transporters: \\n' + columnify(info) + '\\n');\r\n    }\r\n    get matching() {\r\n        if (!this._matching) {\r\n            this._matching = this.stableMatching(this.colony.overlords.logistics.transporters);\r\n        }\r\n        return this._matching;\r\n    }\r\n    /**\r\n     * Generate a stable matching of transporters to requests with Gale-Shapley algorithm\r\n     */\r\n    stableMatching(transporters) {\r\n        const tPrefs = {};\r\n        for (const transporter of transporters) {\r\n            tPrefs[transporter.name] = _.map(this.transporterPreferences(transporter), request => request.id);\r\n        }\r\n        const rPrefs = {};\r\n        for (const request of this.requests) {\r\n            rPrefs[request.id] = _.map(this.requestPreferences(request, transporters), transporter => transporter.name);\r\n        }\r\n        const stableMatching = new Matcher(tPrefs, rPrefs).match();\r\n        const requestMatch = _.mapValues(stableMatching, reqID => _.find(this.requests, request => request.id == reqID));\r\n        return requestMatch;\r\n    }\r\n};\r\nLogisticsNetwork.settings = {\r\n    flagDropAmount: 1000,\r\n    rangeToPathHeuristic: 1.1,\r\n    carryThreshold: 800,\r\n    droppedEnergyThreshold: 200,\r\n};\r\nLogisticsNetwork = LogisticsNetwork_1 = tslib_1.__decorate([\r\n    profile\r\n], LogisticsNetwork);\r\nexport { LogisticsNetwork };\r\n","references":["C:/git/Screeps-Revamped/node_modules/columnify/columnify.js","C:/git/Screeps-Revamped/src/algorithms/galeShapley.ts","C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/creepSetups/setups.ts","C:/git/Screeps-Revamped/src/declarations/typeGuards.ts","C:/git/Screeps-Revamped/src/memory/Memory.ts","C:/git/Screeps-Revamped/src/movement/Pathing.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts","C:/git/Screeps-Revamped/src/zerg/Zerg.ts"]}
