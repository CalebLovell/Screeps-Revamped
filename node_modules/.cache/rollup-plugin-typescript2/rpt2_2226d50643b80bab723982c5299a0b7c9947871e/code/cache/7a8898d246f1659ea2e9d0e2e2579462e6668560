{"code":"import * as tslib_1 from \"tslib\";\r\nvar TraderJoe_1;\r\nimport { assimilationLocked } from '../assimilation/decorator';\r\nimport { log } from '../console/log';\r\nimport { Mem } from '../memory/Memory';\r\nimport { profile } from '../profiler/decorator';\r\nimport { alignedNewline, bullet, leftArrow, rightArrow } from '../utilities/stringConstants';\r\nimport { maxBy, minBy, onPublicServer, printRoomName } from '../utilities/utils';\r\nconst TraderMemoryDefaults = {\r\n    cache: {\r\n        sell: {},\r\n        buy: {},\r\n        tick: 0,\r\n    },\r\n    equalizeIndex: 0\r\n};\r\nconst TraderStatsDefaults = {\r\n    credits: 0,\r\n    bought: {},\r\n    sold: {},\r\n};\r\n// Maximum prices I'm willing to pay to buy various resources - based on shard2 market data in June 2018\r\n// (might not always be up to date)\r\nexport const maxMarketPrices = {\r\n    default: 5.0,\r\n    [RESOURCE_HYDROGEN]: 0.3,\r\n    [RESOURCE_OXYGEN]: 0.25,\r\n    [RESOURCE_UTRIUM]: 0.3,\r\n    [RESOURCE_LEMERGIUM]: 0.25,\r\n    [RESOURCE_KEANIUM]: 0.25,\r\n    [RESOURCE_ZYNTHIUM]: 0.25,\r\n    [RESOURCE_CATALYST]: 0.5,\r\n    [RESOURCE_ENERGY]: 0.05,\r\n};\r\nexport const MAX_ENERGY_SELL_ORDERS = 5;\r\nexport const MAX_ENERGY_BUY_ORDERS = 5;\r\n/**\r\n * The trade network controls resource acquisition and disposal on the player market.\r\n */\r\nlet TraderJoe = TraderJoe_1 = class TraderJoe {\r\n    constructor() {\r\n        this.memory = Mem.wrap(Memory.Overmind, 'trader', TraderMemoryDefaults, true);\r\n        this.stats = Mem.wrap(Memory.stats.persistent, 'trader', TraderStatsDefaults);\r\n        this.notifications = [];\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(Memory.Overmind, 'trader', TraderMemoryDefaults, true);\r\n        this.stats = Mem.wrap(Memory.stats.persistent, 'trader', TraderStatsDefaults);\r\n        this.notifications = [];\r\n    }\r\n    notify(msg) {\r\n        this.notifications.push(bullet + msg);\r\n    }\r\n    /**\r\n     * Builds a cache for market - this is very expensive; use infrequently\r\n     */\r\n    buildMarketCache(verbose = false, orderThreshold = 1000) {\r\n        this.invalidateMarketCache();\r\n        const myActiveOrderIDs = _.map(_.filter(Game.market.orders, order => order.active), order => order.id);\r\n        const allOrders = Game.market.getAllOrders(order => !myActiveOrderIDs.includes(order.id) &&\r\n            order.amount >= orderThreshold); // don't include tiny orders\r\n        const groupedBuyOrders = _.groupBy(_.filter(allOrders, o => o.type == ORDER_BUY), o => o.resourceType);\r\n        const groupedSellOrders = _.groupBy(_.filter(allOrders, o => o.type == ORDER_SELL), o => o.resourceType);\r\n        for (const resourceType in groupedBuyOrders) {\r\n            // Store buy order with maximum price in cache\r\n            const prices = _.map(groupedBuyOrders[resourceType], o => o.price);\r\n            const high = _.max(prices);\r\n            const low = _.min(prices);\r\n            if (verbose)\r\n                console.log(`${resourceType} BUY: high: ${high}  low: ${low}`);\r\n            // this.memory.cache.buy[resourceType] = minBy(groupedBuyOrders[resourceType], (o:Order) => -1 * o.price);\r\n            this.memory.cache.buy[resourceType] = { high: high, low: low };\r\n        }\r\n        for (const resourceType in groupedSellOrders) {\r\n            // Store sell order with minimum price in cache\r\n            const prices = _.map(groupedSellOrders[resourceType], o => o.price);\r\n            const high = _.max(prices);\r\n            const low = _.min(prices);\r\n            if (verbose)\r\n                console.log(`${resourceType} SELL: high: ${high}  low: ${low}`);\r\n            // this.memory.cache.sell[resourceType] = minBy(groupedSellOrders[resourceType], (o:Order) => o.price);\r\n            this.memory.cache.sell[resourceType] = { high: high, low: low };\r\n        }\r\n        this.memory.cache.tick = Game.time;\r\n    }\r\n    invalidateMarketCache() {\r\n        this.memory.cache = {\r\n            sell: {},\r\n            buy: {},\r\n            tick: 0,\r\n        };\r\n    }\r\n    /**\r\n     * Cost per unit including transfer price with energy converted to credits\r\n     */\r\n    effectivePrice(order, terminal) {\r\n        if (order.roomName) {\r\n            const transferCost = Game.market.calcTransactionCost(1000, order.roomName, terminal.room.name) / 1000;\r\n            const energyToCreditMultiplier = 0.01; // this.cache.sell[RESOURCE_ENERGY] * 1.5;\r\n            return order.price + transferCost * energyToCreditMultiplier;\r\n        }\r\n        else {\r\n            return Infinity;\r\n        }\r\n    }\r\n    /**\r\n     * Cost per unit for a buy order including transfer price with energy converted to credits\r\n     */\r\n    effectiveBuyPrice(order, terminal) {\r\n        if (order.roomName) {\r\n            const transferCost = Game.market.calcTransactionCost(1000, order.roomName, terminal.room.name) / 1000;\r\n            const energyToCreditMultiplier = 0.01; // this.cache.sell[RESOURCE_ENERGY] * 1.5;\r\n            return order.price - transferCost * energyToCreditMultiplier;\r\n        }\r\n        else {\r\n            return Infinity;\r\n        }\r\n    }\r\n    // private getBestOrder(mineralType: ResourceConstant, type: 'buy' | 'sell'): Order | undefined {\r\n    // \tlet cachedOrder = this.memory.cache[type][mineralType];\r\n    // \tif (cachedOrder) {\r\n    // \t\tlet order = Game.market.getOrderById(cachedOrder.id);\r\n    // \t\tif (order) {\r\n    // \t\t\t// Update the order in memory\r\n    // \t\t\tthis.memory.cache[type][mineralType] = order;\r\n    // \t\t}\r\n    // \t}\r\n    // }\r\n    cleanUpInactiveOrders() {\r\n        // Clean up sell orders that have expired or orders belonging to rooms no longer owned\r\n        const ordersToClean = _.filter(Game.market.orders, o => (o.type == ORDER_SELL && o.active == false && o.remainingAmount == 0) // if order is expired, or\r\n            || (Game.time - o.created > TraderJoe_1.settings.market.orders.timeout // order is old and almost done\r\n                && o.remainingAmount < TraderJoe_1.settings.market.orders.cleanupAmount)\r\n            || (o.roomName && !Overmind.colonies[o.roomName])); // order placed from dead colony\r\n        for (const order of ordersToClean) {\r\n            Game.market.cancelOrder(order.id);\r\n        }\r\n    }\r\n    /**\r\n     * Opportunistically sells resources when the buy price is higher than current market sell low price\r\n     */\r\n    lookForGoodDeals(terminal, resource, margin = 1.25) {\r\n        if (Game.market.credits < TraderJoe_1.settings.market.reserveCredits) {\r\n            return;\r\n        }\r\n        let amount = 5000;\r\n        if (resource === RESOURCE_POWER) {\r\n            amount = 100;\r\n        }\r\n        let ordersForMineral = Game.market.getAllOrders({ resourceType: resource, type: ORDER_BUY });\r\n        ordersForMineral = _.filter(ordersForMineral, order => order.amount >= amount);\r\n        if (ordersForMineral === undefined) {\r\n            return;\r\n        }\r\n        const marketLow = this.memory.cache.sell[resource] ? this.memory.cache.sell[resource].low : undefined;\r\n        if (marketLow == undefined) {\r\n            return;\r\n        }\r\n        const order = maxBy(ordersForMineral, order => this.effectiveBuyPrice(order, terminal));\r\n        if (order && order.price > marketLow * margin) {\r\n            const amount = Math.min(order.amount, 10000);\r\n            const cost = Game.market.calcTransactionCost(amount, terminal.room.name, order.roomName);\r\n            if (terminal.store[RESOURCE_ENERGY] > cost) {\r\n                const response = Game.market.deal(order.id, amount, terminal.room.name);\r\n                this.logTransaction(order, terminal.room.name, amount, response);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Buy a resource on the market\r\n     */\r\n    buy(terminal, resource, amount) {\r\n        if (Game.market.credits < TraderJoe_1.settings.market.reserveCredits || terminal.cooldown > 0) {\r\n            return;\r\n        }\r\n        amount = Math.max(amount, TERMINAL_MIN_SEND);\r\n        if (terminal.store[RESOURCE_ENERGY] < 10000 || terminal.storeCapacity - _.sum(terminal.store) < amount) {\r\n            return;\r\n        }\r\n        let ordersForMineral = Game.market.getAllOrders({ resourceType: resource, type: ORDER_SELL });\r\n        ordersForMineral = _.filter(ordersForMineral, order => order.amount >= amount);\r\n        const bestOrder = minBy(ordersForMineral, (order) => order.price);\r\n        let maxPrice = maxMarketPrices[resource] || maxMarketPrices.default;\r\n        if (!onPublicServer()) {\r\n            maxPrice = Infinity; // don't care about price limits if on private server\r\n        }\r\n        if (bestOrder && bestOrder.price <= maxPrice) {\r\n            const response = Game.market.deal(bestOrder.id, amount, terminal.room.name);\r\n            this.logTransaction(bestOrder, terminal.room.name, amount, response);\r\n        }\r\n    }\r\n    /**\r\n     * Sell a resource on the market, either through a sell order or directly\r\n     */\r\n    sell(terminal, resource, amount, maxOrdersOfType = Infinity) {\r\n        if (Game.market.credits < TraderJoe_1.settings.market.reserveCredits) {\r\n            return this.sellDirectly(terminal, resource, amount);\r\n        }\r\n        else {\r\n            this.maintainSellOrder(terminal, resource, amount, maxOrdersOfType);\r\n        }\r\n    }\r\n    /**\r\n     * Sell resources directly to a buyer rather than making a sell order\r\n     */\r\n    sellDirectly(terminal, resource, amount, flexibleAmount = true) {\r\n        // If flexibleAmount is allowed, consider selling to orders which don't need the full amount\r\n        const minAmount = flexibleAmount ? TERMINAL_MIN_SEND : amount;\r\n        let ordersForMineral = Game.market.getAllOrders({ resourceType: resource, type: ORDER_BUY });\r\n        ordersForMineral = _.filter(ordersForMineral, order => order.amount >= minAmount);\r\n        const order = maxBy(ordersForMineral, order => this.effectiveBuyPrice(order, terminal));\r\n        if (order) {\r\n            const sellAmount = Math.min(order.amount, amount);\r\n            const cost = Game.market.calcTransactionCost(sellAmount, terminal.room.name, order.roomName);\r\n            if (terminal.store[RESOURCE_ENERGY] > cost) {\r\n                const response = Game.market.deal(order.id, sellAmount, terminal.room.name);\r\n                this.logTransaction(order, terminal.room.name, amount, response);\r\n                return response;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Create or maintain a buy order\r\n     */\r\n    maintainBuyOrder(terminal, resource, amount, maxOrdersOfType = Infinity) {\r\n        const marketHigh = this.memory.cache.buy[resource] ? this.memory.cache.buy[resource].high : undefined;\r\n        if (!marketHigh) {\r\n            return;\r\n        }\r\n        const maxPrice = maxMarketPrices[resource] || maxMarketPrices.default;\r\n        if (marketHigh > maxPrice) {\r\n            return;\r\n        }\r\n        const order = _.find(Game.market.orders, o => o.type == ORDER_BUY &&\r\n            o.resourceType == resource &&\r\n            o.roomName == terminal.room.name);\r\n        if (order) {\r\n            if (order.price < marketHigh || (order.price > marketHigh && order.remainingAmount == 0)) {\r\n                const ret = Game.market.changeOrderPrice(order.id, marketHigh);\r\n                this.notify(`${terminal.room.print}: updating buy order price for ${resource} from ` +\r\n                    `${order.price} to ${marketHigh}. Response: ${ret}`);\r\n            }\r\n            if (order.remainingAmount < 2000) {\r\n                const addAmount = (amount - order.remainingAmount);\r\n                const ret = Game.market.extendOrder(order.id, addAmount);\r\n                this.notify(`${terminal.room.print}: extending buy order for ${resource} by ${addAmount}.` +\r\n                    ` Response: ${ret}`);\r\n            }\r\n        }\r\n        else {\r\n            const ordersOfType = _.filter(Game.market.orders, o => o.type == ORDER_BUY && o.resourceType == resource);\r\n            if (ordersOfType.length < maxOrdersOfType) {\r\n                const ret = Game.market.createOrder(ORDER_BUY, resource, marketHigh, amount, terminal.room.name);\r\n                this.notify(`${terminal.room.print}: creating buy order for ${resource} at price ${marketHigh}. ` +\r\n                    `Response: ${ret}`);\r\n            }\r\n            // else {\r\n            // \tthis.notify(`${terminal.room.print}: cannot create another buy order for ${resource}:` +\r\n            // \t\t\t\t` too many (${ordersOfType.length})`);\r\n            // }\r\n        }\r\n    }\r\n    /**\r\n     * Create or maintain a sell order\r\n     */\r\n    maintainSellOrder(terminal, resource, amount, maxOrdersOfType = Infinity) {\r\n        const marketLow = this.memory.cache.sell[resource] ? this.memory.cache.sell[resource].low : undefined;\r\n        if (!marketLow) {\r\n            return;\r\n        }\r\n        const order = _.find(Game.market.orders, o => o.type == ORDER_SELL &&\r\n            o.resourceType == resource &&\r\n            o.roomName == terminal.room.name);\r\n        if (order) {\r\n            if (order.price > marketLow || (order.price < marketLow && order.remainingAmount == 0)) {\r\n                const ret = Game.market.changeOrderPrice(order.id, marketLow);\r\n                this.notify(`${terminal.room.print}: updating sell order price for ${resource} from ` +\r\n                    `${order.price} to ${marketLow}. Response: ${ret}`);\r\n            }\r\n            if (order.remainingAmount < 2000) {\r\n                const addAmount = (amount - order.remainingAmount);\r\n                const ret = Game.market.extendOrder(order.id, addAmount);\r\n                this.notify(`${terminal.room.print}: extending sell order for ${resource} by ${addAmount}.` +\r\n                    ` Response: ${ret}`);\r\n            }\r\n        }\r\n        else {\r\n            const ordersOfType = _.filter(Game.market.orders, o => o.type == ORDER_SELL && o.resourceType == resource);\r\n            if (ordersOfType.length < maxOrdersOfType) {\r\n                const ret = Game.market.createOrder(ORDER_SELL, resource, marketLow, amount, terminal.room.name);\r\n                this.notify(`${terminal.room.print}: creating sell order for ${resource} at price ${marketLow}. ` +\r\n                    `Response: ${ret}`);\r\n            }\r\n            // else {\r\n            // \tthis.notify(`${terminal.room.print}: cannot create another sell order for ${resource}:` +\r\n            // \t\t\t\t` too many (${ordersOfType.length})`);\r\n            // }\r\n        }\r\n    }\r\n    priceOf(mineralType) {\r\n        if (this.memory.cache.sell[mineralType]) {\r\n            return this.memory.cache.sell[mineralType].low;\r\n        }\r\n        else {\r\n            return Infinity;\r\n        }\r\n    }\r\n    /**\r\n     * Pretty-prints transaction information in the console\r\n     */\r\n    logTransaction(order, terminalRoomName, amount, response) {\r\n        const action = order.type == ORDER_SELL ? 'BOUGHT ' : 'SOLD   ';\r\n        const cost = (order.price * amount).toFixed(2);\r\n        const fee = order.roomName ? Game.market.calcTransactionCost(amount, order.roomName, terminalRoomName) : 0;\r\n        const roomName = Game.rooms[terminalRoomName] ? Game.rooms[terminalRoomName].print : terminalRoomName;\r\n        let msg;\r\n        if (order.type == ORDER_SELL) {\r\n            msg = `${roomName} ${leftArrow} ${amount} ${order.resourceType} ${leftArrow} ` +\r\n                `${printRoomName(order.roomName)} (result: ${response})`;\r\n        }\r\n        else {\r\n            msg = `${roomName} ${rightArrow} ${amount} ${order.resourceType} ${rightArrow} ` +\r\n                `${printRoomName(order.roomName)} (result: ${response})`;\r\n        }\r\n        this.notify(msg);\r\n    }\r\n    /**\r\n     * Look through transactions happening on the previous tick and record stats\r\n     */\r\n    recordStats() {\r\n        this.stats.credits = Game.market.credits;\r\n        const time = Game.time - 1;\r\n        // Incoming transactions\r\n        for (const transaction of Game.market.incomingTransactions) {\r\n            if (transaction.time < time) {\r\n                break; // only look at things from last tick\r\n            }\r\n            else {\r\n                if (transaction.order) {\r\n                    const resourceType = transaction.resourceType;\r\n                    const amount = transaction.amount;\r\n                    const price = transaction.order.price;\r\n                    if (!this.stats.bought[resourceType]) {\r\n                        this.stats.bought[resourceType] = { amount: 0, credits: 0 };\r\n                    }\r\n                    this.stats.bought[resourceType].amount += amount;\r\n                    this.stats.bought[resourceType].credits += amount * price;\r\n                }\r\n            }\r\n        }\r\n        // Outgoing transactions\r\n        for (const transaction of Game.market.outgoingTransactions) {\r\n            if (transaction.time < time) {\r\n                break; // only look at things from last tick\r\n            }\r\n            else {\r\n                if (transaction.order) {\r\n                    const resourceType = transaction.resourceType;\r\n                    const amount = transaction.amount;\r\n                    const price = transaction.order.price;\r\n                    if (!this.stats.sold[resourceType]) {\r\n                        this.stats.sold[resourceType] = { amount: 0, credits: 0 };\r\n                    }\r\n                    this.stats.sold[resourceType].amount += amount;\r\n                    this.stats.sold[resourceType].credits += amount * price;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    init() {\r\n        if (Game.time - (this.memory.cache.tick || 0) > TraderJoe_1.settings.cache.timeout) {\r\n            this.buildMarketCache();\r\n        }\r\n    }\r\n    run() {\r\n        if (Game.time % 10 == 0) {\r\n            this.cleanUpInactiveOrders();\r\n        }\r\n        if (this.notifications.length > 0) {\r\n            log.info(`Trade network activity: ` + alignedNewline + this.notifications.join(alignedNewline));\r\n        }\r\n        this.recordStats();\r\n    }\r\n};\r\nTraderJoe.settings = {\r\n    cache: {\r\n        timeout: 25,\r\n    },\r\n    market: {\r\n        reserveCredits: 10000,\r\n        boostCredits: 25000,\r\n        energyCredits: 50000,\r\n        orders: {\r\n            timeout: 100000,\r\n            cleanupAmount: 10,\r\n        }\r\n    },\r\n};\r\nTraderJoe = TraderJoe_1 = tslib_1.__decorate([\r\n    profile,\r\n    assimilationLocked\r\n], TraderJoe);\r\nexport { TraderJoe };\r\n","references":["C:/git/Screeps-Revamped/src/assimilation/decorator.ts","C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/memory/Memory.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/utilities/stringConstants.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts"]}
