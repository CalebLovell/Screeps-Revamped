{"code":"import * as tslib_1 from \"tslib\";\r\nimport { $ } from '../../caching/GlobalCache';\r\nimport { log } from '../../console/log';\r\nimport { CombatSetups, Roles } from '../../creepSetups/setups';\r\nimport { CombatIntel } from '../../intel/CombatIntel';\r\nimport { RoomIntel } from '../../intel/RoomIntel';\r\nimport { Mem } from '../../memory/Memory';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { boostResources } from '../../resources/map_resources';\r\nimport { Visualizer } from '../../visuals/Visualizer';\r\nimport { Swarm } from '../../zerg/Swarm';\r\nimport { SwarmOverlord } from '../SwarmOverlord';\r\nconst DEBUG = false;\r\n/**\r\n * Spawns squads of attackers and healers to siege a hostile room, moving with swarm logic in a coordinated fashion\r\n */\r\nlet SwarmDestroyerOverlord = class SwarmDestroyerOverlord extends SwarmOverlord {\r\n    constructor(directive, priority = OverlordPriority.offense.destroy) {\r\n        super(directive, 'destroy', priority, 8);\r\n        this.directive = directive;\r\n        this.memory = Mem.wrap(this.directive.memory, this.name);\r\n        this.intel = new CombatIntel(this.directive);\r\n        this.zerglings = this.combatZerg(Roles.melee, {\r\n            notifyWhenAttacked: false,\r\n            boostWishlist: [boostResources.attack[3], boostResources.tough[3], boostResources.move[3]]\r\n        });\r\n        // this.hydralisks = this.combatZerg(Roles.ranged, {\r\n        // \tnotifyWhenAttacked: false,\r\n        // \tboostWishlist     : [boostResources.ranged_attack[3], boostResources.tough[3], boostResources.move[3]]\r\n        // });\r\n        this.healers = this.combatZerg(Roles.healer, {\r\n            notifyWhenAttacked: false,\r\n            boostWishlist: [boostResources.heal[3], boostResources.tough[3], boostResources.move[3],]\r\n        });\r\n        // Make swarms\r\n        this.makeSwarms();\r\n        // Compute fallback positions and assembly points\r\n        this.fallback = $.pos(this, 'fallback', () => this.intel.findSwarmAssemblyPointInColony({ width: 2, height: 2 }), 200);\r\n        this.assemblyPoints = [];\r\n        for (let i = 0; i < _.keys(this.swarms).length + 1; i++) {\r\n            this.assemblyPoints.push($.pos(this, `assemble_${i}`, () => this.intel.findSwarmAssemblyPointInColony({ width: 2, height: 2 }, i + 1), 200));\r\n        }\r\n    }\r\n    refresh() {\r\n        super.refresh();\r\n        this.memory = Mem.wrap(this.directive.memory, this.name);\r\n        this.makeSwarms();\r\n    }\r\n    makeSwarms() {\r\n        this.swarms = {};\r\n        const meleeZerg = [...this.zerglings, ...this.healers];\r\n        // let rangedZerg: CombatZerg[] = this.hydralisks;\r\n        const maxPerSwarm = { [Roles.melee]: 2, [Roles.healer]: 2, [Roles.ranged]: 4 };\r\n        const meleeZergBySwarm = _.groupBy(meleeZerg, zerg => zerg.findSwarm(meleeZerg, maxPerSwarm));\r\n        // let rangedZergBySwarm = _.groupBy(rangedZerg, zerg => zerg.findSwarm(rangedZerg, maxPerSwarm));\r\n        // let zergBySwarm = _.merge(meleeZergBySwarm, rangedZergBySwarm);\r\n        for (const ref in meleeZergBySwarm) {\r\n            if (ref != undefined) {\r\n                if (DEBUG)\r\n                    log.debug(`Making swarm for ${_.map(meleeZergBySwarm[ref], z => z.name)}`);\r\n                this.swarms[ref] = new Swarm(this, ref, meleeZergBySwarm[ref]);\r\n            }\r\n        }\r\n        // for (let ref in rangedZergBySwarm) { // todo: finish changing\r\n        // \tif (ref != undefined) {\r\n        // \t\tif (DEBUG) log.debug(`Making swarm for ${_.map(meleeZergBySwarm[ref], z => z.name)}`);\r\n        // \t\tthis.swarms[ref] = new Swarm(this, ref, meleeZergBySwarm[ref]);\r\n        // \t}\r\n        // }\r\n    }\r\n    handleSwarm(swarm, index, waypoint = this.directive.pos) {\r\n        // Swarm initially groups up at fallback location\r\n        if (!swarm.memory.initialAssembly) {\r\n            const assemblyPoint = this.assemblyPoints[index] || this.fallback;\r\n            log.debug(`Assmbling at ${assemblyPoint.print}`);\r\n            swarm.memory.initialAssembly = swarm.assemble(assemblyPoint);\r\n            return;\r\n        }\r\n        // Swarm has now initially assembled with all members present\r\n        // log.debug(`Done assmbling`);\r\n        const room = swarm.rooms[0];\r\n        if (!room) {\r\n            log.warning(`${this.print} No room! (Why?)`);\r\n        }\r\n        // Siege the room\r\n        const nearbyHostiles = _.filter(room.hostiles, creep => swarm.minRangeTo(creep) <= 3 + 1);\r\n        const attack = _.sum(nearbyHostiles, creep => CombatIntel.getAttackDamage(creep));\r\n        const rangedAttack = _.sum(nearbyHostiles, creep => CombatIntel.getRangedAttackDamage(creep));\r\n        const myDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(_.map(swarm.creeps, c => c.creep));\r\n        const canPopShield = (attack + rangedAttack + CombatIntel.towerDamageAtPos(swarm.anchor)) * myDamageMultiplier\r\n            > _.min(_.map(swarm.creeps, creep => 100 * creep.getActiveBodyparts(TOUGH)));\r\n        if (canPopShield || room.hostileStructures.length == 0 || _.values(this.swarms).length > 1) {\r\n            swarm.autoCombat(this.pos.roomName, waypoint);\r\n        }\r\n        else {\r\n            swarm.autoSiege(this.pos.roomName, waypoint);\r\n        }\r\n    }\r\n    init() {\r\n        let numSwarms = this.directive.memory.amount || 1;\r\n        if (RoomIntel.inSafeMode(this.pos.roomName)) {\r\n            numSwarms = 0;\r\n        }\r\n        const zerglingPriority = this.zerglings.length <= this.healers.length ? this.priority - 0.1 : this.priority + 0.1;\r\n        const zerglingSetup = this.canBoostSetup(CombatSetups.zerglings.boosted_T3) ? CombatSetups.zerglings.boosted_T3\r\n            : CombatSetups.zerglings.default;\r\n        const healerPriority = this.healers.length < this.zerglings.length ? this.priority - 0.1 : this.priority + 0.1;\r\n        const healerSetup = this.canBoostSetup(CombatSetups.healers.boosted_T3) ? CombatSetups.healers.boosted_T3\r\n            : CombatSetups.healers.default;\r\n        const hydraliskPriority = this.healers.length < this.zerglings.length ? this.priority - 0.1 : this.priority + 0.1;\r\n        const hydraliskSetup = this.canBoostSetup(CombatSetups.hydralisks.siege_T3) ? CombatSetups.healers.boosted_T3\r\n            : CombatSetups.healers.default;\r\n        const swarmConfig = [{ setup: zerglingSetup, amount: 2, priority: zerglingPriority },\r\n            { setup: healerSetup, amount: 2, priority: healerPriority }];\r\n        this.swarmWishlist(numSwarms, swarmConfig);\r\n        // const rangedSwarmConfig = [{setup: hydraliskSetup, amount: 4, priority: hydraliskPriority}];\r\n        // this.swarmWishlist(numSwarms, rangedSwarmConfig);\r\n    }\r\n    run() {\r\n        this.autoRun(this.zerglings, zergling => undefined); // zergling => undefined is to handle boosting\r\n        this.autoRun(this.healers, healer => undefined);\r\n        // this.autoRun(this.hydralisks, hydralisk => undefined);\r\n        // Run swarms in order\r\n        const refs = _.keys(this.swarms).sort();\r\n        let i = 0;\r\n        for (const ref of refs) {\r\n            this.handleSwarm(this.swarms[ref], i);\r\n            i++;\r\n        }\r\n    }\r\n    visuals() {\r\n        Visualizer.marker(this.fallback, { color: 'green' });\r\n        for (const ref in this.swarms) {\r\n            const swarm = this.swarms[ref];\r\n            Visualizer.marker(swarm.anchor, { color: 'blue' });\r\n            if (swarm.target) {\r\n                Visualizer.marker(swarm.target.pos, { color: 'orange' });\r\n            }\r\n        }\r\n    }\r\n};\r\nSwarmDestroyerOverlord.settings = {\r\n    retreatHitsPercent: 0.85,\r\n    reengageHitsPercent: 0.95,\r\n};\r\nSwarmDestroyerOverlord = tslib_1.__decorate([\r\n    profile\r\n], SwarmDestroyerOverlord);\r\nexport { SwarmDestroyerOverlord };\r\n","references":["C:/git/Screeps-Revamped/src/caching/GlobalCache.ts","C:/git/Screeps-Revamped/src/console/log.ts","C:/git/Screeps-Revamped/src/creepSetups/setups.ts","C:/git/Screeps-Revamped/src/directives/offense/swarmDestroy.ts","C:/git/Screeps-Revamped/src/intel/CombatIntel.ts","C:/git/Screeps-Revamped/src/intel/RoomIntel.ts","C:/git/Screeps-Revamped/src/memory/Memory.ts","C:/git/Screeps-Revamped/src/priorities/priorities_overlords.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/resources/map_resources.ts","C:/git/Screeps-Revamped/src/visuals/Visualizer.ts","C:/git/Screeps-Revamped/src/zerg/CombatZerg.ts","C:/git/Screeps-Revamped/src/zerg/Swarm.ts","C:/git/Screeps-Revamped/src/overlords/SwarmOverlord.ts"]}
