{"code":"import * as tslib_1 from \"tslib\";\r\nimport { $ } from '../../caching/GlobalCache';\r\nimport { Roles, Setups } from '../../creepSetups/setups';\r\nimport { TERMINAL_STATE_REBUILD } from '../../directives/terminalState/terminalState_rebuild';\r\nimport { Energetics } from '../../logistics/Energetics';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { Tasks } from '../../tasks/Tasks';\r\nimport { hasMinerals, minBy } from '../../utilities/utils';\r\nimport { Overlord } from '../Overlord';\r\nimport { WorkerOverlord } from './worker';\r\n/**\r\n * Command center overlord: spawn and run a dediated commandCenter attendant\r\n */\r\nlet CommandCenterOverlord = class CommandCenterOverlord extends Overlord {\r\n    constructor(commandCenter, priority = OverlordPriority.core.manager) {\r\n        super(commandCenter, 'manager', priority);\r\n        this.commandCenter = commandCenter;\r\n        this.mode = this.colony.layout;\r\n        this.managers = this.zerg(Roles.manager);\r\n        if (this.commandCenter.terminal && _.sum(this.commandCenter.terminal.store) < TERMINAL_CAPACITY - 1000) {\r\n            this.depositTarget = this.commandCenter.terminal;\r\n        }\r\n        else {\r\n            this.depositTarget = this.commandCenter.storage;\r\n        }\r\n        if (this.colony.bunker) {\r\n            const anchor = this.colony.bunker.anchor;\r\n            $.set(this, 'managerRepairTarget', () => minBy(_.filter(anchor.findInRange(anchor.room.barriers, 3), b => b.hits < WorkerOverlord.settings.barrierHits[this.colony.level]), b => b.hits));\r\n        }\r\n    }\r\n    refresh() {\r\n        super.refresh();\r\n        $.refresh(this, 'depositTarget', 'managerRepairTarget');\r\n    }\r\n    init() {\r\n        let setup = Setups.managers.default;\r\n        let spawnRequestOptions = {};\r\n        if (this.colony.layout == 'twoPart') {\r\n            setup = Setups.managers.twoPart;\r\n        }\r\n        if (this.colony.bunker && this.colony.bunker.coreSpawn && this.colony.level == 8\r\n            && !this.colony.roomPlanner.memory.relocating) {\r\n            setup = Setups.managers.stationary;\r\n            if (this.managerRepairTarget && this.colony.assets.energy > WorkerOverlord.settings.fortifyDutyThreshold) {\r\n                setup = Setups.managers.stationary_work; // use working manager body if you have something to repair\r\n            }\r\n            spawnRequestOptions = {\r\n                spawn: this.colony.bunker.coreSpawn,\r\n                directions: [this.colony.bunker.coreSpawn.pos.getDirectionTo(this.colony.bunker.anchor)]\r\n            };\r\n        }\r\n        this.wishlist(1, setup, { options: spawnRequestOptions });\r\n    }\r\n    /**\r\n     * Move anything you are currently holding to deposit location\r\n     */\r\n    unloadCarry(manager) {\r\n        if (_.sum(manager.carry) > 0) {\r\n            manager.task = Tasks.transferAll(this.depositTarget);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Handle any supply requests from your transport request group\r\n     */\r\n    supplyActions(manager) {\r\n        const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(manager.pos, 'supply');\r\n        if (request) {\r\n            const amount = Math.min(request.amount, manager.carryCapacity);\r\n            manager.task = Tasks.transfer(request.target, request.resourceType, amount, { nextPos: this.commandCenter.idlePos });\r\n            if ((manager.carry[request.resourceType] || 0) < amount) {\r\n                // If you are currently carrying other crap, overwrite current task and put junk in terminal/storage\r\n                if (_.sum(manager.carry) > (manager.carry[request.resourceType] || 0)) {\r\n                    manager.task = Tasks.transferAll(this.depositTarget);\r\n                }\r\n                // Otherwise withdraw as much as you can hold\r\n                else {\r\n                    const withdrawAmount = amount - _.sum(manager.carry);\r\n                    let withdrawFrom = this.commandCenter.storage;\r\n                    if (this.commandCenter.terminal\r\n                        && (request.resourceType != RESOURCE_ENERGY\r\n                            || (withdrawFrom.store[request.resourceType] || 0) < withdrawAmount\r\n                            || this.commandCenter.terminal.energy > Energetics.settings.terminal.energy.equilibrium)) {\r\n                        withdrawFrom = this.commandCenter.terminal;\r\n                    }\r\n                    manager.task.fork(Tasks.withdraw(withdrawFrom, request.resourceType, withdrawAmount, { nextPos: request.target.pos }));\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Handle any withdrawal requests from your transport request group\r\n     */\r\n    withdrawActions(manager) {\r\n        if (_.sum(manager.carry) < manager.carryCapacity) {\r\n            const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(manager.pos, 'withdraw');\r\n            if (request) {\r\n                const amount = Math.min(request.amount, manager.carryCapacity - _.sum(manager.carry));\r\n                manager.task = Tasks.withdraw(request.target, request.resourceType, amount);\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            manager.task = Tasks.transferAll(this.depositTarget);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Move energy into terminal if storage is too full and into storage if storage is too empty\r\n     */\r\n    equalizeStorageAndTerminal(manager) {\r\n        const storage = this.commandCenter.storage;\r\n        const terminal = this.commandCenter.terminal;\r\n        if (!storage || !terminal)\r\n            return false;\r\n        const equilibrium = Energetics.settings.terminal.energy.equilibrium;\r\n        const tolerance = Energetics.settings.terminal.energy.tolerance;\r\n        const storageTolerance = Energetics.settings.storage.total.tolerance;\r\n        let storageEnergyCap = Energetics.settings.storage.total.cap;\r\n        const terminalState = this.colony.terminalState;\r\n        // Adjust max energy allowable in storage if there's an exception state happening\r\n        if (terminalState && terminalState.type == 'out') {\r\n            storageEnergyCap = terminalState.amounts[RESOURCE_ENERGY] || 0;\r\n        }\r\n        // Move energy from storage to terminal if there is not enough in terminal or if there's terminal evacuation\r\n        if ((terminal.energy < equilibrium - tolerance || storage.energy > storageEnergyCap + storageTolerance)\r\n            && storage.energy > 0) {\r\n            if (this.unloadCarry(manager))\r\n                return true;\r\n            manager.task = Tasks.withdraw(storage);\r\n            manager.task.parent = Tasks.transfer(terminal);\r\n            return true;\r\n        }\r\n        // Move energy from terminal to storage if there is too much in terminal and there is space in storage\r\n        if (terminal.energy > equilibrium + tolerance && storage.energy < storageEnergyCap) {\r\n            if (this.unloadCarry(manager))\r\n                return true;\r\n            manager.task = Tasks.withdraw(terminal);\r\n            manager.task.parent = Tasks.transfer(storage);\r\n            return true;\r\n        }\r\n        // Nothing has happened\r\n        return false;\r\n    }\r\n    /**\r\n     * Move enough energy from a terminal which needs to be moved into storage to allow you to rebuild the terminal\r\n     */\r\n    moveEnergyFromRebuildingTerminal(manager) {\r\n        const storage = this.commandCenter.storage;\r\n        const terminal = this.commandCenter.terminal;\r\n        if (!storage || !terminal) {\r\n            return false;\r\n        }\r\n        if (storage.energy < Energetics.settings.storage.energy.destroyTerminalThreshold) {\r\n            if (this.unloadCarry(manager))\r\n                return true;\r\n            manager.task = Tasks.withdraw(terminal);\r\n            manager.task.parent = Tasks.transfer(storage);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    moveMineralsToTerminal(manager) {\r\n        const storage = this.commandCenter.storage;\r\n        const terminal = this.commandCenter.terminal;\r\n        if (!storage || !terminal) {\r\n            return false;\r\n        }\r\n        // Move all non-energy resources from storage to terminal\r\n        for (const resourceType in storage.store) {\r\n            if (resourceType != RESOURCE_ENERGY && storage.store[resourceType] > 0) {\r\n                if (this.unloadCarry(manager))\r\n                    return true;\r\n                manager.task = Tasks.withdraw(storage, resourceType);\r\n                manager.task.parent = Tasks.transfer(terminal, resourceType);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Pickup resources dropped on manager position or in tombstones from last manager\r\n     */\r\n    pickupActions(manager) {\r\n        // Pickup any resources that happen to be dropped where you are\r\n        const resources = manager.pos.lookFor(LOOK_RESOURCES);\r\n        if (resources.length > 0) {\r\n            manager.task = Tasks.transferAll(this.depositTarget).fork(Tasks.pickup(resources[0]));\r\n            return true;\r\n        }\r\n        // Look for tombstones at position\r\n        const tombstones = manager.pos.lookFor(LOOK_TOMBSTONES);\r\n        if (tombstones.length > 0) {\r\n            manager.task = Tasks.transferAll(this.depositTarget).fork(Tasks.withdrawAll(tombstones[0]));\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Suicide once you get old and make sure you don't drop and waste any resources\r\n     */\r\n    deathActions(manager) {\r\n        const nearbyManagers = _.filter(this.managers, manager => manager.pos.inRangeTo(this.commandCenter.pos, 3));\r\n        if (nearbyManagers.length > 1) {\r\n            if (_.sum(manager.carry) == 0) {\r\n                const nearbySpawn = _.first(manager.pos.findInRange(manager.room.spawns, 1));\r\n                if (nearbySpawn) {\r\n                    nearbySpawn.recycleCreep(manager.creep);\r\n                }\r\n                else {\r\n                    manager.suicide();\r\n                }\r\n            }\r\n            else {\r\n                manager.task = Tasks.transferAll(this.depositTarget);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    handleManager(manager) {\r\n        // Handle switching to next manager\r\n        if (manager.ticksToLive < 150) {\r\n            if (this.deathActions(manager))\r\n                return;\r\n        }\r\n        // Pick up any dropped resources on ground\r\n        if (this.pickupActions(manager))\r\n            return;\r\n        // Move minerals from storage to terminal if needed\r\n        if (hasMinerals(this.commandCenter.storage.store)) {\r\n            if (this.moveMineralsToTerminal(manager))\r\n                return;\r\n        }\r\n        // Fill up storage before you destroy terminal if rebuilding room\r\n        if (this.colony.terminalState == TERMINAL_STATE_REBUILD) {\r\n            if (this.moveEnergyFromRebuildingTerminal(manager))\r\n                return;\r\n        }\r\n        // Moving energy to terminal gets priority if evacuating room\r\n        if (this.colony.terminalState && this.colony.terminalState.type == 'out') {\r\n            if (this.equalizeStorageAndTerminal(manager))\r\n                return;\r\n        }\r\n        // Fulfill withdraw requests\r\n        if (this.commandCenter.transportRequests.needsWithdrawing) {\r\n            if (this.withdrawActions(manager))\r\n                return;\r\n        }\r\n        // Fulfill supply requests\r\n        if (this.commandCenter.transportRequests.needsSupplying) {\r\n            if (this.supplyActions(manager))\r\n                return;\r\n        }\r\n        // Move energy between storage and terminal if needed\r\n        this.equalizeStorageAndTerminal(manager);\r\n    }\r\n    /**\r\n     * Handle idle actions if the manager has nothing to do\r\n     */\r\n    idleActions(manager) {\r\n        if (this.mode == 'bunker' && this.managerRepairTarget && manager.getActiveBodyparts(WORK) > 0) {\r\n            // Repair ramparts when idle\r\n            if (manager.carry.energy > 0) {\r\n                manager.repair(this.managerRepairTarget);\r\n            }\r\n            else {\r\n                manager.withdraw(this.depositTarget);\r\n            }\r\n        }\r\n        if (!manager.pos.isEqualTo(this.commandCenter.idlePos)) {\r\n            manager.goTo(this.commandCenter.idlePos);\r\n        }\r\n    }\r\n    run() {\r\n        for (const manager of this.managers) {\r\n            // Get a task if needed\r\n            if (manager.isIdle) {\r\n                this.handleManager(manager);\r\n            }\r\n            // If you have a valid task, run it; else go to idle pos\r\n            if (manager.hasValidTask) {\r\n                manager.run();\r\n            }\r\n            else {\r\n                this.idleActions(manager);\r\n            }\r\n        }\r\n    }\r\n};\r\nCommandCenterOverlord = tslib_1.__decorate([\r\n    profile\r\n], CommandCenterOverlord);\r\nexport { CommandCenterOverlord };\r\n","references":["C:/git/Screeps-Revamped/src/caching/GlobalCache.ts","C:/git/Screeps-Revamped/src/creepSetups/setups.ts","C:/git/Screeps-Revamped/src/declarations/typeGuards.ts","C:/git/Screeps-Revamped/src/directives/terminalState/terminalState_rebuild.ts","C:/git/Screeps-Revamped/src/hiveClusters/commandCenter.ts","C:/git/Screeps-Revamped/src/hiveClusters/hatchery.ts","C:/git/Screeps-Revamped/src/logistics/Energetics.ts","C:/git/Screeps-Revamped/src/priorities/priorities_overlords.ts","C:/git/Screeps-Revamped/src/profiler/decorator.ts","C:/git/Screeps-Revamped/src/tasks/Tasks.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts","C:/git/Screeps-Revamped/src/zerg/Zerg.ts","C:/git/Screeps-Revamped/src/overlords/Overlord.ts","C:/git/Screeps-Revamped/src/overlords/core/worker.ts"]}
