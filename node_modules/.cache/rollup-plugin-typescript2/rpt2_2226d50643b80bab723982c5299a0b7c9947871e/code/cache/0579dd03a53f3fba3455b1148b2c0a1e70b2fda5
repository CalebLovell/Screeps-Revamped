{"code":"import { alignedNewline, bullet } from '../utilities/stringConstants';\r\nimport { color, toColumns } from '../utilities/utils';\r\nimport { asciiLogoRL, asciiLogoSmall } from '../visuals/logos';\r\nimport { DEFAULT_OVERMIND_SIGNATURE, MY_USERNAME, USE_PROFILER } from '../~settings';\r\nimport { log } from './log';\r\n/**\r\n * OvermindConsole registers a number of global methods for direct use in the Screeps console\r\n */\r\nexport class OvermindConsole {\r\n    static init() {\r\n        global.help = this.help();\r\n        global.info = this.info;\r\n        global.notifications = this.notifications;\r\n        global.debug = this.debug;\r\n        global.stopDebug = this.stopDebug;\r\n        global.setMode = this.setMode;\r\n        global.setSignature = this.setSignature;\r\n        global.print = this.print;\r\n        global.timeit = this.timeit;\r\n        global.setLogLevel = log.setLogLevel;\r\n        global.suspendColony = this.suspendColony;\r\n        global.unsuspendColony = this.unsuspendColony;\r\n        global.openRoomPlanner = this.openRoomPlanner;\r\n        global.closeRoomPlanner = this.closeRoomPlanner;\r\n        global.cancelRoomPlanner = this.cancelRoomPlanner;\r\n        global.listActiveRoomPlanners = this.listActiveRoomPlanners;\r\n        global.destroyErrantStructures = this.destroyErrantStructures;\r\n        global.destroyAllHostileStructures = this.destroyAllHostileStructures;\r\n        global.destroyAllBarriers = this.destroyAllBarriers;\r\n        global.listConstructionSites = this.listConstructionSites;\r\n        global.listDirectives = this.listDirectives;\r\n        global.listPersistentDirectives = this.listPersistentDirectives;\r\n        global.removeAllLogisticsDirectives = this.removeAllLogisticsDirectives;\r\n        global.removeFlagsByColor = this.removeFlagsByColor;\r\n        global.removeErrantFlags = this.removeErrantFlags;\r\n        global.deepCleanMemory = this.deepCleanMemory;\r\n        global.startRemoteDebugSession = this.startRemoteDebugSession;\r\n        global.endRemoteDebugSession = this.endRemoteDebugSession;\r\n        global.profileMemory = this.profileMemory;\r\n        global.cancelMarketOrders = this.cancelMarketOrders;\r\n    }\r\n    // Help, information, and operational changes ======================================================================\r\n    static help() {\r\n        let msg = '\\n<font color=\"#ff00ff\">';\r\n        for (const line of asciiLogoSmall) {\r\n            msg += line + '\\n';\r\n        }\r\n        msg += '</font>';\r\n        const descr = {};\r\n        descr.help = 'show this message';\r\n        descr['info()'] = 'display version and operation information';\r\n        descr['notifications()'] = 'print a list of notifications with hyperlinks to the console';\r\n        descr['setMode(mode)'] = 'set the operational mode to \"manual\", \"semiautomatic\", or \"automatic\"';\r\n        descr['setSignature(newSignature)'] = 'set your controller signature; no argument sets to default';\r\n        descr['print(...args[])'] = 'log stringified objects to the console';\r\n        descr['debug(thing)'] = 'enable debug logging for a game object or process';\r\n        descr['stopDebug(thing)'] = 'disable debug logging for a game object or process';\r\n        descr['timeit(function, repeat=1)'] = 'time the execution of a snippet of code';\r\n        descr['setLogLevel(int)'] = 'set the logging level from 0 - 4';\r\n        descr['suspendColony(roomName)'] = 'suspend operations within a colony';\r\n        descr['unsuspendColony(roomName)'] = 'resume operations within a suspended colony';\r\n        descr['openRoomPlanner(roomName)'] = 'open the room planner for a room';\r\n        descr['closeRoomPlanner(roomName)'] = 'close the room planner and save changes';\r\n        descr['cancelRoomPlanner(roomName)'] = 'close the room planner and discard changes';\r\n        descr['listActiveRoomPlanners()'] = 'display a list of colonies with open room planners';\r\n        descr['destroyErrantStructures(roomName)'] = 'destroys all misplaced structures within an owned room';\r\n        descr['destroyAllHostileStructures(roomName)'] = 'destroys all hostile structures in an owned room';\r\n        descr['destroyAllBarriers(roomName)'] = 'destroys all ramparts and barriers in a room';\r\n        descr['listConstructionSites(filter?)'] = 'list all construction sites matching an optional filter';\r\n        descr['listDirectives(filter?)'] = 'list directives, matching a filter if specified';\r\n        descr['listPersistentDirectives()'] = 'print type, name, pos of every persistent directive';\r\n        descr['removeFlagsByColor(color, secondaryColor)'] = 'remove flags that match the specified colors';\r\n        descr['removeErrantFlags()'] = 'remove all flags which don\\'t match a directive';\r\n        descr['deepCleanMemory()'] = 'deletes all non-critical portions of memory (be careful!)';\r\n        descr['profileMemory(depth=1)'] = 'scan through memory to get the size of various objects';\r\n        descr['startRemoteDebugSession()'] = 'enables the remote debugger so Muon can debug your code';\r\n        descr['cancelMarketOrders(filter?)'] = 'cancels all market orders matching filter (if provided)';\r\n        // Console list\r\n        const descrMsg = toColumns(descr, { justify: true, padChar: '.' });\r\n        const maxLineLength = _.max(_.map(descrMsg, line => line.length)) + 2;\r\n        msg += 'Console Commands: '.padRight(maxLineLength, '=') + '\\n' + descrMsg.join('\\n');\r\n        msg += '\\n\\nRefer to the repository for more information\\n';\r\n        return msg;\r\n    }\r\n    static printUpdateMessage(aligned = false) {\r\n        const joinChar = aligned ? alignedNewline : '\\n';\r\n        const msg = `Codebase updated or global reset. Type \"help\" for a list of console commands.` + joinChar +\r\n            color(asciiLogoSmall.join(joinChar), '#ff00ff') + joinChar +\r\n            OvermindConsole.info(aligned);\r\n        log.alert(msg);\r\n    }\r\n    static printTrainingMessage() {\r\n        console.log('\\n' + asciiLogoRL.join('\\n') + '\\n');\r\n    }\r\n    static info(aligned = false) {\r\n        const b = bullet;\r\n        const checksum = Assimilator.generateChecksum();\r\n        const clearanceCode = Assimilator.getClearanceCode(MY_USERNAME);\r\n        const baseInfo = [\r\n            `${b}Version:        Overmind v${__VERSION__}`,\r\n            `${b}Checksum:       ${checksum}`,\r\n            `${b}Assimilated:    ${clearanceCode ? 'Yes' : 'No'} (clearance code: ${clearanceCode}) [WIP]`,\r\n            `${b}Operating mode: ${Memory.settings.operationMode}`,\r\n        ];\r\n        const joinChar = aligned ? alignedNewline : '\\n';\r\n        return baseInfo.join(joinChar);\r\n    }\r\n    static notifications() {\r\n        const notifications = Overmind.overseer.notifier.generateNotificationsList(true);\r\n        return _.map(notifications, msg => bullet + msg).join('\\n');\r\n    }\r\n    static setMode(mode) {\r\n        switch (mode) {\r\n            case 'manual':\r\n                Memory.settings.operationMode = 'manual';\r\n                return `Operational mode set to manual. Only defensive directives will be placed automatically; ` +\r\n                    `remove harvesting, claiming, room planning, and raiding must be done manually.`;\r\n            case 'semiautomatic':\r\n                Memory.settings.operationMode = 'semiautomatic';\r\n                return `Operational mode set to semiautomatic. Claiming, room planning, and raiding must be done ` +\r\n                    `manually; everything else is automatic.`;\r\n            case 'automatic':\r\n                Memory.settings.operationMode = 'automatic';\r\n                return `Operational mode set to automatic. All actions are done automatically, but manually placed ` +\r\n                    `directives will still be responded to.`;\r\n            default:\r\n                return `Invalid mode: please specify 'manual', 'semiautomatic', or 'automatic'.`;\r\n        }\r\n    }\r\n    static setSignature(signature) {\r\n        const sig = signature ? signature : DEFAULT_OVERMIND_SIGNATURE;\r\n        if (sig.length > 100) {\r\n            throw new Error(`Invalid signature: ${signature}; length is over 100 chars.`);\r\n        }\r\n        else if (sig.toLowerCase().includes('overmind') || sig.includes(DEFAULT_OVERMIND_SIGNATURE)) {\r\n            Memory.settings.signature = sig;\r\n            return `Controller signature set to ${sig}`;\r\n        }\r\n        else {\r\n            throw new Error(`Invalid signature: ${signature}; must contain the string \"Overmind\" or ` +\r\n                `${DEFAULT_OVERMIND_SIGNATURE} (accessible on global with __DEFAULT_OVERMIND_SIGNATURE__)`);\r\n        }\r\n    }\r\n    // Debugging methods ===============================================================================================\r\n    static debug(thing) {\r\n        thing.memory.debug = true;\r\n        return `Enabled debugging for ${thing.name}.`;\r\n    }\r\n    static stopDebug(thing) {\r\n        delete thing.memory.debug;\r\n        return `Disabled debugging for ${thing.name}.`;\r\n    }\r\n    static startRemoteDebugSession() {\r\n        global.remoteDebugger.enable();\r\n        return `Started remote debug session.`;\r\n    }\r\n    static endRemoteDebugSession() {\r\n        global.remoteDebugger.disable();\r\n        return `Ended remote debug session.`;\r\n    }\r\n    static print(...args) {\r\n        for (const arg of args) {\r\n            let cache = [];\r\n            const msg = JSON.stringify(arg, function (key, value) {\r\n                if (typeof value === 'object' && value !== null) {\r\n                    if (cache.indexOf(value) !== -1) {\r\n                        // Duplicate reference found\r\n                        try {\r\n                            // If this value does not reference a parent it can be deduped\r\n                            return JSON.parse(JSON.stringify(value));\r\n                        }\r\n                        catch (error) {\r\n                            // discard key if value cannot be deduped\r\n                            return;\r\n                        }\r\n                    }\r\n                    // Store value in our collection\r\n                    cache.push(value);\r\n                }\r\n                return value;\r\n            }, '\\t');\r\n            cache = null;\r\n            console.log(msg);\r\n        }\r\n        return 'Done.';\r\n    }\r\n    static timeit(callback, repeat = 1) {\r\n        let start, used, i;\r\n        start = Game.cpu.getUsed();\r\n        for (i = 0; i < repeat; i++) {\r\n            callback();\r\n        }\r\n        used = Game.cpu.getUsed() - start;\r\n        return `CPU used: ${used}. Repetitions: ${repeat} (${used / repeat} each).`;\r\n    }\r\n    // Colony suspension ===============================================================================================\r\n    static suspendColony(roomName) {\r\n        if (Overmind.colonies[roomName]) {\r\n            const colonyMemory = Memory.colonies[roomName];\r\n            if (colonyMemory) {\r\n                colonyMemory.suspend = true;\r\n                Overmind.shouldBuild = true;\r\n                return `Colony ${roomName} suspended.`;\r\n            }\r\n            else {\r\n                return `No colony memory for ${roomName}!`;\r\n            }\r\n        }\r\n        else {\r\n            return `Colony ${roomName} is not a valid colony!`;\r\n        }\r\n    }\r\n    static unsuspendColony(roomName) {\r\n        const colonyMemory = Memory.colonies[roomName];\r\n        if (colonyMemory) {\r\n            if (!colonyMemory.suspend) {\r\n                return `Colony ${roomName} is not suspended!`;\r\n            }\r\n            else {\r\n                delete colonyMemory.suspend;\r\n                Overmind.shouldBuild = true;\r\n                return `Colony ${roomName} unsuspended.`;\r\n            }\r\n        }\r\n        else {\r\n            return `No colony memory for ${roomName}!`;\r\n        }\r\n    }\r\n    // Room planner control ============================================================================================\r\n    static openRoomPlanner(roomName) {\r\n        if (Overmind.colonies[roomName]) {\r\n            if (Overmind.colonies[roomName].roomPlanner.active != true) {\r\n                Overmind.colonies[roomName].roomPlanner.active = true;\r\n                return '';\r\n            }\r\n            else {\r\n                return `RoomPlanner for ${roomName} is already active!`;\r\n            }\r\n        }\r\n        else {\r\n            return `Error: ${roomName} is not a valid colony!`;\r\n        }\r\n    }\r\n    static closeRoomPlanner(roomName) {\r\n        if (Overmind.colonies[roomName]) {\r\n            if (Overmind.colonies[roomName].roomPlanner.active) {\r\n                Overmind.colonies[roomName].roomPlanner.finalize();\r\n                return '';\r\n            }\r\n            else {\r\n                return `RoomPlanner for ${roomName} is not active!`;\r\n            }\r\n        }\r\n        else {\r\n            return `Error: ${roomName} is not a valid colony!`;\r\n        }\r\n    }\r\n    static cancelRoomPlanner(roomName) {\r\n        if (Overmind.colonies[roomName]) {\r\n            if (Overmind.colonies[roomName].roomPlanner.active) {\r\n                Overmind.colonies[roomName].roomPlanner.active = false;\r\n                return `RoomPlanner for ${roomName} has been deactivated without saving changes`;\r\n            }\r\n            else {\r\n                return `RoomPlanner for ${roomName} is not active!`;\r\n            }\r\n        }\r\n        else {\r\n            return `Error: ${roomName} is not a valid colony!`;\r\n        }\r\n    }\r\n    static listActiveRoomPlanners() {\r\n        const coloniesWithActiveRoomPlanners = _.filter(_.map(_.keys(Overmind.colonies), colonyName => Overmind.colonies[colonyName]), (colony) => colony.roomPlanner.active);\r\n        const names = _.map(coloniesWithActiveRoomPlanners, colony => colony.room.print);\r\n        if (names.length > 0) {\r\n            console.log('Colonies with active room planners: ' + names);\r\n            return '';\r\n        }\r\n        else {\r\n            return `No colonies with active room planners`;\r\n        }\r\n    }\r\n    static listConstructionSites(filter) {\r\n        let msg = `${_.keys(Game.constructionSites).length} construction sites currently present: \\n`;\r\n        for (const id in Game.constructionSites) {\r\n            const site = Game.constructionSites[id];\r\n            if (!filter || filter(site)) {\r\n                msg += `${bullet}Type: ${site.structureType}`.padRight(20) +\r\n                    `Pos: ${site.pos.print}`.padRight(65) +\r\n                    `Progress: ${site.progress} / ${site.progressTotal} \\n`;\r\n            }\r\n        }\r\n        return msg;\r\n    }\r\n    // Directive management ============================================================================================\r\n    static listDirectives(filter) {\r\n        let msg = '';\r\n        for (const i in Overmind.directives) {\r\n            const dir = Overmind.directives[i];\r\n            if (!filter || filter(dir)) {\r\n                msg += `${bullet}Name: ${dir.print}`.padRight(70) +\r\n                    `Colony: ${dir.colony.print}`.padRight(55) +\r\n                    `Pos: ${dir.pos.print}\\n`;\r\n            }\r\n        }\r\n        return msg;\r\n    }\r\n    static removeAllLogisticsDirectives() {\r\n        const logisticsFlags = _.filter(Game.flags, flag => flag.color == COLOR_YELLOW &&\r\n            flag.secondaryColor == COLOR_YELLOW);\r\n        for (const dir of logisticsFlags) {\r\n            dir.remove();\r\n        }\r\n        return `Removed ${logisticsFlags.length} logistics directives.`;\r\n    }\r\n    static listPersistentDirectives() {\r\n        let msg = '';\r\n        for (const i in Overmind.directives) {\r\n            const dir = Overmind.directives[i];\r\n            if (dir.memory.persistent) {\r\n                msg += `Type: ${dir.directiveName}`.padRight(20) +\r\n                    `Name: ${dir.name}`.padRight(15) +\r\n                    `Pos: ${dir.pos.print}\\n`;\r\n            }\r\n        }\r\n        return msg;\r\n    }\r\n    static removeFlagsByColor(color, secondaryColor) {\r\n        const removeFlags = _.filter(Game.flags, flag => flag.color == color && flag.secondaryColor == secondaryColor);\r\n        for (const flag of removeFlags) {\r\n            flag.remove();\r\n        }\r\n        return `Removed ${removeFlags.length} flags.`;\r\n    }\r\n    static removeErrantFlags() {\r\n        // This may need to be be run several times depending on visibility\r\n        if (USE_PROFILER) {\r\n            return `ERROR: should not be run while profiling is enabled!`;\r\n        }\r\n        let count = 0;\r\n        for (const name in Game.flags) {\r\n            if (!Overmind.directives[name]) {\r\n                Game.flags[name].remove();\r\n                count += 1;\r\n            }\r\n        }\r\n        return `Removed ${count} flags.`;\r\n    }\r\n    // Structure management ============================================================================================\r\n    static destroyErrantStructures(roomName) {\r\n        const colony = Overmind.colonies[roomName];\r\n        if (!colony)\r\n            return `${roomName} is not a valid colony!`;\r\n        const room = colony.room;\r\n        const allStructures = room.find(FIND_STRUCTURES);\r\n        let i = 0;\r\n        for (const s of allStructures) {\r\n            if (s.structureType == STRUCTURE_CONTROLLER)\r\n                continue;\r\n            if (!colony.roomPlanner.structureShouldBeHere(s.structureType, s.pos)) {\r\n                const result = s.destroy();\r\n                if (result == OK) {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        return `Destroyed ${i} misplaced structures in ${roomName}.`;\r\n    }\r\n    static destroyAllHostileStructures(roomName) {\r\n        const room = Game.rooms[roomName];\r\n        if (!room)\r\n            return `${roomName} is undefined! (No vision?)`;\r\n        if (!room.my)\r\n            return `${roomName} is not owned by you!`;\r\n        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);\r\n        for (const structure of hostileStructures) {\r\n            structure.destroy();\r\n        }\r\n        return `Destroyed ${hostileStructures.length} hostile structures.`;\r\n    }\r\n    static destroyAllBarriers(roomName) {\r\n        const room = Game.rooms[roomName];\r\n        if (!room)\r\n            return `${roomName} is undefined! (No vision?)`;\r\n        if (!room.my)\r\n            return `${roomName} is not owned by you!`;\r\n        for (const barrier of room.barriers) {\r\n            barrier.destroy();\r\n        }\r\n        return `Destroyed ${room.barriers.length} barriers.`;\r\n    }\r\n    // Memory management ===============================================================================================\r\n    static deepCleanMemory() {\r\n        // Clean colony memory\r\n        const protectedColonyKeys = ['defcon', 'roomPlanner', 'roadPlanner', 'barrierPlanner'];\r\n        for (const colName in Memory.colonies) {\r\n            for (const key in Memory.colonies[colName]) {\r\n                if (!protectedColonyKeys.includes(key)) {\r\n                    delete Memory.colonies[colName][key];\r\n                }\r\n            }\r\n        }\r\n        // Suicide any creeps which have no memory\r\n        for (const i in Game.creeps) {\r\n            if (Game.creeps[i].memory == {}) {\r\n                Game.creeps[i].suicide();\r\n            }\r\n        }\r\n        // Remove profiler memory\r\n        delete Memory.profiler;\r\n        // Remove overlords memory from flags\r\n        for (const i in Memory.flags) {\r\n            if (Memory.flags[i].overlords) {\r\n                delete Memory.flags[i].overlords;\r\n            }\r\n        }\r\n        // Clean creep memory\r\n        for (const i in Memory.creeps) {\r\n            // Remove all creep tasks to fix memory leak in 0.3.1\r\n            if (Memory.creeps[i].task) {\r\n                Memory.creeps[i].task = null;\r\n            }\r\n        }\r\n        return `Memory has been cleaned.`;\r\n    }\r\n    static recursiveMemoryProfile(memoryObject, sizes, currentDepth) {\r\n        for (const key in memoryObject) {\r\n            if (currentDepth == 0 || !_.keys(memoryObject[key]) || _.keys(memoryObject[key]).length == 0) {\r\n                sizes[key] = JSON.stringify(memoryObject[key]).length;\r\n            }\r\n            else {\r\n                sizes[key] = {};\r\n                OvermindConsole.recursiveMemoryProfile(memoryObject[key], sizes[key], currentDepth - 1);\r\n            }\r\n        }\r\n    }\r\n    static profileMemory(depth = 1) {\r\n        const sizes = {};\r\n        console.log(`Profiling memory...`);\r\n        const start = Game.cpu.getUsed();\r\n        OvermindConsole.recursiveMemoryProfile(Memory, sizes, depth);\r\n        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);\r\n        return JSON.stringify(sizes, undefined, '\\t');\r\n    }\r\n    static cancelMarketOrders(filter) {\r\n        const ordersToCancel = !!filter ? _.filter(Game.market.orders, order => filter(order)) : Game.market.orders;\r\n        _.forEach(_.values(ordersToCancel), (order) => Game.market.cancelOrder(order.id));\r\n        return `Canceled ${_.values(ordersToCancel).length} orders.`;\r\n    }\r\n}\r\n","references":["C:/git/Screeps-Revamped/src/Colony.ts","C:/git/Screeps-Revamped/src/directives/Directive.ts","C:/git/Screeps-Revamped/src/utilities/stringConstants.ts","C:/git/Screeps-Revamped/src/utilities/utils.ts","C:/git/Screeps-Revamped/src/visuals/logos.ts","C:/git/Screeps-Revamped/src/~settings.ts","C:/git/Screeps-Revamped/src/console/log.ts"]}
