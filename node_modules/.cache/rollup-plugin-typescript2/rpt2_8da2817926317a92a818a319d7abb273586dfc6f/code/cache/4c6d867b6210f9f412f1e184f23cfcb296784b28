{"code":"import * as tslib_1 from \"tslib\";\r\nvar Log_1;\r\nimport { profile } from '../profiler/decorator';\r\nimport { color } from '../utilities/utils';\r\nexport var LogLevels;\r\n(function (LogLevels) {\r\n    LogLevels[LogLevels[\"ERROR\"] = 0] = \"ERROR\";\r\n    LogLevels[LogLevels[\"WARNING\"] = 1] = \"WARNING\";\r\n    LogLevels[LogLevels[\"ALERT\"] = 2] = \"ALERT\";\r\n    LogLevels[LogLevels[\"INFO\"] = 3] = \"INFO\";\r\n    LogLevels[LogLevels[\"DEBUG\"] = 4] = \"DEBUG\"; // log.level = 4\r\n})(LogLevels || (LogLevels = {}));\r\n/**\r\n * Default debug level for log output\r\n */\r\nexport const LOG_LEVEL = LogLevels.INFO;\r\n/**\r\n * Prepend log output with current tick number.\r\n */\r\nexport const LOG_PRINT_TICK = true;\r\n/**\r\n * Prepend log output with source line.\r\n */\r\nexport const LOG_PRINT_LINES = false;\r\n/**\r\n * Load source maps and resolve source lines back to typeascript.\r\n */\r\nexport const LOG_LOAD_SOURCE_MAP = false;\r\n/**\r\n * Maximum padding for source links (for aligning log output).\r\n */\r\nexport const LOG_MAX_PAD = 100;\r\n/**\r\n * VSC location, used to create links back to source.\r\n * Repo and revision are filled in at build time for git repositories.\r\n */\r\nexport const LOG_VSC = { repo: '@@_repo_@@', revision: '@@_revision_@@', valid: false };\r\n// export const LOG_VSC = { repo: \"@@_repo_@@\", revision: __REVISION__, valid: false };\r\n/**\r\n * URL template for VSC links, this one works for github and gitlab.\r\n */\r\nexport const LOG_VSC_URL_TEMPLATE = (path, line) => {\r\n    return `${LOG_VSC.repo}/blob/${LOG_VSC.revision}/${path}#${line}`;\r\n};\r\n// <caller> (<source>:<line>:<column>)\r\nconst stackLineRe = /([^ ]*) \\(([^:]*):([0-9]*):([0-9]*)\\)/;\r\nconst FATAL = -1;\r\nconst fatalColor = '#d65156';\r\nexport function resolve(fileLine) {\r\n    const split = _.trim(fileLine).match(stackLineRe);\r\n    if (!split || !Log.sourceMap) {\r\n        return { compiled: fileLine, final: fileLine };\r\n    }\r\n    const pos = { column: parseInt(split[4], 10), line: parseInt(split[3], 10) };\r\n    const original = Log.sourceMap.originalPositionFor(pos);\r\n    const line = `${split[1]} (${original.source}:${original.line})`;\r\n    const out = {\r\n        caller: split[1],\r\n        compiled: fileLine,\r\n        final: line,\r\n        line: original.line,\r\n        original: line,\r\n        path: original.source,\r\n    };\r\n    return out;\r\n}\r\nfunction makeVSCLink(pos) {\r\n    if (!LOG_VSC.valid || !pos.caller || !pos.path || !pos.line || !pos.original) {\r\n        return pos.final;\r\n    }\r\n    return link(vscUrl(pos.path, `L${pos.line.toString()}`), pos.original);\r\n}\r\nfunction tooltip(str, tooltip) {\r\n    return `<abbr title='${tooltip}'>${str}</abbr>`;\r\n}\r\nfunction vscUrl(path, line) {\r\n    return LOG_VSC_URL_TEMPLATE(path, line);\r\n}\r\nfunction link(href, title) {\r\n    return `<a href='${href}' target=\"_blank\">${title}</a>`;\r\n}\r\nfunction time() {\r\n    return color(Game.time.toString(), 'gray');\r\n}\r\nexport function debug(thing, ...args) {\r\n    if (thing.memory && thing.memory.debug) {\r\n        this.debug(`${thing.name} @ ${thing.pos.print}: `, args);\r\n    }\r\n}\r\n/**\r\n * Log provides methods for displaying pretty-printed text into the Screeps console\r\n */\r\nlet Log = Log_1 = class Log {\r\n    constructor() {\r\n        this._maxFileString = 0;\r\n        _.defaultsDeep(Memory, {\r\n            settings: {\r\n                log: {\r\n                    level: LOG_LEVEL,\r\n                    showSource: LOG_PRINT_LINES,\r\n                    showTick: LOG_PRINT_TICK,\r\n                }\r\n            }\r\n        });\r\n    }\r\n    static loadSourceMap() {\r\n        // try {\r\n        // \t// tslint:disable-next-line\r\n        // \tconst map = require('main.js.map');\r\n        // \tif (map) {\r\n        // \t\tLog.sourceMap = new SourceMapConsumer(map);\r\n        // \t}\r\n        // } catch (err) {\r\n        console.log('Source mapping deprecated.');\r\n        // }\r\n    }\r\n    get level() {\r\n        return Memory.settings.log.level;\r\n    }\r\n    setLogLevel(value) {\r\n        let changeValue = true;\r\n        switch (value) {\r\n            case LogLevels.ERROR:\r\n                console.log(`Logging level set to ${value}. Displaying: ERROR.`);\r\n                break;\r\n            case LogLevels.WARNING:\r\n                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING.`);\r\n                break;\r\n            case LogLevels.ALERT:\r\n                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT.`);\r\n                break;\r\n            case LogLevels.INFO:\r\n                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO.`);\r\n                break;\r\n            case LogLevels.DEBUG:\r\n                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO, DEBUG.`);\r\n                break;\r\n            default:\r\n                console.log(`Invalid input: ${value}. Loging level can be set to integers between `\r\n                    + LogLevels.ERROR + ' and ' + LogLevels.DEBUG + ', inclusive.');\r\n                changeValue = false;\r\n                break;\r\n        }\r\n        if (changeValue) {\r\n            Memory.settings.log.level = value;\r\n        }\r\n    }\r\n    get showSource() {\r\n        return Memory.settings.log.showSource;\r\n    }\r\n    set showSource(value) {\r\n        Memory.settings.log.showSource = value;\r\n    }\r\n    get showTick() {\r\n        return Memory.settings.log.showTick;\r\n    }\r\n    set showTick(value) {\r\n        Memory.settings.log.showTick = value;\r\n    }\r\n    trace(error) {\r\n        if (this.level >= LogLevels.ERROR && error.stack) {\r\n            console.log(this.resolveStack(error.stack));\r\n        }\r\n        return this;\r\n    }\r\n    throw(e) {\r\n        console.log.apply(this, this.buildArguments(FATAL).concat([color(e.toString(), fatalColor)]));\r\n    }\r\n    error(...args) {\r\n        if (this.level >= LogLevels.ERROR) {\r\n            console.log.apply(this, this.buildArguments(LogLevels.ERROR).concat([].slice.call(args)));\r\n        }\r\n        return undefined;\r\n    }\r\n    warning(...args) {\r\n        if (this.level >= LogLevels.WARNING) {\r\n            console.log.apply(this, this.buildArguments(LogLevels.WARNING).concat([].slice.call(args)));\r\n        }\r\n        return undefined;\r\n    }\r\n    alert(...args) {\r\n        if (this.level >= LogLevels.ALERT) {\r\n            console.log.apply(this, this.buildArguments(LogLevels.ALERT).concat([].slice.call(args)));\r\n        }\r\n        return undefined;\r\n    }\r\n    notify(message) {\r\n        this.alert(message);\r\n        Game.notify(message);\r\n        return undefined;\r\n    }\r\n    info(...args) {\r\n        if (this.level >= LogLevels.INFO) {\r\n            console.log.apply(this, this.buildArguments(LogLevels.INFO).concat([].slice.call(args)));\r\n        }\r\n        return undefined;\r\n    }\r\n    debug(...args) {\r\n        if (this.level >= LogLevels.DEBUG) {\r\n            console.log.apply(this, this.buildArguments(LogLevels.DEBUG).concat([].slice.call(args)));\r\n        }\r\n    }\r\n    debugCreep(creep, ...args) {\r\n        if (creep.memory && creep.memory.debug) {\r\n            this.debug(`${creep.name} @ ${creep.pos.print}: `, args);\r\n        }\r\n    }\r\n    printObject(obj) {\r\n        console.log.apply(this, this.buildArguments(LogLevels.DEBUG).concat(JSON.stringify(obj)));\r\n    }\r\n    getFileLine(upStack = 4) {\r\n        const stack = new Error('').stack;\r\n        if (stack) {\r\n            const lines = stack.split('\\n');\r\n            if (lines.length > upStack) {\r\n                const originalLines = _.drop(lines, upStack).map(resolve);\r\n                const hoverText = _.map(originalLines, 'final').join('&#10;');\r\n                return this.adjustFileLine(originalLines[0].final, tooltip(makeVSCLink(originalLines[0]), hoverText));\r\n            }\r\n        }\r\n        return '';\r\n    }\r\n    buildArguments(level) {\r\n        const out = [];\r\n        switch (level) {\r\n            case LogLevels.ERROR:\r\n                out.push(color('ERROR  ', 'red'));\r\n                break;\r\n            case LogLevels.WARNING:\r\n                out.push(color('WARNING', 'orange'));\r\n                break;\r\n            case LogLevels.ALERT:\r\n                out.push(color('ALERT  ', 'yellow'));\r\n                break;\r\n            case LogLevels.INFO:\r\n                out.push(color('INFO   ', 'green'));\r\n                break;\r\n            case LogLevels.DEBUG:\r\n                out.push(color('DEBUG  ', 'gray'));\r\n                break;\r\n            case FATAL:\r\n                out.push(color('FATAL  ', fatalColor));\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        if (this.showTick) {\r\n            out.push(time());\r\n        }\r\n        if (this.showSource && level <= LogLevels.ERROR) {\r\n            out.push(this.getFileLine());\r\n        }\r\n        return out;\r\n    }\r\n    resolveStack(stack) {\r\n        if (!Log_1.sourceMap) {\r\n            return stack;\r\n        }\r\n        return _.map(stack.split('\\n').map(resolve), 'final').join('\\n');\r\n    }\r\n    adjustFileLine(visibleText, line) {\r\n        const newPad = Math.max(visibleText.length, this._maxFileString);\r\n        this._maxFileString = Math.min(newPad, LOG_MAX_PAD);\r\n        return `|${_.padRight(line, line.length + this._maxFileString - visibleText.length, ' ')}|`;\r\n    }\r\n};\r\nLog = Log_1 = tslib_1.__decorate([\r\n    profile\r\n], Log);\r\nexport { Log };\r\nif (LOG_LOAD_SOURCE_MAP) {\r\n    Log.loadSourceMap();\r\n}\r\nexport const log = new Log();\r\n","references":["C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/utils.ts"]}
