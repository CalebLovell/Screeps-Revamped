{"code":"import * as tslib_1 from \"tslib\";\r\nvar RoadLogistics_1;\r\nimport { $ } from '../caching/GlobalCache';\r\nimport { profile } from '../profiler/decorator';\r\nimport { repairTaskName } from '../tasks/instances/repair';\r\nconst ROAD_CACHE_TIMEOUT = 15;\r\n/**\r\n * RoadLogistics: groups roads in a single object for more intelligent repair requests\r\n */\r\nlet RoadLogistics = RoadLogistics_1 = class RoadLogistics {\r\n    constructor(colony) {\r\n        this.colony = colony;\r\n        this.ref = this.colony.name + ':roadLogistics';\r\n        this.rooms = colony.rooms;\r\n        this._assignedWorkers = {};\r\n    }\r\n    refresh() {\r\n        this._assignedWorkers = {};\r\n    }\r\n    /**\r\n     * Whether a road in the network needs repair\r\n     */\r\n    workerShouldRepaveRoom(worker, room) {\r\n        // Room should be repaved if there is a road with critical HP or if energy to repave >= worker carry capacity\r\n        const otherAssignedWorkers = _.filter(this.assignedWorkers(room), name => name != worker.name);\r\n        if (otherAssignedWorkers.length < RoadLogistics_1.settings.allowedPaversPerRoom) {\r\n            if (this.assignedWorkers(room).includes(worker.name)) {\r\n                // If worker is already working in the room, have it repair until all roads are at acceptable level\r\n                return this.repairableRoads(room).length > 0;\r\n            }\r\n            else {\r\n                // If worker is not already assigned, repair if critical roads or repaving energy >= carry capacity\r\n                return this.criticalRoads(room).length > 0 || this.energyToRepave(room) >= worker.carryCapacity;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Get the room the worker should repave, if any\r\n     */\r\n    workerShouldRepave(worker) {\r\n        // If the worker is already working in a room and should keep doing so, return that first\r\n        if (worker.task && worker.task.name == repairTaskName) {\r\n            const room = Game.rooms[worker.task.targetPos.roomName];\r\n            if (room && this.assignedWorkers(room).includes(worker.name)\r\n                && this.workerShouldRepaveRoom(worker, room)) {\r\n                return room;\r\n            }\r\n        }\r\n        // Otherwise scan through rooms and see if needs repaving\r\n        for (const room of this.rooms) {\r\n            if (this.workerShouldRepaveRoom(worker, room)) {\r\n                return room;\r\n            }\r\n        }\r\n    }\r\n    // /* Compute roads ordered by a depth-first search from a root node */\r\n    // roads(room: Room): StructureRoad[] {\r\n    //\r\n    // }\r\n    criticalRoads(room) {\r\n        return $.structures(this, 'criticalRoads:' + room.name, () => _.sortBy(_.filter(room.roads, road => road.hits < road.hitsMax * RoadLogistics_1.settings.criticalThreshold &&\r\n            this.colony.roomPlanner.roadShouldBeHere(road.pos)), road => road.pos.getMultiRoomRangeTo(this.colony.pos)), ROAD_CACHE_TIMEOUT);\r\n    }\r\n    repairableRoads(room) {\r\n        return $.structures(this, 'repairableRoads:' + room.name, () => _.sortBy(_.filter(room.roads, road => road.hits < road.hitsMax * RoadLogistics_1.settings.repairThreshold &&\r\n            this.colony.roomPlanner.roadShouldBeHere(road.pos)), road => road.pos.getMultiRoomRangeTo(this.colony.pos)), ROAD_CACHE_TIMEOUT);\r\n    }\r\n    /**\r\n     * Total amount of energy needed to repair all roads in the room\r\n     */\r\n    energyToRepave(room) {\r\n        return $.number(this, 'energyToRepave:' + room.name, () => _.sum(this.repairableRoads(room), road => (road.hitsMax - road.hits) / REPAIR_POWER));\r\n    }\r\n    /**\r\n     * Check that the worker is in the assignedWorker cache; avoids bugs where duplicate workers get assigned\r\n     * on the same tick\r\n     */\r\n    registerWorkerAssignment(worker, room) {\r\n        if (this._assignedWorkers[room.name]) {\r\n            if (!this._assignedWorkers[room.name].includes(worker.name)) {\r\n                this._assignedWorkers[room.name].push(worker.name);\r\n            }\r\n        }\r\n        else {\r\n            this._assignedWorkers[room.name] = [worker.name];\r\n        }\r\n    }\r\n    assignedWorkers(room) {\r\n        return this._assignedWorkers[room.name] || [];\r\n    }\r\n    init() {\r\n        const workers = this.colony.overlords.work.workers;\r\n        for (const worker of workers) {\r\n            if (worker.task && worker.task.name == repairTaskName) {\r\n                const roomName = worker.task.targetPos.roomName;\r\n                if (!this._assignedWorkers[roomName]) {\r\n                    this._assignedWorkers[roomName] = [];\r\n                }\r\n                this._assignedWorkers[roomName].push(worker.name);\r\n            }\r\n        }\r\n    }\r\n    run() {\r\n    }\r\n};\r\nRoadLogistics.settings = {\r\n    allowedPaversPerRoom: 1,\r\n    criticalThreshold: 0.25,\r\n    repairThreshold: 0.9\r\n};\r\nRoadLogistics = RoadLogistics_1 = tslib_1.__decorate([\r\n    profile\r\n], RoadLogistics);\r\nexport { RoadLogistics };\r\n","references":["C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/tasks/instances/repair.ts","C:/git/Overmind/src/zerg/Zerg.ts"]}
