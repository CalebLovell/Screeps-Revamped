{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Pathing } from '../../movement/Pathing';\r\nimport { MiningOverlord } from '../../overlords/mining/miner';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { Cartographer, ROOMTYPE_SOURCEKEEPER } from '../../utilities/Cartographer';\r\nimport { exponentialMovingAverage, getCacheExpiration } from '../../utilities/utils';\r\nimport { Directive } from '../Directive';\r\n// Because harvest directives are the most common, they have special shortened memory keys to minimize memory impact\r\nexport const _HARVEST_MEM_PATHING = 'P';\r\nexport const _HARVEST_MEM_USAGE = 'u';\r\nexport const _HARVEST_MEM_DOWNTIME = 'd';\r\nconst defaultDirectiveHarvestMemory = {\r\n    [_HARVEST_MEM_USAGE]: 1,\r\n    [_HARVEST_MEM_DOWNTIME]: 0,\r\n};\r\n/**\r\n * Standard mining directive. Mines from an owned, remote, or source keeper room\r\n */\r\nlet DirectiveHarvest = class DirectiveHarvest extends Directive {\r\n    constructor(flag) {\r\n        super(flag);\r\n        if (this.colony) {\r\n            this.colony.miningSites[this.name] = this;\r\n            this.colony.destinations.push({ pos: this.pos, order: this.memory[\"T\" /* TICK */] || Game.time });\r\n        }\r\n        _.defaultsDeep(this.memory, defaultDirectiveHarvestMemory);\r\n    }\r\n    // Hauling distance\r\n    get distance() {\r\n        if (!this.memory[_HARVEST_MEM_PATHING] || Game.time >= this.memory[_HARVEST_MEM_PATHING][\"X\" /* EXPIRATION */]) {\r\n            const distance = Pathing.distance(this.colony.pos, this.pos);\r\n            const expiration = getCacheExpiration(this.colony.storage ? 5000 : 1000);\r\n            this.memory[_HARVEST_MEM_PATHING] = {\r\n                [\"D\" /* DISTANCE */]: distance,\r\n                [\"X\" /* EXPIRATION */]: expiration\r\n            };\r\n        }\r\n        return this.memory[_HARVEST_MEM_PATHING][\"D\" /* DISTANCE */];\r\n    }\r\n    spawnMoarOverlords() {\r\n        // Create a mining overlord for this\r\n        let priority = OverlordPriority.ownedRoom.mine;\r\n        if (!(this.room && this.room.my)) {\r\n            priority = Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER ?\r\n                OverlordPriority.remoteSKRoom.mine : OverlordPriority.remoteRoom.mine;\r\n        }\r\n        this.overlords.mine = new MiningOverlord(this, priority);\r\n    }\r\n    init() {\r\n    }\r\n    run() {\r\n        this.computeStats();\r\n    }\r\n    computeStats() {\r\n        const source = this.overlords.mine.source;\r\n        if (source && source.ticksToRegeneration == 1) {\r\n            this.memory[_HARVEST_MEM_USAGE] = (source.energyCapacity - source.energy) / source.energyCapacity;\r\n        }\r\n        const container = this.overlords.mine.container;\r\n        this.memory[_HARVEST_MEM_DOWNTIME] = +(exponentialMovingAverage(container ? +container.isFull : 0, this.memory[_HARVEST_MEM_DOWNTIME], CREEP_LIFE_TIME)).toFixed(5);\r\n    }\r\n};\r\nDirectiveHarvest.directiveName = 'harvest';\r\nDirectiveHarvest.color = COLOR_YELLOW;\r\nDirectiveHarvest.secondaryColor = COLOR_YELLOW;\r\nDirectiveHarvest = tslib_1.__decorate([\r\n    profile\r\n], DirectiveHarvest);\r\nexport { DirectiveHarvest };\r\n","references":["C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/overlords/mining/miner.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/Cartographer.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/directives/Directive.ts"]}
