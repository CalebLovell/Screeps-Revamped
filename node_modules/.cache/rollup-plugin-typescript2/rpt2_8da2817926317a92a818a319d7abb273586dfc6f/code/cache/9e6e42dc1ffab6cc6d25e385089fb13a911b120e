{"code":"import * as tslib_1 from \"tslib\";\r\nimport { getAllColonies } from '../Colony';\r\nimport { log } from '../console/log';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { profile } from '../profiler/decorator';\r\nimport { equalXYR, getPosFromString, randomHex } from '../utilities/utils';\r\nimport { NotifierPriority } from './Notifier';\r\nconst DEFAULT_MAX_PATH_LENGTH = 600;\r\nconst DEFAULT_MAX_LINEAR_RANGE = 10;\r\n/**\r\n * Directives are contextual wrappers for flags and serve as attachment points for Overlords, acting as a sort of\r\n * \"process table\" for the bot, with individual processes (Overlords) run by the scheulder (Overseer)\r\n */\r\nlet Directive = class Directive {\r\n    constructor(flag, colonyFilter) {\r\n        this.memory = flag.memory;\r\n        if (this.memory.suspendUntil) {\r\n            if (Game.time < this.memory.suspendUntil) {\r\n                return;\r\n            }\r\n            else {\r\n                delete this.memory.suspendUntil;\r\n            }\r\n        }\r\n        this.name = flag.name;\r\n        this.ref = flag.ref;\r\n        if (!this.memory[\"T\" /* TICK */]) {\r\n            this.memory[\"T\" /* TICK */] = Game.time;\r\n        }\r\n        if (this.memory.waypoints) {\r\n            this.waypoints = _.map(this.memory.waypoints, posName => getPosFromString(posName));\r\n        }\r\n        // Relocate flag if needed; this must be called before the colony calculations\r\n        const needsRelocating = this.handleRelocation();\r\n        if (!needsRelocating) {\r\n            this.pos = flag.pos;\r\n            this.room = flag.room;\r\n        }\r\n        const colony = this.getColony(colonyFilter);\r\n        // Delete the directive if the colony is dead\r\n        if (!colony) {\r\n            if (Overmind.exceptions.length == 0) {\r\n                log.alert(`Could not get colony for directive ${this.print}; removing flag!`);\r\n                flag.remove();\r\n            }\r\n            else {\r\n                log.alert(`Could not get colony for directive ${this.print}; ` +\r\n                    `exceptions present this tick, so won't remove`);\r\n            }\r\n            return;\r\n        }\r\n        // Delete the directive if expired\r\n        if (this.memory[\"X\" /* EXPIRATION */] && Game.time > this.memory[\"X\" /* EXPIRATION */]) {\r\n            log.alert(`Removing expired directive ${this.print}!`);\r\n            flag.remove();\r\n            return;\r\n        }\r\n        // Register colony and add flags to colony.flags\r\n        this.colony = colony;\r\n        this.colony.flags.push(flag);\r\n        this.overlords = {};\r\n        // Register directive on Overmind\r\n        global[this.name] = this;\r\n        Overmind.overseer.registerDirective(this);\r\n        Overmind.directives[this.name] = this;\r\n    }\r\n    /**\r\n     * Gets an effective room position for a directive; allows you to reference this.pos in constructor super() without\r\n     * throwing an error\r\n     */\r\n    static getPos(flag) {\r\n        if (flag.memory && flag.memory.setPosition) {\r\n            const pos = derefRoomPosition(flag.memory.setPosition);\r\n            return pos;\r\n        }\r\n        return flag.pos;\r\n    }\r\n    // Flag must be a getter to avoid caching issues\r\n    get flag() {\r\n        return Game.flags[this.name];\r\n    }\r\n    // get isSuspended(): boolean {\r\n    // \treturn !!this.memory.suspendUntil && Game.time < this.memory.suspendUntil;\r\n    // }\r\n    //\r\n    // suspend(ticks: number) {\r\n    // \tthis.memory.suspendUntil = Game.time + ticks;\r\n    // }\r\n    //\r\n    // suspendUntil(tick: number) {\r\n    // \tthis.memory.suspendUntil = tick;\r\n    // }\r\n    refresh() {\r\n        const flag = this.flag;\r\n        if (!flag) {\r\n            log.warning(`Missing flag for directive ${this.print}! Removing directive.`);\r\n            this.remove();\r\n            return;\r\n        }\r\n        this.memory = flag.memory;\r\n        this.pos = flag.pos;\r\n        this.room = flag.room;\r\n    }\r\n    alert(message, priority = NotifierPriority.Normal) {\r\n        Overmind.overseer.notifier.alert(message, this.pos.roomName, priority);\r\n    }\r\n    get print() {\r\n        return '<a href=\"#!/room/' + Game.shard.name + '/' + this.pos.roomName + '\">[' + this.name + ']</a>';\r\n    }\r\n    handleRelocation() {\r\n        if (this.memory.setPosition) {\r\n            const pos = derefRoomPosition(this.memory.setPosition);\r\n            if (!this.flag.pos.isEqualTo(pos)) {\r\n                const result = this.flag.setPosition(pos);\r\n                if (result == OK) {\r\n                    log.debug(`Moving ${this.name} from ${this.flag.pos.print} to ${pos.print}.`);\r\n                }\r\n                else {\r\n                    log.warning(`Could not set room position to ${JSON.stringify(this.memory.setPosition)}!`);\r\n                }\r\n            }\r\n            else {\r\n                delete this.memory.setPosition;\r\n            }\r\n            this.pos = pos;\r\n            this.room = Game.rooms[pos.roomName];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    getColony(colonyFilter, verbose = false) {\r\n        // If something is written to flag.colony, use that as the colony\r\n        if (this.memory[\"C\" /* COLONY */]) {\r\n            return Overmind.colonies[this.memory[\"C\" /* COLONY */]];\r\n        }\r\n        else {\r\n            // If flag contains a colony name as a substring, assign to that colony, regardless of RCL\r\n            const colonyNames = _.keys(Overmind.colonies);\r\n            for (const name of colonyNames) {\r\n                if (this.name.includes(name)) {\r\n                    if (this.name.split(name)[1] != '')\r\n                        continue; // in case of other substring, e.g. E11S12 and E11S1\r\n                    this.memory[\"C\" /* COLONY */] = name;\r\n                    return Overmind.colonies[name];\r\n                }\r\n            }\r\n            // If flag is in a room belonging to a colony and the colony has sufficient RCL, assign to there\r\n            const colony = Overmind.colonies[Overmind.colonyMap[this.pos.roomName]];\r\n            if (colony) {\r\n                if (!colonyFilter || colonyFilter(colony)) {\r\n                    this.memory[\"C\" /* COLONY */] = colony.name;\r\n                    return colony;\r\n                }\r\n            }\r\n            // Otherwise assign to closest colony\r\n            const nearestColony = this.findNearestColony(colonyFilter, verbose);\r\n            if (nearestColony) {\r\n                log.info(`Colony ${nearestColony.room.print} assigned to ${this.name}.`);\r\n                this.memory[\"C\" /* COLONY */] = nearestColony.room.name;\r\n                return nearestColony;\r\n            }\r\n            else {\r\n                log.error(`Could not find colony match for ${this.name} in ${this.pos.roomName}! ` +\r\n                    `Try setting memory.maxPathLength and memory.maxLinearRange.`);\r\n            }\r\n        }\r\n    }\r\n    findNearestColony(colonyFilter, verbose = false) {\r\n        const maxPathLength = this.memory.maxPathLength || DEFAULT_MAX_PATH_LENGTH;\r\n        const maxLinearRange = this.memory.maxLinearRange || DEFAULT_MAX_LINEAR_RANGE;\r\n        if (verbose)\r\n            log.info(`Recalculating colony association for ${this.name} in ${this.pos.roomName}`);\r\n        let nearestColony;\r\n        let minDistance = Infinity;\r\n        const colonyRooms = _.filter(Game.rooms, room => room.my);\r\n        for (const colony of getAllColonies()) {\r\n            if (Game.map.getRoomLinearDistance(this.pos.roomName, colony.name) > maxLinearRange) {\r\n                continue;\r\n            }\r\n            if (!colonyFilter || colonyFilter(colony)) {\r\n                const ret = Pathing.findPath((colony.hatchery || colony).pos, this.pos);\r\n                if (!ret.incomplete) {\r\n                    if (ret.path.length < maxPathLength && ret.path.length < minDistance) {\r\n                        nearestColony = colony;\r\n                        minDistance = ret.path.length;\r\n                    }\r\n                    if (verbose)\r\n                        log.info(`Path length to ${colony.room.print}: ${ret.path.length}`);\r\n                }\r\n                else {\r\n                    if (verbose)\r\n                        log.info(`Incomplete path from ${colony.room.print}`);\r\n                }\r\n            }\r\n        }\r\n        if (nearestColony) {\r\n            return nearestColony;\r\n        }\r\n    }\r\n    // Wrapped flag methods ============================================================================================\r\n    remove(force = false) {\r\n        if (!this.memory.persistent || force) {\r\n            delete Overmind.directives[this.name];\r\n            delete global[this];\r\n            Overmind.overseer.removeDirective(this);\r\n            if (this.colony) {\r\n                _.remove(this.colony.flags, flag => flag.name == this.name);\r\n            }\r\n            if (this.flag) { // check in case flag was removed manually in last build cycle\r\n                return this.flag.remove();\r\n            }\r\n        }\r\n    }\r\n    setColor(color, secondaryColor) {\r\n        if (secondaryColor) {\r\n            return this.flag.setColor(color, secondaryColor);\r\n        }\r\n        else {\r\n            return this.flag.setColor(color);\r\n        }\r\n    }\r\n    setPosition(pos) {\r\n        // Ignore the (x,y) setPosition option since I never use it\r\n        return this.flag.setPosition(pos);\r\n    }\r\n    // Custom directive methods ========================================================================================\r\n    /* Create an appropriate flag to instantiate this directive in the next tick */\r\n    static create(pos, opts = {}) {\r\n        let flagName = opts.name || undefined;\r\n        if (!flagName) {\r\n            flagName = this.directiveName + ':' + randomHex(6);\r\n            if (Game.flags[flagName]) {\r\n                return ERR_NAME_EXISTS;\r\n            }\r\n        }\r\n        if (!opts.quiet) {\r\n            log.alert(`Creating ${this.directiveName} directive at ${pos.print}!`);\r\n        }\r\n        const result = pos.createFlag(flagName, this.color, this.secondaryColor);\r\n        if (result == flagName && opts.memory) {\r\n            Memory.flags[flagName] = opts.memory;\r\n        }\r\n        log.debug(`Result: ${result}, memory: ${JSON.stringify(Memory.flags[result])}`);\r\n        return result;\r\n    }\r\n    /* Whether a directive of the same type is already present (in room | at position) */\r\n    static isPresent(pos, scope) {\r\n        const room = Game.rooms[pos.roomName];\r\n        switch (scope) {\r\n            case 'room':\r\n                if (room) {\r\n                    return _.filter(room.flags, flag => this.filter(flag) &&\r\n                        !(flag.memory.setPosition\r\n                            && flag.memory.setPosition.roomName != pos.roomName)).length > 0;\r\n                }\r\n                else {\r\n                    const flagsInRoom = _.filter(Game.flags, function (flag) {\r\n                        if (flag.memory.setPosition) { // does it need to be relocated?\r\n                            return flag.memory.setPosition.roomName == pos.roomName;\r\n                        }\r\n                        else { // properly located\r\n                            return flag.pos.roomName == pos.roomName;\r\n                        }\r\n                    });\r\n                    return _.filter(flagsInRoom, flag => this.filter(flag)).length > 0;\r\n                }\r\n            case 'pos':\r\n                if (room) {\r\n                    return _.filter(pos.lookFor(LOOK_FLAGS), flag => this.filter(flag) &&\r\n                        !(flag.memory.setPosition\r\n                            && !equalXYR(pos, flag.memory.setPosition))).length > 0;\r\n                }\r\n                else {\r\n                    const flagsAtPos = _.filter(Game.flags, function (flag) {\r\n                        if (flag.memory.setPosition) { // does it need to be relocated?\r\n                            return equalXYR(flag.memory.setPosition, pos);\r\n                        }\r\n                        else { // properly located\r\n                            return equalXYR(flag.pos, pos);\r\n                        }\r\n                    });\r\n                    return _.filter(flagsAtPos, flag => this.filter(flag)).length > 0;\r\n                }\r\n        }\r\n    }\r\n    /* Create a directive if one of the same type is not already present (in room | at position).\r\n     * Calling this method on positions in invisible rooms can be expensive and should be used sparingly. */\r\n    static createIfNotPresent(pos, scope, opts = {}) {\r\n        if (this.isPresent(pos, scope)) {\r\n            return; // do nothing if flag is already here\r\n        }\r\n        const room = Game.rooms[pos.roomName];\r\n        if (!room) {\r\n            if (!opts.memory) {\r\n                opts.memory = {};\r\n            }\r\n            opts.memory.setPosition = pos;\r\n        }\r\n        switch (scope) {\r\n            case 'room':\r\n                if (room) {\r\n                    return this.create(pos, opts);\r\n                }\r\n                else {\r\n                    log.info(`Creating directive at ${pos.print}... ` +\r\n                        `No visibility in room; directive will be relocated on next tick.`);\r\n                    let createAtPos;\r\n                    if (opts.memory && opts.memory[\"C\" /* COLONY */]) {\r\n                        createAtPos = Pathing.findPathablePosition(opts.memory[\"C\" /* COLONY */]);\r\n                    }\r\n                    else {\r\n                        createAtPos = Pathing.findPathablePosition(_.first(getAllColonies()).room.name);\r\n                    }\r\n                    return this.create(createAtPos, opts);\r\n                }\r\n            case 'pos':\r\n                if (room) {\r\n                    return this.create(pos, opts);\r\n                }\r\n                else {\r\n                    log.info(`Creating directive at ${pos.print}... ` +\r\n                        `No visibility in room; directive will be relocated on next tick.`);\r\n                    let createAtPos;\r\n                    if (opts.memory && opts.memory[\"C\" /* COLONY */]) {\r\n                        createAtPos = Pathing.findPathablePosition(opts.memory[\"C\" /* COLONY */]);\r\n                    }\r\n                    else {\r\n                        createAtPos = Pathing.findPathablePosition(_.first(getAllColonies()).room.name);\r\n                    }\r\n                    return this.create(createAtPos, opts);\r\n                }\r\n        }\r\n    }\r\n    /* Filter for _.filter() that checks if a flag is of the matching type */\r\n    static filter(flag) {\r\n        return flag.color == this.color && flag.secondaryColor == this.secondaryColor;\r\n    }\r\n    /* Map a list of flags to directives, accepting a filter */\r\n    static find(flags) {\r\n        flags = _.filter(flags, flag => this.filter(flag));\r\n        return _.compact(_.map(flags, flag => Overmind.directives[flag.name]));\r\n    }\r\n    // Overwrite this in child classes to display relevant information\r\n    visuals() {\r\n    }\r\n};\r\nDirective = tslib_1.__decorate([\r\n    profile\r\n], Directive);\r\nexport { Directive };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/overlords/Overlord.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/directives/Notifier.ts"]}
