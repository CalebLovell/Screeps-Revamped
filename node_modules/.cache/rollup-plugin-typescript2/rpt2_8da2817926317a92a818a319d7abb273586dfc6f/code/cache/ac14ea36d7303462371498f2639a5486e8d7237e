{"code":"import * as tslib_1 from \"tslib\";\r\nimport { log } from '../../console/log';\r\nimport { isResource } from '../../declarations/typeGuards';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { maxBy, minMax } from '../../utilities/utils';\r\nimport { Task } from '../Task';\r\nimport { TaskHarvest } from './harvest';\r\nimport { pickupTaskName, TaskPickup } from './pickup';\r\nimport { TaskWithdraw, withdrawTaskName } from './withdraw';\r\nexport const rechargeTaskName = 'recharge';\r\n// This is a \"dispenser task\" which is not itself a valid task, but dispenses a task when assigned to a creep.\r\nlet TaskRecharge = class TaskRecharge extends Task {\r\n    constructor(target, minEnergy = 0, options = {}) {\r\n        super(rechargeTaskName, { ref: '', pos: { x: -1, y: -1, roomName: '' } }, options);\r\n        this.data.minEnergy = minEnergy;\r\n    }\r\n    rechargeRateForCreep(creep, obj) {\r\n        if (creep.colony && creep.colony.hatchery && creep.colony.hatchery.battery\r\n            && obj.id == creep.colony.hatchery.battery.id && creep.roleName != 'queen') {\r\n            return false; // only queens can use the hatchery battery\r\n        }\r\n        let amount = isResource(obj) ? obj.amount : obj.energy;\r\n        if (amount < this.data.minEnergy) {\r\n            return false;\r\n        }\r\n        const otherTargeters = _.filter(_.map(obj.targetedBy, name => Overmind.zerg[name]), zerg => !!zerg && zerg.memory._task\r\n            && (zerg.memory._task.name == withdrawTaskName\r\n                || zerg.memory._task.name == pickupTaskName));\r\n        const resourceOutflux = _.sum(_.map(otherTargeters, other => other.carryCapacity - _.sum(other.carry)));\r\n        amount = minMax(amount - resourceOutflux, 0, creep.carryCapacity);\r\n        const effectiveAmount = amount / (creep.pos.getMultiRoomRangeTo(obj.pos) + 1);\r\n        if (effectiveAmount <= 0) {\r\n            return false;\r\n        }\r\n        else {\r\n            return effectiveAmount;\r\n        }\r\n    }\r\n    // Override creep setter to dispense a valid recharge task\r\n    set creep(creep) {\r\n        this._creep.name = creep.name;\r\n        if (this._parent) {\r\n            this.parent.creep = creep;\r\n        }\r\n        // Choose the target to maximize your energy gain subject to other targeting workers\r\n        const target = creep.colony && creep.inColonyRoom\r\n            ? maxBy(creep.colony.rechargeables, o => this.rechargeRateForCreep(creep, o))\r\n            : maxBy(creep.room.rechargeables, o => this.rechargeRateForCreep(creep, o));\r\n        if (!target || creep.pos.getMultiRoomRangeTo(target.pos) > 40) {\r\n            // workers shouldn't harvest; let drones do it (disabling this check can destabilize early economy)\r\n            const canHarvest = creep.getActiveBodyparts(WORK) > 0 && creep.roleName != 'worker';\r\n            if (canHarvest) {\r\n                // Harvest from a source if there is no recharge target available\r\n                const availableSources = _.filter(creep.room.sources, function (source) {\r\n                    // Only harvest from sources which aren't surrounded by creeps excluding yourself\r\n                    const isSurrounded = source.pos.availableNeighbors(false).length == 0;\r\n                    return !isSurrounded || creep.pos.isNearTo(source);\r\n                });\r\n                const availableSource = creep.pos.findClosestByMultiRoomRange(availableSources);\r\n                if (availableSource) {\r\n                    creep.task = new TaskHarvest(availableSource);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        if (target) {\r\n            if (isResource(target)) {\r\n                creep.task = new TaskPickup(target);\r\n                return;\r\n            }\r\n            else {\r\n                creep.task = new TaskWithdraw(target);\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            // if (creep.roleName == 'queen') {\r\n            log.debug(`No valid withdraw target for ${creep.print}!`);\r\n            // }\r\n            creep.task = null;\r\n        }\r\n    }\r\n    isValidTask() {\r\n        return false;\r\n    }\r\n    isValidTarget() {\r\n        return false;\r\n    }\r\n    work() {\r\n        log.warning(`BAD RESULT: Should not get here...`);\r\n        return ERR_INVALID_TARGET;\r\n    }\r\n};\r\nTaskRecharge = tslib_1.__decorate([\r\n    profile\r\n], TaskRecharge);\r\nexport { TaskRecharge };\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/tasks/Task.ts","C:/git/Overmind/src/tasks/instances/harvest.ts","C:/git/Overmind/src/tasks/instances/pickup.ts","C:/git/Overmind/src/tasks/instances/withdraw.ts"]}
