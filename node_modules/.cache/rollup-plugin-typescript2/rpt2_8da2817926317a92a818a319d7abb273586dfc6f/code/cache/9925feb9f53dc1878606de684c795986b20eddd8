{"code":"// Random utilities that don't belong anywhere else\r\nimport { alignedNewline, bullet } from './stringConstants';\r\nexport function getAllColonyRooms() {\r\n    return _.filter(_.values(Game.rooms), room => room.my);\r\n}\r\nexport function printRoomName(roomName) {\r\n    return '<a href=\"#!/room/' + Game.shard.name + '/' + roomName + '\">' + roomName + '</a>';\r\n}\r\nexport function color(str, color) {\r\n    return `<font color='${color}'>${str}</font>`;\r\n}\r\n/**\r\n * Correct generalization of the modulo operator to negative numbers\r\n */\r\nexport function mod(n, m) {\r\n    return ((n % m) + m) % m;\r\n}\r\nexport function minMax(value, min, max) {\r\n    return Math.max(Math.min(value, max), min);\r\n}\r\nexport function hasMinerals(store) {\r\n    for (const resourceType in store) {\r\n        if (resourceType != RESOURCE_ENERGY && (store[resourceType] || 0) > 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Obtain the username of the player\r\n */\r\nexport function getUsername() {\r\n    for (const i in Game.rooms) {\r\n        const room = Game.rooms[i];\r\n        if (room.controller && room.controller.my) {\r\n            return room.controller.owner.username;\r\n        }\r\n    }\r\n    for (const i in Game.creeps) {\r\n        const creep = Game.creeps[i];\r\n        if (creep.owner) {\r\n            return creep.owner.username;\r\n        }\r\n    }\r\n    console.log('ERROR: Could not determine username. You can set this manually in src/settings/settings_user');\r\n    return 'ERROR: Could not determine username.';\r\n}\r\nexport function hasJustSpawned() {\r\n    return _.keys(Overmind.colonies).length == 1 && _.keys(Game.creeps).length == 0 && _.keys(Game.spawns).length == 1;\r\n}\r\nexport function onPublicServer() {\r\n    return Game.shard.name.includes('shard');\r\n}\r\nexport function onTrainingEnvironment() {\r\n    return !!Memory.reinforcementLearning && !!Memory.reinforcementLearning.enabled;\r\n}\r\nexport function getReinforcementLearningTrainingVerbosity() {\r\n    if (Memory.reinforcementLearning) {\r\n        if (Memory.reinforcementLearning.verbosity != undefined) {\r\n            return Memory.reinforcementLearning.verbosity;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\nexport function bulleted(text, aligned = true, startWithNewLine = true) {\r\n    if (text.length == 0) {\r\n        return '';\r\n    }\r\n    const prefix = (startWithNewLine ? (aligned ? alignedNewline : '\\n') : '') + bullet;\r\n    if (aligned) {\r\n        return prefix + text.join(alignedNewline + bullet);\r\n    }\r\n    else {\r\n        return prefix + text.join('\\n' + bullet);\r\n    }\r\n}\r\n/**\r\n * Create column-aligned text array from object with string key/values\r\n */\r\nexport function toColumns(obj, opts = {}) {\r\n    _.defaults(opts, {\r\n        padChar: ' ',\r\n        justify: false // Right align values column?\r\n    });\r\n    const ret = [];\r\n    const keyPadding = _.max(_.map(_.keys(obj), str => str.length)) + 1;\r\n    const valPadding = _.max(_.mapValues(obj, str => str.length));\r\n    for (const key in obj) {\r\n        if (opts.justify) {\r\n            ret.push(key.padRight(keyPadding, opts.padChar) + obj[key].padLeft(valPadding, opts.padChar));\r\n        }\r\n        else {\r\n            ret.push(key.padRight(keyPadding, opts.padChar) + obj[key]);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * Merges a list of store-like objects, summing overlapping keys. Useful for calculating assets from multiple sources\r\n */\r\nexport function mergeSum(objects) {\r\n    const ret = {};\r\n    for (const object of objects) {\r\n        for (const key in object) {\r\n            const amount = object[key] || 0;\r\n            if (!ret[key]) {\r\n                ret[key] = 0;\r\n            }\r\n            ret[key] += amount;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nexport function coordName(coord) {\r\n    return coord.x + ':' + coord.y;\r\n}\r\nconst CHARCODE_A = 65;\r\n/**\r\n * Returns a compact two-character encoding of the coordinate\r\n */\r\nexport function compactCoordName(coord) {\r\n    return String.fromCharCode(CHARCODE_A + coord.x, CHARCODE_A + coord.y);\r\n}\r\nexport function derefCoords(coordName, roomName) {\r\n    const [x, y] = coordName.split(':');\r\n    return new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName);\r\n}\r\nexport function getPosFromString(str) {\r\n    if (!str)\r\n        return;\r\n    const posName = _.first(str.match(/(E|W)\\d+(N|S)\\d+:\\d+:\\d+/g) || []);\r\n    if (posName) {\r\n        const [roomName, x, y] = posName.split(':');\r\n        return new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName);\r\n    }\r\n}\r\nexport function equalXYR(pos1, pos2) {\r\n    return pos1.x == pos2.x && pos1.y == pos2.y && pos1.roomName == pos2.roomName;\r\n}\r\n/**\r\n * Averages a list of objects by mapping object=>iteratee(object)\r\n */\r\nexport function averageBy(objects, iteratee) {\r\n    if (objects.length == 0) {\r\n        return undefined;\r\n    }\r\n    else {\r\n        return _.sum(objects, obj => iteratee(obj)) / objects.length;\r\n    }\r\n}\r\n/**\r\n * Equivalent to lodash.minBy() method\r\n */\r\nexport function minBy(objects, iteratee) {\r\n    let minObj;\r\n    let minVal = Infinity;\r\n    let val;\r\n    for (const i in objects) {\r\n        val = iteratee(objects[i]);\r\n        if (val !== false && val < minVal) {\r\n            minVal = val;\r\n            minObj = objects[i];\r\n        }\r\n    }\r\n    return minObj;\r\n}\r\n/**\r\n * Equivalent to lodash.maxBy() method\r\n */\r\nexport function maxBy(objects, iteratee) {\r\n    let maxObj;\r\n    let maxVal = -Infinity;\r\n    let val;\r\n    for (const i in objects) {\r\n        val = iteratee(objects[i]);\r\n        if (val !== false && val > maxVal) {\r\n            maxVal = val;\r\n            maxObj = objects[i];\r\n        }\r\n    }\r\n    return maxObj;\r\n}\r\nexport function logHeapStats() {\r\n    if (typeof Game.cpu.getHeapStatistics === 'function') {\r\n        const heapStats = Game.cpu.getHeapStatistics();\r\n        const heapPercent = Math.round(100 * (heapStats.total_heap_size + heapStats.externally_allocated_size)\r\n            / heapStats.heap_size_limit);\r\n        const heapSize = Math.round((heapStats.total_heap_size) / 1048576);\r\n        const externalHeapSize = Math.round((heapStats.externally_allocated_size) / 1048576);\r\n        const heapLimit = Math.round(heapStats.heap_size_limit / 1048576);\r\n        console.log(`Heap usage: ${heapSize} MB + ${externalHeapSize} MB of ${heapLimit} MB (${heapPercent}%).`);\r\n    }\r\n}\r\n/**\r\n * Return whether the IVM is enabled\r\n */\r\nexport function isIVM() {\r\n    return typeof Game.cpu.getHeapStatistics === 'function';\r\n}\r\n/**\r\n * Generate a randomly-offset cache expiration time\r\n */\r\nexport function getCacheExpiration(timeout, offset = 5) {\r\n    return Game.time + timeout + Math.round((Math.random() * offset * 2) - offset);\r\n}\r\nconst hexChars = '0123456789abcdef';\r\n/**\r\n * Generate a random hex string of specified length\r\n */\r\nexport function randomHex(length) {\r\n    let result = '';\r\n    for (let i = 0; i < length; i++) {\r\n        result += hexChars[Math.floor(Math.random() * hexChars.length)];\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Compute an exponential moving average\r\n */\r\nexport function exponentialMovingAverage(current, avg, window) {\r\n    return (current + (avg || 0) * (window - 1)) / window;\r\n}\r\n/**\r\n * Compute an exponential moving average for unevenly spaced samples\r\n */\r\nexport function irregularExponentialMovingAverage(current, avg, dt, window) {\r\n    return (current * dt + avg * (window - dt)) / window;\r\n}\r\n/**\r\n * Create a shallow copy of a 2D array\r\n */\r\nexport function clone2DArray(a) {\r\n    return _.map(a, e => e.slice());\r\n}\r\n/**\r\n * Rotate a square matrix in place clockwise by 90 degrees\r\n */\r\nfunction rotateMatrix(matrix) {\r\n    // reverse the rows\r\n    matrix.reverse();\r\n    // swap the symmetric elements\r\n    for (let i = 0; i < matrix.length; i++) {\r\n        for (let j = 0; j < i; j++) {\r\n            const temp = matrix[i][j];\r\n            matrix[i][j] = matrix[j][i];\r\n            matrix[j][i] = temp;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Return a copy of a 2D array rotated by specified number of clockwise 90 turns\r\n */\r\nexport function rotatedMatrix(matrix, clockwiseTurns) {\r\n    const mat = clone2DArray(matrix);\r\n    for (let i = 0; i < clockwiseTurns; i++) {\r\n        rotateMatrix(mat);\r\n    }\r\n    return mat;\r\n}\r\n","references":["C:/git/Overmind/src/utilities/stringConstants.ts"]}
