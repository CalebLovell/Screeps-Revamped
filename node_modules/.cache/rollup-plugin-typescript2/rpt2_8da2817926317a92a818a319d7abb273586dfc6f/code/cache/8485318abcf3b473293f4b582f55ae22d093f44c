{"code":"import * as tslib_1 from \"tslib\";\r\nimport { log } from '../console/log';\r\nimport { CombatIntel } from '../intel/CombatIntel';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { AttackStructurePriorities, AttackStructureScores } from '../priorities/priorities_structures';\r\nimport { profile } from '../profiler/decorator';\r\nimport { maxBy } from '../utilities/utils';\r\nimport { Visualizer } from '../visuals/Visualizer';\r\nlet CombatTargeting = class CombatTargeting {\r\n    /**\r\n     * Finds the best target within a given range that a zerg can currently attack\r\n     */\r\n    static findBestCreepTargetInRange(zerg, range, targets = zerg.room.hostiles) {\r\n        const nearbyHostiles = _.filter(targets, c => zerg.pos.inRangeToXY(c.pos.x, c.pos.y, range));\r\n        return maxBy(nearbyHostiles, function (hostile) {\r\n            if (hostile.hitsPredicted == undefined)\r\n                hostile.hitsPredicted = hostile.hits;\r\n            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART))\r\n                return false;\r\n            return hostile.hitsMax - hostile.hitsPredicted + CombatIntel.getHealPotential(hostile); // compute score\r\n        });\r\n    }\r\n    /**\r\n     * Finds the best target within a given range that a zerg can currently attack\r\n     */\r\n    static findBestStructureTargetInRange(zerg, range, allowUnowned = true) {\r\n        let nearbyStructures = _.filter(zerg.room.hostileStructures, s => zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range));\r\n        // If no owned structures to attack and not in colony room or outpost, target unowned structures\r\n        if (allowUnowned && nearbyStructures.length == 0 && !Overmind.colonyMap[zerg.room.name]) {\r\n            nearbyStructures = _.filter(zerg.room.structures, s => zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range));\r\n        }\r\n        return maxBy(nearbyStructures, function (structure) {\r\n            let score = 10 * AttackStructureScores[structure.structureType];\r\n            if (structure.pos.lookForStructure(STRUCTURE_RAMPART))\r\n                score *= .1;\r\n            return score;\r\n        });\r\n    }\r\n    /**\r\n     * Standard target-finding logic\r\n     */\r\n    static findTarget(zerg, targets = zerg.room.hostiles) {\r\n        return maxBy(targets, function (hostile) {\r\n            if (hostile.hitsPredicted == undefined)\r\n                hostile.hitsPredicted = hostile.hits;\r\n            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART))\r\n                return false;\r\n            return hostile.hitsMax - hostile.hitsPredicted + CombatIntel.getHealPotential(hostile)\r\n                - 10 * zerg.pos.getMultiRoomRangeTo(hostile.pos); // compute score\r\n        });\r\n    }\r\n    /**\r\n     * Finds the best target within a given range that a zerg can currently attack\r\n     */\r\n    static findBestCreepTargetForTowers(room, targets = room.hostiles) {\r\n        return maxBy(targets, function (hostile) {\r\n            if (hostile.hitsPredicted == undefined)\r\n                hostile.hitsPredicted = hostile.hits;\r\n            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART))\r\n                return false;\r\n            return hostile.hitsMax - hostile.hitsPredicted\r\n                + CombatIntel.getHealPotential(hostile) + (CombatIntel.towerDamageAtPos(hostile.pos) || 0);\r\n        });\r\n    }\r\n    static findClosestHostile(zerg, checkReachable = false, ignoreCreepsAtEdge = true) {\r\n        if (zerg.room.hostiles.length > 0) {\r\n            let targets;\r\n            if (ignoreCreepsAtEdge) {\r\n                targets = _.filter(zerg.room.hostiles, hostile => hostile.pos.rangeToEdge > 0);\r\n            }\r\n            else {\r\n                targets = zerg.room.hostiles;\r\n            }\r\n            if (checkReachable) {\r\n                const targetsByRange = _.sortBy(targets, target => zerg.pos.getRangeTo(target));\r\n                return _.find(targetsByRange, target => Pathing.isReachable(zerg.pos, target.pos, zerg.room.barriers));\r\n            }\r\n            else {\r\n                return zerg.pos.findClosestByRange(targets);\r\n            }\r\n        }\r\n    }\r\n    // This method is expensive\r\n    static findClosestReachable(pos, targets) {\r\n        const targetsByRange = _.sortBy(targets, target => pos.getRangeTo(target));\r\n        return _.find(targetsByRange, target => Pathing.isReachable(pos, target.pos, target.room.barriers));\r\n    }\r\n    static findClosestHurtFriendly(healer) {\r\n        return healer.pos.findClosestByRange(_.filter(healer.room.creeps, creep => creep.hits < creep.hitsMax));\r\n    }\r\n    /**\r\n     * Finds the best (friendly) target in range that a zerg can currently heal\r\n     */\r\n    static findBestHealingTargetInRange(healer, range = 3, friendlies = healer.room.creeps) {\r\n        return maxBy(_.filter(friendlies, f => healer.pos.getRangeTo(f) <= range), friend => {\r\n            if (friend.hitsPredicted == undefined)\r\n                friend.hitsPredicted = friend.hits;\r\n            const attackProbability = 0.5;\r\n            for (const hostile of friend.pos.findInRange(friend.room.hostiles, 3)) {\r\n                if (hostile.pos.isNearTo(friend)) {\r\n                    friend.hitsPredicted -= attackProbability * CombatIntel.getAttackDamage(hostile);\r\n                }\r\n                else {\r\n                    friend.hitsPredicted -= attackProbability * (CombatIntel.getAttackDamage(hostile)\r\n                        + CombatIntel.getRangedAttackDamage(hostile));\r\n                }\r\n            }\r\n            const healScore = friend.hitsMax - friend.hitsPredicted;\r\n            if (healer.pos.getRangeTo(friend) > 1) {\r\n                return healScore + CombatIntel.getRangedHealAmount(healer.creep);\r\n            }\r\n            else {\r\n                return healScore + CombatIntel.getHealAmount(healer.creep);\r\n            }\r\n        });\r\n    }\r\n    static findClosestPrioritizedStructure(zerg, checkReachable = false) {\r\n        for (const structureType of AttackStructurePriorities) {\r\n            const structures = _.filter(zerg.room.hostileStructures, s => s.structureType == structureType);\r\n            if (structures.length == 0)\r\n                continue;\r\n            if (checkReachable) {\r\n                const closestReachable = this.findClosestReachable(zerg.pos, structures);\r\n                if (closestReachable)\r\n                    return closestReachable;\r\n            }\r\n            else {\r\n                return zerg.pos.findClosestByRange(structures);\r\n            }\r\n        }\r\n    }\r\n    static findBestStructureTarget(pos) {\r\n        const room = Game.rooms[pos.roomName];\r\n        // Don't accidentally destroy your own shit\r\n        if (!room || room.my || room.reservedByMe) {\r\n            return;\r\n        }\r\n        // Look for any unprotected structures\r\n        const unprotectedRepairables = _.filter(room.repairables, s => {\r\n            const rampart = s.pos.lookForStructure(STRUCTURE_RAMPART);\r\n            return !rampart || rampart.hits < 10000;\r\n        });\r\n        let approach = _.map(unprotectedRepairables, structure => {\r\n            return { pos: structure.pos, range: 0 };\r\n        });\r\n        if (room.barriers.length == 0 && unprotectedRepairables.length == 0)\r\n            return; // if there's nothing in the room\r\n        // Try to find a reachable unprotected structure\r\n        if (approach.length > 0) {\r\n            const ret = PathFinder.search(pos, approach, {\r\n                maxRooms: 1,\r\n                maxOps: 2000,\r\n                roomCallback: roomName => {\r\n                    if (roomName != room.name)\r\n                        return false;\r\n                    const matrix = new PathFinder.CostMatrix();\r\n                    for (const barrier of room.barriers) {\r\n                        matrix.set(barrier.pos.x, barrier.pos.y, 0xff);\r\n                    }\r\n                    return matrix;\r\n                },\r\n            });\r\n            const targetPos = _.last(ret.path);\r\n            if (!ret.incomplete && targetPos) {\r\n                const targetStructure = _.first(_.filter(targetPos.lookFor(LOOK_STRUCTURES), s => {\r\n                    return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;\r\n                }));\r\n                if (targetStructure) {\r\n                    log.debug(`Found unprotected structure target @ ${targetPos.print}`);\r\n                    return targetStructure;\r\n                }\r\n            }\r\n        }\r\n        // Determine a \"siege anchor\" for what you eventually want to destroy\r\n        let targets = room.spawns;\r\n        if (targets.length == 0)\r\n            targets = room.repairables;\r\n        if (targets.length == 0)\r\n            targets = room.barriers;\r\n        if (targets.length == 0)\r\n            targets = room.structures;\r\n        if (targets.length == 0)\r\n            return;\r\n        // Recalculate approach targets\r\n        approach = _.map(targets, s => {\r\n            return { pos: s.pos, range: 0 };\r\n        });\r\n        const maxWallHits = _.max(_.map(room.barriers, b => b.hits)) || 0;\r\n        // Compute path with wall position costs weighted by fraction of highest wall\r\n        const ret = PathFinder.search(pos, approach, {\r\n            maxRooms: 1,\r\n            plainCost: 1,\r\n            swampCost: 2,\r\n            roomCallback: roomName => {\r\n                if (roomName != pos.roomName)\r\n                    return false;\r\n                const matrix = new PathFinder.CostMatrix();\r\n                for (const barrier of room.barriers) {\r\n                    const cost = 100 + Math.round((barrier.hits / maxWallHits) * 100);\r\n                    matrix.set(barrier.pos.x, barrier.pos.y, cost);\r\n                }\r\n                return matrix;\r\n            },\r\n        });\r\n        // Target the first non-road, non-container structure you find along the path\r\n        for (const pos of ret.path) {\r\n            const targetStructure = _.first(_.filter(pos.lookFor(LOOK_STRUCTURES), s => {\r\n                return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;\r\n            }));\r\n            if (targetStructure) {\r\n                log.debug(`Targeting structure @ ${targetStructure.pos.print}`);\r\n                return targetStructure;\r\n            }\r\n        }\r\n    }\r\n    static findBestSwarmStructureTarget(swarm, roomName, randomness = 0, displayCostMatrix = false) {\r\n        const room = Game.rooms[roomName];\r\n        // Don't accidentally destroy your own shit\r\n        if (!room || room.my || room.reservedByMe) {\r\n            return;\r\n        }\r\n        if (swarm.anchor.roomName != roomName) {\r\n            log.warning(`Swarm is not in target room!`);\r\n            return;\r\n        }\r\n        // // Look for any unprotected structures\r\n        // let unprotectedRepairables = _.filter(room.repairables, s => {\r\n        // \tlet rampart = s.pos.lookForStructure(STRUCTURE_RAMPART);\r\n        // \treturn !rampart || rampart.hits < 10000;\r\n        // });\r\n        // let approach = _.map(unprotectedRepairables, structure => {\r\n        // \treturn {pos: structure.pos, range: 0};\r\n        // }) as PathFinderGoal[];\r\n        // if (room.barriers.length == 0 && unprotectedRepairables.length == 0) return; // if there's nothing in the room\r\n        //\r\n        // // Try to find a reachable unprotected structure\r\n        // if (approach.length > 0) {\r\n        // \tlet ret = PathFinder.search(swarm.anchor, approach, {\r\n        // \t\tmaxRooms    : 1,\r\n        // \t\tmaxOps      : 2000,\r\n        // \t\troomCallback: roomName => {\r\n        // \t\t\tif (roomName != room.name) return false;\r\n        // \t\t\tlet matrix = Pathing.getSwarmTerrainMatrix(roomName, swarm.width, swarm.height).clone();\r\n        // \t\t\tfor (let barrier of room.barriers) {\r\n        // \t\t\t\tlet setPositions = Pathing.getPosWindow(barrier.pos, -swarm.width, -swarm.height);\r\n        // \t\t\t\tfor (let pos of setPositions) {\r\n        // \t\t\t\t\tmatrix.set(pos.x, pos.y, 0xff);\r\n        // \t\t\t\t}\r\n        // \t\t\t}\r\n        // \t\t\treturn matrix;\r\n        // \t\t},\r\n        // \t});\r\n        // \tlet targetPos = _.last(ret.path);\r\n        // \tif (!ret.incomplete && targetPos) {\r\n        // \t\tlet targetStructure = _.first(_.filter(targetPos.lookFor(LOOK_STRUCTURES), s => {\r\n        // \t\t\treturn s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;\r\n        // \t\t}));\r\n        // \t\tif (targetStructure) {\r\n        // \t\t\tlog.debug(`Found unprotected structure target @ ${targetPos.print}`);\r\n        // \t\t\treturn targetStructure;\r\n        // \t\t}\r\n        // \t}\r\n        // }\r\n        // Determine a \"siege anchor\" for what you eventually want to destroy\r\n        let targets = room.spawns;\r\n        if (targets.length == 0)\r\n            targets = room.towers;\r\n        if (targets.length == 0)\r\n            targets = room.repairables;\r\n        if (targets.length == 0)\r\n            targets = room.barriers;\r\n        if (targets.length == 0)\r\n            targets = room.structures;\r\n        if (targets.length == 0)\r\n            return;\r\n        // Recalculate approach targets\r\n        const approach = _.map(targets, s => {\r\n            return { pos: s.pos, range: 0 };\r\n        });\r\n        const maxWallHits = _.max(_.map(room.barriers, b => b.hits)) || 0;\r\n        // Compute path with wall position costs weighted by fraction of highest wall\r\n        const ret = PathFinder.search(swarm.anchor, approach, {\r\n            maxRooms: 1,\r\n            plainCost: 1,\r\n            swampCost: 2,\r\n            roomCallback: rn => {\r\n                if (rn != roomName)\r\n                    return false;\r\n                const matrix = Pathing.getSwarmTerrainMatrix(roomName, swarm.width, swarm.height).clone();\r\n                for (const barrier of room.barriers) {\r\n                    const randomFactor = Math.min(Math.round(randomness * Math.random()), 100);\r\n                    const cost = 100 + Math.round((barrier.hits / maxWallHits) * 100) + randomFactor;\r\n                    const setPositions = Pathing.getPosWindow(barrier.pos, -swarm.width, -swarm.height);\r\n                    for (const pos of setPositions) {\r\n                        matrix.set(pos.x, pos.y, Math.max(cost, matrix.get(pos.x, pos.y)));\r\n                    }\r\n                }\r\n                if (displayCostMatrix) {\r\n                    Visualizer.displayCostMatrix(matrix, roomName);\r\n                }\r\n                return matrix;\r\n            },\r\n        });\r\n        // Target the first non-road, non-container structure you find along the path or neighboring positions\r\n        for (const pos of ret.path) {\r\n            log.debug(`Searching path ${pos.print}...`);\r\n            const searchPositions = Pathing.getPosWindow(pos, swarm.width, swarm.height); // not -1*width\r\n            for (const searchPos of searchPositions) {\r\n                const targetStructure = _.first(_.filter(searchPos.lookFor(LOOK_STRUCTURES), s => {\r\n                    return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;\r\n                }));\r\n                if (targetStructure) {\r\n                    log.debug(`Targeting structure @ ${targetStructure.pos.print}`);\r\n                    return targetStructure;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nCombatTargeting = tslib_1.__decorate([\r\n    profile\r\n], CombatTargeting);\r\nexport { CombatTargeting };\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/intel/CombatIntel.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/priorities/priorities_structures.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/visuals/Visualizer.ts","C:/git/Overmind/src/zerg/Swarm.ts","C:/git/Overmind/src/zerg/Zerg.ts"]}
