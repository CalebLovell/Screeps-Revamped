{"code":"import * as tslib_1 from \"tslib\";\r\nimport { log } from '../console/log';\r\nimport { bodyCost } from '../creepSetups/CreepSetup';\r\nimport { Mem } from '../memory/Memory';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { profile } from '../profiler/decorator';\r\nimport { getAllColonyRooms, getCacheExpiration, minBy, onPublicServer } from '../utilities/utils';\r\nconst SpawnGroupMemoryDefaults = {\r\n    colonies: [],\r\n    distances: {},\r\n    routes: {},\r\n    // paths    : {},\r\n    expiration: 0,\r\n};\r\nconst MAX_LINEAR_DISTANCE = 10; // maximum linear distance to search for ANY spawn group\r\nconst MAX_PATH_DISTANCE = 600; // maximum path distance to consider for ANY spawn group\r\nconst DEFAULT_RECACHE_TIME = onPublicServer() ? 2000 : 1000;\r\nconst defaultSettings = {\r\n    maxPathDistance: 400,\r\n    requiredRCL: 7,\r\n    flexibleEnergy: true,\r\n};\r\n/**\r\n * SpawnGroup provides a decentralized method of spawning creeps from multiple nearby colonies. Use cases include\r\n * incubation, spawning large combat groups, etc.\r\n */\r\nlet SpawnGroup = class SpawnGroup {\r\n    constructor(initializer, settings = {}) {\r\n        this.roomName = initializer.pos.roomName;\r\n        // this.room = initializer.room;\r\n        if (!Memory.rooms[this.roomName]) {\r\n            Memory.rooms[this.roomName] = {};\r\n        }\r\n        this.memory = Mem.wrap(Memory.rooms[this.roomName], 'spawnGroup', SpawnGroupMemoryDefaults);\r\n        this.ref = initializer.ref + ':SG';\r\n        this.stats = {\r\n            avgDistance: (_.sum(this.memory.distances) / _.keys(this.memory.distances).length) || 100,\r\n        };\r\n        this.requests = [];\r\n        this.settings = _.defaults(settings, defaultSettings);\r\n        if (Game.time >= this.memory.expiration) {\r\n            this.recalculateColonies();\r\n        }\r\n        // Compute stats\r\n        this.colonyNames = _.filter(this.memory.colonies, roomName => this.memory.distances[roomName] <= this.settings.maxPathDistance &&\r\n            Game.rooms[roomName] && Game.rooms[roomName].my &&\r\n            Game.rooms[roomName].controller.level >= this.settings.requiredRCL);\r\n        if (this.colonyNames.length == 0) {\r\n            log.warning(`No colonies meet the requirements for SwarmGroup: ${this.ref}`);\r\n        }\r\n        this.energyCapacityAvailable = _.max(_.map(this.colonyNames, roomName => Game.rooms[roomName].energyCapacityAvailable));\r\n        Overmind.spawnGroups[this.ref] = this;\r\n    }\r\n    /**\r\n     * Refresh the state of the spawnGroup; called by the Overmind object.\r\n     */\r\n    refresh() {\r\n        this.memory = Mem.wrap(Memory.rooms[this.roomName], 'spawnGroup', SpawnGroupMemoryDefaults);\r\n        this.requests = [];\r\n    }\r\n    recalculateColonies() {\r\n        const colonyRoomsInRange = _.filter(getAllColonyRooms(), room => Game.map.getRoomLinearDistance(room.name, this.roomName) <= MAX_LINEAR_DISTANCE);\r\n        const colonies = [];\r\n        const routes = {};\r\n        // let paths = {} as { [colonyName: string]: { startPos: RoomPosition, path: string[] } };\r\n        const distances = {};\r\n        for (const colonyRoom of colonyRoomsInRange) {\r\n            const spawn = colonyRoom.spawns[0];\r\n            if (spawn) {\r\n                const route = Pathing.findRoute(colonyRoom.name, this.roomName);\r\n                const path = Pathing.findPathToRoom(spawn.pos, this.roomName, { route: route });\r\n                if (route && !path.incomplete && path.path.length <= MAX_PATH_DISTANCE) {\r\n                    colonies.push(colonyRoom.name);\r\n                    routes[colonyRoom.name] = route;\r\n                    // paths[room.name] = path.path;\r\n                    distances[colonyRoom.name] = path.path.length;\r\n                }\r\n            }\r\n        }\r\n        this.memory.colonies = colonies;\r\n        this.memory.routes = routes;\r\n        // this.memory.paths = TODO\r\n        this.memory.distances = distances;\r\n        this.memory.expiration = getCacheExpiration(DEFAULT_RECACHE_TIME, 25);\r\n    }\r\n    enqueue(request) {\r\n        this.requests.push(request);\r\n    }\r\n    /**\r\n     * SpawnGroup.init() must be called AFTER all hatcheries have been initialized\r\n     */\r\n    init() {\r\n        // Most initialization needs to be done at init phase because colonies are still being constructed earlier\r\n        const colonies = _.compact(_.map(this.colonyNames, name => Overmind.colonies[name]));\r\n        const hatcheries = _.compact(_.map(colonies, colony => colony.hatchery));\r\n        const distanceTo = (hatchery) => this.memory.distances[hatchery.pos.roomName] + 25;\r\n        // Enqueue all requests to the hatchery with least expected wait time that can spawn full-size creep\r\n        for (const request of this.requests) {\r\n            const maxCost = bodyCost(request.setup.generateBody(this.energyCapacityAvailable));\r\n            const okHatcheries = _.filter(hatcheries, hatchery => hatchery.room.energyCapacityAvailable >= maxCost);\r\n            // || this.settings.flexibleEnergy);\r\n            const bestHatchery = minBy(okHatcheries, hatchery => hatchery.nextAvailability + distanceTo(hatchery));\r\n            if (bestHatchery) {\r\n                bestHatchery.enqueue(request);\r\n            }\r\n            else {\r\n                log.warning(`Could not enqueue creep ${request.setup.role} in ${this.roomName}, ` +\r\n                    `no hatchery with ${maxCost} energy capacity`);\r\n            }\r\n        }\r\n    }\r\n    run() {\r\n        // Nothing goes here\r\n    }\r\n};\r\nSpawnGroup = tslib_1.__decorate([\r\n    profile\r\n], SpawnGroup);\r\nexport { SpawnGroup };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/creepSetups/CreepSetup.ts","C:/git/Overmind/src/hiveClusters/hatchery.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/utils.ts"]}
