{"code":"import * as tslib_1 from \"tslib\";\r\nvar SporeCrawler_1;\r\nimport { $ } from '../caching/GlobalCache';\r\nimport { log } from '../console/log';\r\nimport { TERMINAL_STATE_REBUILD } from '../directives/terminalState/terminalState_rebuild';\r\nimport { CombatIntel } from '../intel/CombatIntel';\r\nimport { WorkerOverlord } from '../overlords/core/worker';\r\nimport { profile } from '../profiler/decorator';\r\nimport { CombatTargeting } from '../targeting/CombatTargeting';\r\nimport { HiveCluster } from './_HiveCluster';\r\n/**\r\n * The spore crawler is the hive cluster for controlling towers within a room\r\n */\r\nlet SporeCrawler = SporeCrawler_1 = class SporeCrawler extends HiveCluster {\r\n    constructor(colony, tower) {\r\n        super(colony, tower, 'sporeCrawler');\r\n        // Register structure components\r\n        this.towers = this.colony.towers;\r\n    }\r\n    refresh() {\r\n        $.refreshRoom(this);\r\n        $.refresh(this, 'towers');\r\n    }\r\n    spawnMoarOverlords() {\r\n    }\r\n    get memory() {\r\n        return undefined;\r\n    }\r\n    registerEnergyRequests() {\r\n        // Request energy from transporters if below request threshold\r\n        for (const tower of this.towers) {\r\n            if (tower.energy < SporeCrawler_1.settings.requestThreshold) {\r\n                const multiplier = tower.energy < SporeCrawler_1.settings.criticalEnergyThreshold ? 2 : 1;\r\n                const dAmountdt = this.room.hostiles.length > 0 ? 10 : 0;\r\n                this.colony.logisticsNetwork.requestInput(tower, { multiplier: multiplier, dAmountdt: dAmountdt });\r\n            }\r\n        }\r\n    }\r\n    init() {\r\n        this.registerEnergyRequests();\r\n    }\r\n    attack(target) {\r\n        for (const tower of this.towers) {\r\n            const result = tower.attack(target);\r\n            if (result == OK) {\r\n                if (target.hitsPredicted == undefined)\r\n                    target.hitsPredicted = target.hits;\r\n                target.hitsPredicted -= CombatIntel.singleTowerDamage(target.pos.getRangeTo(tower));\r\n            }\r\n        }\r\n    }\r\n    // private attackNearestEnemy(prioritizeHealers = false) {\r\n    // \tif (prioritizeHealers) {\r\n    // \t\tlet healers = _.filter(this.room.hostiles, creep => creep.getActiveBodyparts(HEAL) > 0);\r\n    // \t\tif (healers.length > 0) {\r\n    // \t\t\tlet healer = this.pos.findClosestByRange(healers);\r\n    // \t\t\tif (healer) {\r\n    // \t\t\t\treturn this.tower.attack(healer);\r\n    // \t\t\t}\r\n    // \t\t}\r\n    // \t}\r\n    // \tlet closestHostile = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS);\r\n    // \tif (closestHostile) {\r\n    // \t\treturn this.tower.attack(closestHostile);\r\n    // \t}\r\n    // }\r\n    // private healNearestAlly() {\r\n    // \tvar closestDamagedAlly = this.pos.findClosestByRange(FIND_MY_CREEPS, {\r\n    // \t\tfilter: (c: Creep) => c.hits < c.hitsMax,\r\n    // \t});\r\n    // \tif (closestDamagedAlly) {\r\n    // \t\treturn this.tower.heal(closestDamagedAlly);\r\n    // \t}\r\n    // }\r\n    preventRampartDecay() {\r\n        if (this.colony.level < 7 && this.towers.length > 0) {\r\n            // expensive to check all rampart hits; only run in intermediate RCL\r\n            const dyingRamparts = _.filter(this.room.ramparts, rampart => rampart.hits < WorkerOverlord.settings.barrierHits.critical\r\n                && this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(rampart.pos));\r\n            if (dyingRamparts.length > 0) {\r\n                for (const tower of this.towers) {\r\n                    tower.repair(tower.pos.findClosestByRange(dyingRamparts));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // private repairNearestStructure() {\r\n    // \tvar closestDamagedStructure = this.pos.findClosestByRange(FIND_STRUCTURES, {\r\n    // \t\tfilter: (s: Structure) => s.hits < s.hitsMax &&\r\n    // \t\t\t\t\t\t\t\t  s.structureType != STRUCTURE_WALL &&\r\n    // \t\t\t\t\t\t\t\t  s.structureType != STRUCTURE_RAMPART,\r\n    // \t});\r\n    // \tif (closestDamagedStructure) {\r\n    // \t\treturn this.tower.repair(closestDamagedStructure);\r\n    // \t}\r\n    // }\r\n    run() {\r\n        if (this.room.hostiles.length > 0) {\r\n            const myDefenders = _.filter(this.room.creeps, creep => creep.getActiveBodyparts(ATTACK) > 1);\r\n            const myRangedDefenders = _.filter(this.room.creeps, creep => creep.getActiveBodyparts(RANGED_ATTACK) > 1);\r\n            const myCreepDamage = ATTACK_POWER * _.sum(myDefenders, creep => CombatIntel.getAttackPotential(creep)) +\r\n                RANGED_ATTACK_POWER * _.sum(myRangedDefenders, creep => CombatIntel.getRangedAttackPotential(creep));\r\n            const HEAL_FUDGE_FACTOR = 1.0;\r\n            const avgHealing = HEAL_FUDGE_FACTOR * CombatIntel.avgHostileHealingTo(this.room.hostiles);\r\n            let possibleTargets = _.filter(this.room.hostiles, hostile => {\r\n                // let healing = HEAL_FUDGE_FACTOR * CombatIntel.maxHostileHealingTo(hostile);\r\n                const damageTaken = CombatIntel.towerDamageAtPos(hostile.pos) + myCreepDamage;\r\n                const damageMultiplier = CombatIntel.minimumDamageTakenMultiplier(hostile);\r\n                return damageTaken * damageMultiplier > avgHealing;\r\n            });\r\n            // Only attack dancing targets (drain attack) which are far enough in rooms to be killed off by towers\r\n            possibleTargets = _.filter(possibleTargets, hostile => {\r\n                if (CombatIntel.isEdgeDancing(hostile)) {\r\n                    const netDPS = CombatIntel.towerDamageAtPos(hostile.pos) + myCreepDamage\r\n                        - (HEAL_FUDGE_FACTOR * CombatIntel.maxHostileHealingTo(hostile));\r\n                    const isKillable = netDPS * hostile.pos.rangeToEdge > hostile.hits;\r\n                    if (isKillable) {\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        // Shoot if they get close enough\r\n                        if (this.colony.bunker && this.colony.bunker.anchor &&\r\n                            hostile.pos.getRangeTo(this.colony.bunker.anchor) <= 6 + 2) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            });\r\n            const target = CombatTargeting.findBestCreepTargetForTowers(this.room, possibleTargets);\r\n            if (target) {\r\n                return this.attack(target);\r\n            }\r\n        }\r\n        const closestDamagedAlly = this.pos.findClosestByRange(_.filter(this.room.creeps, creep => creep.hits < creep.hitsMax));\r\n        if (closestDamagedAlly) {\r\n            for (const tower of this.towers) {\r\n                tower.heal(closestDamagedAlly);\r\n            }\r\n            return;\r\n        }\r\n        // Towers build nuke response ramparts\r\n        const nearbyNukeRamparts = _.filter(this.colony.overlords.work.nukeDefenseRamparts, rampart => this.pos.getRangeTo(rampart) <= TOWER_OPTIMAL_RANGE);\r\n        if (nearbyNukeRamparts.length > 0 && this.colony.terminal\r\n            && this.colony.terminalState != TERMINAL_STATE_REBUILD) {\r\n            const nukes = this.colony.room.find(FIND_NUKES);\r\n            const timeToImpact = _.min(_.map(nukes, nuke => nuke.timeToLand));\r\n            if (timeToImpact) {\r\n                const repairHitsRemaining = _.sum(_.values(this.colony.overlords.work.nukeDefenseHitsRemaining));\r\n                const hitsRepairedPerTick = this.towers.length * TOWER_POWER_REPAIR;\r\n                // Only repair using towers if it looks like you won't finish repairs in time\r\n                if (repairHitsRemaining > 0.9 * hitsRepairedPerTick * timeToImpact) {\r\n                    for (const tower of this.towers) {\r\n                        tower.repair(nearbyNukeRamparts[0]);\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                // Shouldn't get here\r\n                log.warning(`No time to impact! (Why?)`);\r\n            }\r\n        }\r\n        // Prevent rampart decay at early RCL\r\n        this.preventRampartDecay();\r\n    }\r\n    visuals() {\r\n    }\r\n};\r\nSporeCrawler.settings = {\r\n    requestThreshold: 500,\r\n    criticalEnergyThreshold: 250,\r\n};\r\nSporeCrawler = SporeCrawler_1 = tslib_1.__decorate([\r\n    profile\r\n], SporeCrawler);\r\nexport { SporeCrawler };\r\n","references":["C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/directives/terminalState/terminalState_rebuild.ts","C:/git/Overmind/src/intel/CombatIntel.ts","C:/git/Overmind/src/overlords/core/worker.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/targeting/CombatTargeting.ts","C:/git/Overmind/src/hiveClusters/_HiveCluster.ts"]}
