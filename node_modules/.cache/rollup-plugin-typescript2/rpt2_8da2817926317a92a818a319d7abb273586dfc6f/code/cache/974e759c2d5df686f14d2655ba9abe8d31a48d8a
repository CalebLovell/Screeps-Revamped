{"code":"import * as tslib_1 from \"tslib\";\r\nvar Pathing_1;\r\nimport { $ } from '../caching/GlobalCache';\r\nimport { log } from '../console/log';\r\nimport { hasPos } from '../declarations/typeGuards';\r\nimport { profile } from '../profiler/decorator';\r\nimport { Cartographer, ROOMTYPE_ALLEY, ROOMTYPE_SOURCEKEEPER } from '../utilities/Cartographer';\r\nimport { Visualizer } from '../visuals/Visualizer';\r\nimport { normalizePos } from './helpers';\r\nconst DEFAULT_MAXOPS = 20000; // Default timeout for pathfinding\r\nconst CREEP_COST = 0xfe;\r\nexport const MatrixTypes = {\r\n    direct: 'dir',\r\n    default: 'def',\r\n    sk: 'sk',\r\n    obstacle: 'obst',\r\n    preferRampart: 'preframp'\r\n};\r\n/**\r\n * Module for pathing-related operations.\r\n */\r\nlet Pathing = Pathing_1 = class Pathing {\r\n    // Room avoidance methods ==========================================================================================\r\n    /**\r\n     * Check if the room should be avoiding when calculating routes\r\n     */\r\n    static shouldAvoid(roomName) {\r\n        return Memory.rooms[roomName] && Memory.rooms[roomName][\"a\" /* AVOID */];\r\n    }\r\n    /**\r\n     * Update memory on whether a room should be avoided based on controller owner\r\n     */\r\n    static updateRoomStatus(room) {\r\n        if (!room) {\r\n            return;\r\n        }\r\n        if (room.controller) {\r\n            if (room.controller.owner && !room.controller.my && room.towers.length > 0) {\r\n                room.memory[\"a\" /* AVOID */] = true;\r\n            }\r\n            else {\r\n                delete room.memory[\"a\" /* AVOID */];\r\n                // if (room.memory.expansionData == false) delete room.memory.expansionData;\r\n            }\r\n        }\r\n    }\r\n    // Pathfinding and room callback methods ===========================================================================\r\n    /**\r\n     * Find a path from origin to destination\r\n     */\r\n    static findPath(origin, destination, options = {}) {\r\n        _.defaults(options, {\r\n            ignoreCreeps: true,\r\n            maxOps: DEFAULT_MAXOPS,\r\n            range: 1,\r\n            terrainCosts: { plainCost: 1, swampCost: 5 },\r\n        });\r\n        if (options.movingTarget) {\r\n            options.range = 0;\r\n        }\r\n        // check to see whether findRoute should be used\r\n        const roomDistance = Game.map.getRoomLinearDistance(origin.roomName, destination.roomName);\r\n        let allowedRooms = options.route;\r\n        if (!allowedRooms && (options.useFindRoute || (options.useFindRoute === undefined && roomDistance > 2))) {\r\n            allowedRooms = this.findRoute(origin.roomName, destination.roomName, options);\r\n        }\r\n        if (options.direct) {\r\n            options.terrainCosts = { plainCost: 1, swampCost: 1 };\r\n        }\r\n        const callback = (roomName) => this.roomCallback(roomName, origin, destination, allowedRooms, options);\r\n        let ret = PathFinder.search(origin, { pos: destination, range: options.range }, {\r\n            maxOps: options.maxOps,\r\n            maxRooms: options.maxRooms,\r\n            plainCost: options.terrainCosts.plainCost,\r\n            swampCost: options.terrainCosts.swampCost,\r\n            roomCallback: callback,\r\n        });\r\n        if (ret.incomplete && options.ensurePath) {\r\n            if (options.useFindRoute == undefined) {\r\n                // handle case where pathfinder failed at a short distance due to not using findRoute\r\n                // can happen for situations where the creep would have to take an uncommonly indirect path\r\n                // options.allowedRooms and options.routeCallback can also be used to handle this situation\r\n                if (roomDistance <= 2) {\r\n                    log.warning(`Movement: path failed without findroute. Origin: ${origin.print}, ` +\r\n                        `destination: ${destination.print}. Trying again with options.useFindRoute = true...`);\r\n                    options.useFindRoute = true;\r\n                    ret = this.findPath(origin, destination, options);\r\n                    log.warning(`Movement: second attempt was ${ret.incomplete ? 'not ' : ''}successful`);\r\n                    return ret;\r\n                }\r\n            }\r\n            else {\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    /**\r\n     * Find a path from origin to destination\r\n     */\r\n    static findSwarmPath(origin, destination, width, height, options = {}) {\r\n        _.defaults(options, {\r\n            ignoreCreeps: true,\r\n            maxOps: 2 * DEFAULT_MAXOPS,\r\n            range: 1,\r\n        });\r\n        // Make copies of the destination offset for where anchor could be\r\n        const destinations = this.getPosWindow(destination, -width, -height);\r\n        const callback = (roomName) => this.swarmRoomCallback(roomName, width, height, options);\r\n        return PathFinder.search(origin, _.map(destinations, pos => ({ pos: pos, range: options.range })), {\r\n            maxOps: options.maxOps,\r\n            maxRooms: options.maxRooms,\r\n            plainCost: 1,\r\n            swampCost: 5,\r\n            roomCallback: callback,\r\n        });\r\n    }\r\n    /**\r\n     * Get a window of offset RoomPositions from an anchor position and a window width and height\r\n     */\r\n    static getPosWindow(anchor, width, height) {\r\n        const positions = [];\r\n        for (const dx of _.range(0, width, width < 0 ? -1 : 1)) {\r\n            for (const dy of _.range(0, height, height < 0 ? -1 : 1)) {\r\n                positions.push(anchor.getOffsetPos(dx, dy));\r\n            }\r\n        }\r\n        return positions;\r\n    }\r\n    /**\r\n     * Returns the shortest path from start to end position, regardless of (passable) terrain\r\n     */\r\n    static findShortestPath(startPos, endPos, options = {}) {\r\n        _.defaults(options, {\r\n            ignoreCreeps: true,\r\n            range: 1,\r\n            direct: true,\r\n        });\r\n        const ret = this.findPath(startPos, endPos, options);\r\n        if (ret.incomplete)\r\n            log.alert(`Pathing: incomplete path from ${startPos.print} to ${endPos.print}!`);\r\n        return ret;\r\n    }\r\n    /**\r\n     * Returns the shortest path from start to end position, regardless of (passable) terrain\r\n     */\r\n    static findPathToRoom(startPos, roomName, options = {}) {\r\n        options.range = 23;\r\n        const ret = this.findPath(startPos, new RoomPosition(25, 25, roomName), options);\r\n        if (ret.incomplete)\r\n            log.alert(`Pathing: incomplete path from ${startPos.print} to ${roomName}!`);\r\n        return ret;\r\n    }\r\n    /**\r\n     * Default room callback, which automatically determines the most appropriate callback method to use\r\n     */\r\n    static roomCallback(roomName, origin, destination, allowedRooms, options) {\r\n        if (allowedRooms && !allowedRooms[roomName]) {\r\n            return false;\r\n        }\r\n        if (!options.allowHostile && this.shouldAvoid(roomName)\r\n            && roomName != origin.roomName && roomName != destination.roomName) {\r\n            return false;\r\n        }\r\n        const room = Game.rooms[roomName];\r\n        if (room) {\r\n            const matrix = this.getCostMatrix(room, options, false);\r\n            // Modify cost matrix if needed\r\n            if (options.modifyRoomCallback) {\r\n                return options.modifyRoomCallback(room, matrix.clone());\r\n            }\r\n            else {\r\n                return matrix;\r\n            }\r\n        }\r\n        else { // have no vision\r\n            return this.getCostMatrixForInvisibleRoom(roomName, options);\r\n        }\r\n    }\r\n    static swarmRoomCallback(roomName, width, height, options) {\r\n        const room = Game.rooms[roomName];\r\n        let matrix;\r\n        if (room && !options.ignoreStructures) {\r\n            matrix = this.getSwarmDefaultMatrix(room, width, height, options, false);\r\n        }\r\n        else {\r\n            matrix = this.getSwarmTerrainMatrix(roomName, width, height, options.exitCost);\r\n        }\r\n        if (options.displayCostMatrix) {\r\n            Visualizer.displayCostMatrix(matrix, roomName);\r\n        }\r\n        return matrix;\r\n    }\r\n    static kitingRoomCallback(roomName) {\r\n        const room = Game.rooms[roomName];\r\n        if (room) {\r\n            return Pathing_1.getKitingMatrix(room);\r\n        }\r\n        else { // have no vision\r\n            return true;\r\n        }\r\n    }\r\n    /**\r\n     * Get a kiting path within a room\r\n     */\r\n    static findKitingPath(creepPos, fleeFrom, options = {}) {\r\n        _.defaults(options, {\r\n            fleeRange: 5,\r\n            terrainCosts: { plainCost: 1, swampCost: 5 },\r\n        });\r\n        const fleeFromPos = _.map(fleeFrom, flee => normalizePos(flee));\r\n        const avoidGoals = _.map(fleeFromPos, pos => {\r\n            return { pos: pos, range: options.fleeRange };\r\n        });\r\n        return PathFinder.search(creepPos, avoidGoals, {\r\n            plainCost: options.terrainCosts.plainCost,\r\n            swampCost: options.terrainCosts.swampCost,\r\n            flee: true,\r\n            roomCallback: Pathing_1.kitingRoomCallback,\r\n            maxRooms: 1\r\n        });\r\n    }\r\n    /**\r\n     * Get a flee path possibly leaving the room; generally called further in advance of kitingPath\r\n     */\r\n    static findFleePath(creepPos, fleeFrom, options = {}) {\r\n        _.defaults(options, {\r\n            terrainCosts: { plainCost: 1, swampCost: 5 },\r\n        });\r\n        if (options.fleeRange == undefined)\r\n            options.fleeRange = options.terrainCosts.plainCost > 1 ? 20 : 10;\r\n        const fleeFromPos = _.map(fleeFrom, flee => normalizePos(flee));\r\n        const avoidGoals = _.map(fleeFromPos, pos => {\r\n            return { pos: pos, range: options.fleeRange };\r\n        });\r\n        const callback = (roomName) => {\r\n            if (!options.allowHostile && this.shouldAvoid(roomName) && roomName != creepPos.roomName) {\r\n                return false;\r\n            }\r\n            const room = Game.rooms[roomName];\r\n            if (room) {\r\n                const matrix = this.getCostMatrix(room, options, false);\r\n                // Modify cost matrix if needed\r\n                if (options.modifyRoomCallback) {\r\n                    return options.modifyRoomCallback(room, matrix.clone());\r\n                }\r\n                else {\r\n                    return matrix;\r\n                }\r\n            }\r\n            else { // have no vision\r\n                return true;\r\n            }\r\n        };\r\n        return PathFinder.search(creepPos, avoidGoals, {\r\n            plainCost: options.terrainCosts.plainCost,\r\n            swampCost: options.terrainCosts.swampCost,\r\n            flee: true,\r\n            roomCallback: callback,\r\n        });\r\n    }\r\n    // Cost matrix retrieval functions =================================================================================\r\n    /**\r\n     * Get a cloned copy of the cost matrix for a room with specified options\r\n     */\r\n    static getCostMatrix(room, options, clone = true) {\r\n        let matrix;\r\n        if (options.ignoreCreeps == false) {\r\n            matrix = this.getCreepMatrix(room);\r\n        }\r\n        else if (options.avoidSK) {\r\n            matrix = this.getSkMatrix(room);\r\n        }\r\n        else if (options.ignoreStructures) {\r\n            matrix = new PathFinder.CostMatrix();\r\n        }\r\n        else if (options.direct) {\r\n            matrix = this.getDirectMatrix(room);\r\n        }\r\n        else {\r\n            matrix = this.getDefaultMatrix(room);\r\n        }\r\n        // Register other obstacles\r\n        if (options.obstacles && options.obstacles.length > 0) {\r\n            matrix = matrix.clone();\r\n            for (const obstacle of options.obstacles) {\r\n                if (obstacle && obstacle.roomName == room.name) {\r\n                    matrix.set(obstacle.x, obstacle.y, 0xff);\r\n                }\r\n            }\r\n        }\r\n        if (clone) {\r\n            matrix = matrix.clone();\r\n        }\r\n        return matrix;\r\n    }\r\n    static getSwarmDefaultMatrix(room, width, height, options = {}, clone = true) {\r\n        let matrix = $.costMatrix(room.name, `swarm${width}x${height}`, () => {\r\n            const mat = this.getTerrainMatrix(room.name).clone();\r\n            this.blockImpassibleStructures(mat, room);\r\n            this.setExitCosts(mat, room.name, options.exitCost || 10);\r\n            this.applyMovingMaximum(mat, width, height);\r\n            return mat;\r\n        }, 25);\r\n        if (options.ignoreCreeps == false) {\r\n            matrix = matrix.clone();\r\n            this.blockHostileCreeps(matrix, room); // todo: need to smear again?\r\n        }\r\n        if (clone) {\r\n            matrix = matrix.clone();\r\n        }\r\n        return matrix;\r\n    }\r\n    static getCostMatrixForInvisibleRoom(roomName, options, clone = true) {\r\n        let matrix;\r\n        if (options.avoidSK) {\r\n            matrix = $.costMatrixRecall(roomName, MatrixTypes.sk);\r\n        }\r\n        else if (options.direct) {\r\n            matrix = $.costMatrixRecall(roomName, MatrixTypes.direct);\r\n        }\r\n        else {\r\n            matrix = $.costMatrixRecall(roomName, MatrixTypes.default);\r\n        }\r\n        // Register other obstacles\r\n        if (matrix && options.obstacles && options.obstacles.length > 0) {\r\n            matrix = matrix.clone();\r\n            for (const obstacle of options.obstacles) {\r\n                if (obstacle && obstacle.roomName == roomName) {\r\n                    matrix.set(obstacle.x, obstacle.y, 0xff);\r\n                }\r\n            }\r\n        }\r\n        if (matrix && clone) {\r\n            matrix = matrix.clone();\r\n        }\r\n        return matrix || true;\r\n    }\r\n    // Cost matrix generation functions ================================================================================\r\n    /**\r\n     * Get a matrix of explicit terrain values for a room\r\n     */\r\n    static getTerrainMatrix(roomName, costs = { plainCost: 1, swampCost: 5 }) {\r\n        return $.costMatrix(roomName, `terrain:${costs.plainCost}:${costs.swampCost}`, () => {\r\n            const matrix = new PathFinder.CostMatrix();\r\n            const terrain = Game.map.getRoomTerrain(roomName);\r\n            for (let y = 0; y < 50; ++y) {\r\n                for (let x = 0; x < 50; ++x) {\r\n                    switch (terrain.get(x, y)) {\r\n                        case TERRAIN_MASK_SWAMP:\r\n                            matrix.set(x, y, costs.swampCost);\r\n                            break;\r\n                        case TERRAIN_MASK_WALL:\r\n                            matrix.set(x, y, 0xff);\r\n                            break;\r\n                        default: // plain\r\n                            matrix.set(x, y, costs.plainCost);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            return matrix;\r\n        }, 10000);\r\n    }\r\n    /**\r\n     * Get a cloned copy of the cost matrix for a room with specified options\r\n     */\r\n    static getSwarmTerrainMatrix(roomName, width, height, exitCost = 10) {\r\n        const matrix = $.costMatrix(roomName, `swarmTerrain${width}x${height}EC${exitCost}`, () => {\r\n            const mat = this.getTerrainMatrix(roomName).clone();\r\n            this.setExitCosts(mat, roomName, exitCost);\r\n            this.applyMovingMaximum(mat, width, height);\r\n            return mat;\r\n        }, 10000);\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Default matrix for a room, setting impassable structures and constructionSites to impassible\r\n     */\r\n    static getDefaultMatrix(room) {\r\n        return $.costMatrix(room.name, MatrixTypes.default, () => {\r\n            const matrix = new PathFinder.CostMatrix();\r\n            // Set passability of structure positions\r\n            const impassibleStructures = [];\r\n            _.forEach(room.find(FIND_STRUCTURES), (s) => {\r\n                if (s.structureType == STRUCTURE_ROAD) {\r\n                    matrix.set(s.pos.x, s.pos.y, 1);\r\n                }\r\n                else if (!s.isWalkable) {\r\n                    impassibleStructures.push(s);\r\n                }\r\n            });\r\n            _.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));\r\n            const portals = _.filter(impassibleStructures, s => s.structureType == STRUCTURE_PORTAL);\r\n            _.forEach(portals, p => matrix.set(p.pos.x, p.pos.y, 0xfe));\r\n            // Set passability of construction sites\r\n            _.forEach(room.find(FIND_CONSTRUCTION_SITES), (site) => {\r\n                if (site.my && !site.isWalkable) {\r\n                    matrix.set(site.pos.x, site.pos.y, 0xff);\r\n                }\r\n            });\r\n            return matrix;\r\n        });\r\n    }\r\n    /**\r\n     * Default matrix for a room, setting impassable structures and constructionSites to impassible, ignoring roads\r\n     */\r\n    static getDirectMatrix(room) {\r\n        return $.costMatrix(room.name, MatrixTypes.direct, () => {\r\n            const matrix = new PathFinder.CostMatrix();\r\n            // Set passability of structure positions\r\n            const impassibleStructures = [];\r\n            _.forEach(room.find(FIND_STRUCTURES), (s) => {\r\n                if (!s.isWalkable) {\r\n                    impassibleStructures.push(s);\r\n                }\r\n            });\r\n            _.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));\r\n            const portals = _.filter(impassibleStructures, s => s.structureType == STRUCTURE_PORTAL);\r\n            _.forEach(portals, p => matrix.set(p.pos.x, p.pos.y, 0xfe));\r\n            // Set passability of construction sites\r\n            _.forEach(room.find(FIND_MY_CONSTRUCTION_SITES), (site) => {\r\n                if (!site.isWalkable) {\r\n                    matrix.set(site.pos.x, site.pos.y, 0xff);\r\n                }\r\n            });\r\n            return matrix;\r\n        });\r\n    }\r\n    /**\r\n     * Avoids creeps in a room\r\n     */\r\n    static getCreepMatrix(room, fromMatrix) {\r\n        if (room._creepMatrix) {\r\n            return room._creepMatrix;\r\n        }\r\n        const matrix = this.getDefaultMatrix(room).clone();\r\n        _.forEach(room.find(FIND_CREEPS), c => matrix.set(c.pos.x, c.pos.y, CREEP_COST)); // don't block off entirely\r\n        room._creepMatrix = matrix;\r\n        return room._creepMatrix;\r\n    }\r\n    /**\r\n     * Kites around hostile creeps in a room\r\n     */\r\n    static getKitingMatrix(room) {\r\n        if (room._kitingMatrix) {\r\n            return room._kitingMatrix;\r\n        }\r\n        const matrix = this.getCreepMatrix(room).clone();\r\n        const avoidCreeps = _.filter(room.hostiles, c => c.getActiveBodyparts(ATTACK) > 0 || c.getActiveBodyparts(RANGED_ATTACK) > 0);\r\n        // || c.getActiveBodyparts(HEAL) > 0);\r\n        _.forEach(avoidCreeps, avoidCreep => {\r\n            let cost;\r\n            for (let dx = -3; dx <= 3; dx++) {\r\n                for (let dy = -3; dy <= 3; dy++) {\r\n                    cost = matrix.get(avoidCreep.pos.x + dx, avoidCreep.pos.y + dy);\r\n                    cost += 40 - (10 * Math.max(Math.abs(dx), Math.abs(dy)));\r\n                    matrix.set(avoidCreep.pos.x + dx, avoidCreep.pos.y + dy, cost);\r\n                }\r\n            }\r\n        });\r\n        room._kitingMatrix = matrix;\r\n        return room._kitingMatrix;\r\n    }\r\n    /**\r\n     * Avoids source keepers in a room\r\n     */\r\n    static getSkMatrix(room) {\r\n        if (Cartographer.roomType(room.name) != ROOMTYPE_SOURCEKEEPER) {\r\n            return this.getDefaultMatrix(room);\r\n        }\r\n        return $.costMatrix(room.name, MatrixTypes.sk, () => {\r\n            const matrix = this.getDefaultMatrix(room).clone();\r\n            const avoidRange = 6;\r\n            _.forEach(room.keeperLairs, lair => {\r\n                for (let dx = -avoidRange; dx <= avoidRange; dx++) {\r\n                    for (let dy = -avoidRange; dy <= avoidRange; dy++) {\r\n                        matrix.set(lair.pos.x + dx, lair.pos.y + dy, 0xfe);\r\n                    }\r\n                }\r\n            });\r\n            return matrix;\r\n        });\r\n    }\r\n    // /* Avoids source keepers in a room */\r\n    // private static getInvisibleSkMatrix(roomName: string): CostMatrix {\r\n    // \tlet matrix = new PathFinder.CostMatrix();\r\n    // \tif (Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER) {\r\n    // \t\tif (Memory.rooms[roomName] && Memory.rooms[roomName].SKlairs != undefined) {\r\n    //\r\n    // \t\t\tconst avoidRange = 5;\r\n    // \t\t\tconst lairs: RoomPosition[] = _.map(Memory.rooms[roomName].SKlairs!,\r\n    // \t\t\t\t\t\t\t\t\t\t\t\tsaved => derefCoords(saved.c, roomName));\r\n    // \t\t\t_.forEach(lairs, lair => {\r\n    // \t\t\t\tfor (let dx = -avoidRange; dx <= avoidRange; dx++) {\r\n    // \t\t\t\t\tfor (let dy = -avoidRange; dy <= avoidRange; dy++) {\r\n    // \t\t\t\t\t\tmatrix.set(lair.x + dx, lair.y + dy, 0xff);\r\n    // \t\t\t\t\t}\r\n    // \t\t\t\t}\r\n    // \t\t\t});\r\n    // \t\t}\r\n    // \t}\r\n    // \treturn matrix;\r\n    // }\r\n    // In-place CostMatrix manipulation routines =======================================================================\r\n    /**\r\n     * Sets impassible structure positions to 0xff\r\n     */\r\n    static blockImpassibleStructures(matrix, room) {\r\n        _.forEach(room.find(FIND_STRUCTURES), (s) => {\r\n            if (!s.isWalkable) {\r\n                if (s.structureType == STRUCTURE_PORTAL) {\r\n                    matrix.set(s.pos.x, s.pos.y, 0xfe);\r\n                }\r\n                else {\r\n                    matrix.set(s.pos.x, s.pos.y, 0xff);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Sets all creep positions to impassible\r\n     */\r\n    static blockMyCreeps(matrix, room, creeps) {\r\n        const blockCreeps = creeps || room.creeps;\r\n        const blockPositions = _.map(blockCreeps, creep => Overmind.zerg[creep.name] ? Overmind.zerg[creep.name].nextPos\r\n            : creep.pos);\r\n        _.forEach(blockPositions, pos => {\r\n            matrix.set(pos.x, pos.y, CREEP_COST);\r\n        });\r\n    }\r\n    /**\r\n     * Sets hostile creep positions to impassible\r\n     */\r\n    static blockHostileCreeps(matrix, room) {\r\n        _.forEach(room.hostiles, hostile => {\r\n            matrix.set(hostile.pos.x, hostile.pos.y, CREEP_COST);\r\n        });\r\n    }\r\n    /**\r\n     * Sets all creep positions to impassible\r\n     */\r\n    static blockAllCreeps(matrix, room) {\r\n        _.forEach(room.find(FIND_CREEPS), creep => {\r\n            matrix.set(creep.pos.x, creep.pos.y, CREEP_COST);\r\n        });\r\n    }\r\n    /**\r\n     * Sets road positions to 1 if cost is less than 0xfe\r\n     */\r\n    static preferRoads(matrix, room) {\r\n        _.forEach(room.roads, road => {\r\n            if (matrix.get(road.pos.x, road.pos.y) < 0xfe) {\r\n                matrix.set(road.pos.x, road.pos.y, 1);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Sets walkable rampart positions to 1 if cost is less than 0xfe\r\n     */\r\n    static preferRamparts(matrix, room) {\r\n        _.forEach(room.walkableRamparts, rampart => {\r\n            if (matrix.get(rampart.pos.x, rampart.pos.y) < 0xfe) {\r\n                matrix.set(rampart.pos.x, rampart.pos.y, 1);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Sets walkable rampart positions to 1, everything else is blocked\r\n     */\r\n    static blockNonRamparts(matrix, room) {\r\n        for (let y = 0; y < 50; ++y) {\r\n            for (let x = 0; x < 50; ++x) {\r\n                matrix.set(x, y, 0xff);\r\n            }\r\n        }\r\n        _.forEach(room.walkableRamparts, rampart => {\r\n            matrix.set(rampart.pos.x, rampart.pos.y, 1);\r\n        });\r\n    }\r\n    /**\r\n     * Explicitly blocks off walls for a room\r\n     */\r\n    static blockImpassibleTerrain(matrix, roomName) {\r\n        const terrain = Game.map.getRoomTerrain(roomName);\r\n        for (let y = 0; y < 50; ++y) {\r\n            for (let x = 0; x < 50; ++x) {\r\n                if (terrain.get(x, y) === TERRAIN_MASK_WALL) {\r\n                    matrix.set(x, y, 0xff);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Transform a CostMatrix such that the cost at each point is transformed to the max of costs in a width x height\r\n     * window (indexed from upper left corner). This requires that terrain be explicitly specified in the matrix!\r\n     */\r\n    static applyMovingMaximum(matrix, width, height) {\r\n        // Since we're moving in increasing order of x, y, we don't need to clone the matrix\r\n        let x, y, dx, dy;\r\n        let maxCost, cost;\r\n        for (x = 0; x <= 50 - width; x++) {\r\n            for (y = 0; y <= 50 - height; y++) {\r\n                maxCost = matrix.get(x, y);\r\n                for (dx = 0; dx <= width - 1; dx++) {\r\n                    for (dy = 0; dy <= height - 1; dy++) {\r\n                        cost = matrix.get(x + dx, y + dy);\r\n                        if (cost > maxCost) {\r\n                            maxCost = cost;\r\n                        }\r\n                    }\r\n                }\r\n                matrix.set(x, y, maxCost);\r\n            }\r\n        }\r\n    }\r\n    static setCostsInRange(matrix, pos, range, cost = 30, add = false) {\r\n        pos = normalizePos(pos);\r\n        const terrain = Game.map.getRoomTerrain(pos.roomName);\r\n        for (let dx = -range; dx <= range; dx++) {\r\n            const x = pos.x + dx;\r\n            if (x < 0 || x > 49)\r\n                continue;\r\n            for (let dy = -range; dy <= range; dy++) {\r\n                const y = pos.y + dy;\r\n                if (y < 0 || y > 49)\r\n                    continue;\r\n                const posTerrain = terrain.get(x, y);\r\n                if (posTerrain === TERRAIN_MASK_WALL) {\r\n                    continue;\r\n                }\r\n                let currentCost = matrix.get(x, y);\r\n                if (currentCost === 0) {\r\n                    if (posTerrain === TERRAIN_MASK_SWAMP) {\r\n                        currentCost += 10;\r\n                    }\r\n                    else {\r\n                        currentCost += 2;\r\n                    }\r\n                }\r\n                if (currentCost >= 0xff || currentCost > cost)\r\n                    continue;\r\n                matrix.set(x, y, add ? Math.min(cost + currentCost, 200) : cost);\r\n            }\r\n        }\r\n    }\r\n    static blockExits(matrix, rangeToEdge = 0) {\r\n        for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {\r\n            for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {\r\n                matrix.set(x, y, 0xff);\r\n            }\r\n        }\r\n        for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {\r\n            for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {\r\n                matrix.set(x, y, 0xff);\r\n            }\r\n        }\r\n    }\r\n    static setExitCosts(matrix, roomName, cost, rangeToEdge = 0) {\r\n        const terrain = Game.map.getRoomTerrain(roomName);\r\n        for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {\r\n            for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {\r\n                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {\r\n                    matrix.set(x, y, cost);\r\n                }\r\n            }\r\n        }\r\n        for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {\r\n            for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {\r\n                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {\r\n                    matrix.set(x, y, cost);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static getExitPositions(roomName) {\r\n        const terrain = Game.map.getRoomTerrain(roomName);\r\n        const exitPositions = [];\r\n        for (let x = 0; x < 50; x += 49) {\r\n            for (let y = 0; y < 50; y++) {\r\n                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {\r\n                    exitPositions.push(new RoomPosition(x, y, roomName));\r\n                }\r\n            }\r\n        }\r\n        for (let x = 0; x < 50; x++) {\r\n            for (let y = 0; y < 50; y += 49) {\r\n                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {\r\n                    exitPositions.push(new RoomPosition(x, y, roomName));\r\n                }\r\n            }\r\n        }\r\n        return exitPositions;\r\n    }\r\n    /**\r\n     * Find a viable sequence of rooms to narrow down Pathfinder algorithm\r\n     */\r\n    static findRoute(origin, destination, options = {}) {\r\n        const linearDistance = Game.map.getRoomLinearDistance(origin, destination);\r\n        const restrictDistance = options.restrictDistance || linearDistance + 10;\r\n        const allowedRooms = { [origin]: true, [destination]: true };\r\n        // Determine whether to use highway bias\r\n        let highwayBias = 1;\r\n        if (options.preferHighway) {\r\n            highwayBias = 2.5;\r\n        }\r\n        else if (options.preferHighway != false) {\r\n            // if (linearDistance > 8) {\r\n            // \thighwayBias = 2.5;\r\n            // } else {\r\n            // \tlet oCoords = Cartographer.getRoomCoordinates(origin);\r\n            // \tlet dCoords = Cartographer.getRoomCoordinates(destination);\r\n            // \tif (_.any([oCoords.x, oCoords.y, dCoords.x, dCoords.y], z => z % 10 <= 1 || z % 10 >= 9)) {\r\n            // \t\thighwayBias = 2.5;\r\n            // \t}\r\n            // }\r\n        }\r\n        const ret = Game.map.findRoute(origin, destination, {\r\n            routeCallback: (roomName) => {\r\n                const rangeToRoom = Game.map.getRoomLinearDistance(origin, roomName);\r\n                if (rangeToRoom > restrictDistance) { // room is too far out of the way\r\n                    return Number.POSITIVE_INFINITY;\r\n                }\r\n                if (!options.allowHostile && this.shouldAvoid(roomName) &&\r\n                    roomName !== destination && roomName !== origin) { // room is marked as \"avoid\" in room memory\r\n                    return Number.POSITIVE_INFINITY;\r\n                }\r\n                if (options.preferHighway && Cartographer.roomType(roomName) == ROOMTYPE_ALLEY) {\r\n                    return 1;\r\n                }\r\n                return highwayBias;\r\n            },\r\n        });\r\n        if (!_.isArray(ret)) {\r\n            log.warning(`Movement: couldn't findRoute from ${origin} to ${destination}!`);\r\n        }\r\n        else {\r\n            for (const value of ret) {\r\n                allowedRooms[value.room] = true;\r\n            }\r\n            return allowedRooms;\r\n        }\r\n    }\r\n    /**\r\n     * Serialize a path as a string of move directions\r\n     */\r\n    static serializePath(startPos, path, color = 'orange') {\r\n        let serializedPath = '';\r\n        let lastPosition = startPos;\r\n        for (const position of path) {\r\n            if (position.roomName == lastPosition.roomName) {\r\n                new RoomVisual(position.roomName)\r\n                    .line(position, lastPosition, { color: color, lineStyle: 'dashed' });\r\n                serializedPath += lastPosition.getDirectionTo(position);\r\n            }\r\n            lastPosition = position;\r\n        }\r\n        return serializedPath;\r\n    }\r\n    static nextDirectionInPath(creep) {\r\n        const moveData = creep.memory._go;\r\n        if (!moveData || !moveData.path || moveData.path.length == 0) {\r\n            return;\r\n        }\r\n        return Number.parseInt(moveData.path[0], 10);\r\n    }\r\n    static nextPositionInPath(creep) {\r\n        const nextDir = this.nextDirectionInPath(creep);\r\n        if (!nextDir) {\r\n            return;\r\n        }\r\n        return this.positionAtDirection(creep.pos, nextDir);\r\n    }\r\n    static oppositeDirection(direction) {\r\n        switch (direction) {\r\n            case TOP:\r\n                return BOTTOM;\r\n            case TOP_LEFT:\r\n                return BOTTOM_RIGHT;\r\n            case LEFT:\r\n                return RIGHT;\r\n            case BOTTOM_LEFT:\r\n                return TOP_RIGHT;\r\n            case BOTTOM:\r\n                return TOP;\r\n            case BOTTOM_RIGHT:\r\n                return TOP_LEFT;\r\n            case RIGHT:\r\n                return LEFT;\r\n            case TOP_RIGHT:\r\n                return BOTTOM_LEFT;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a position at a direction from origin\r\n     */\r\n    static positionAtDirection(origin, direction) {\r\n        const offsetX = [0, 0, 1, 1, 1, 0, -1, -1, -1];\r\n        const offsetY = [0, -1, -1, 0, 1, 1, 1, 0, -1];\r\n        const x = origin.x + offsetX[direction];\r\n        const y = origin.y + offsetY[direction];\r\n        if (x > 49 || x < 0 || y > 49 || y < 0) {\r\n            return;\r\n        }\r\n        return new RoomPosition(x, y, origin.roomName);\r\n    }\r\n    static savePath(path) {\r\n        const savedPath = {\r\n            path: path,\r\n            length: path.length,\r\n            tick: Game.time\r\n        };\r\n        const originName = _.first(path).name;\r\n        const destinationName = _.last(path).name;\r\n        if (!Memory.pathing.paths[originName]) {\r\n            Memory.pathing.paths[originName] = {};\r\n        }\r\n        Memory.pathing.paths[originName][destinationName] = savedPath;\r\n    }\r\n    // Distance and path weight calculations ===========================================================================\r\n    /**\r\n     * Calculate and/or cache the length of the shortest path between two points.\r\n     * Cache is probabilistically cleared in Mem\r\n     */\r\n    static distance(arg1, arg2) {\r\n        const [name1, name2] = [arg1.name, arg2.name].sort(); // alphabetize since path is the same in either direction\r\n        if (!Memory.pathing.distances[name1]) {\r\n            Memory.pathing.distances[name1] = {};\r\n        }\r\n        if (!Memory.pathing.distances[name1][name2]) {\r\n            const ret = this.findShortestPath(arg1, arg2);\r\n            if (!ret.incomplete) {\r\n                Memory.pathing.distances[name1][name2] = ret.path.length;\r\n            }\r\n        }\r\n        return Memory.pathing.distances[name1][name2];\r\n    }\r\n    static calculatePathWeight(startPos, endPos, options = {}) {\r\n        _.defaults(options, {\r\n            range: 1,\r\n        });\r\n        const ret = this.findPath(startPos, endPos, options);\r\n        let weight = 0;\r\n        for (const pos of ret.path) {\r\n            if (!pos.room) { // If you don't have vision, assume there are roads\r\n                weight += 1;\r\n            }\r\n            else {\r\n                if (pos.lookForStructure(STRUCTURE_ROAD)) {\r\n                    weight += 1;\r\n                }\r\n                else {\r\n                    const terrain = pos.lookFor(LOOK_TERRAIN)[0];\r\n                    if (terrain == 'plain') {\r\n                        weight += 2;\r\n                    }\r\n                    else if (terrain == 'swamp') {\r\n                        weight += 10;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return weight;\r\n    }\r\n    /**\r\n     * Calculates and/or caches the weighted distance for the most efficient path. Weight is sum of tile weights:\r\n     * Road = 1, Plain = 2, Swamp = 10. Cached weights are cleared in Mem occasionally.\r\n     */\r\n    static weightedDistance(arg1, arg2) {\r\n        let pos1, pos2;\r\n        if (arg1.name < arg2.name) { // alphabetize since path lengths are the same either direction\r\n            pos1 = arg1;\r\n            pos2 = arg2;\r\n        }\r\n        else {\r\n            pos1 = arg2;\r\n            pos2 = arg1;\r\n        }\r\n        if (!Memory.pathing.weightedDistances[pos1.name]) {\r\n            Memory.pathing.weightedDistances[pos1.name] = {};\r\n        }\r\n        if (!Memory.pathing.weightedDistances[pos1.name][pos2.name]) {\r\n            Memory.pathing.weightedDistances[pos1.name][pos2.name] = this.calculatePathWeight(pos1, pos2);\r\n        }\r\n        return Memory.pathing.weightedDistances[pos1.name][pos2.name];\r\n    }\r\n    /**\r\n     * Whether another object in the same room can be reached from the current position\r\n     */\r\n    static isReachable(startPos, endPos, obstacles, options = {}) {\r\n        _.defaults(options, {\r\n            ignoreCreeps: true,\r\n            range: 1,\r\n            maxOps: 2000,\r\n            ensurePath: false,\r\n        });\r\n        if (startPos.roomName != endPos.roomName) {\r\n            log.error(`isReachable() should only be used within a single room!`);\r\n            return false;\r\n        }\r\n        const matrix = new PathFinder.CostMatrix();\r\n        _.forEach(obstacles, obstacle => {\r\n            if (hasPos(obstacle)) {\r\n                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);\r\n            }\r\n            else {\r\n                matrix.set(obstacle.x, obstacle.y, 0xfe);\r\n            }\r\n        });\r\n        const callback = (roomName) => roomName == endPos.roomName ? matrix : false;\r\n        const ret = PathFinder.search(startPos, { pos: endPos, range: options.range }, {\r\n            maxOps: options.maxOps,\r\n            plainCost: 1,\r\n            swampCost: 5,\r\n            maxRooms: 1,\r\n            roomCallback: callback,\r\n        });\r\n        if (ret.incomplete) {\r\n            return false;\r\n        }\r\n        else {\r\n            for (const pos of ret.path) {\r\n                if (matrix.get(pos.x, pos.y) > 100) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Like isReachable(), but returns the first position which should be cleared to find a path to destination\r\n     */\r\n    static findBlockingPos(startPos, endPos, obstacles, options = {}) {\r\n        _.defaults(options, {\r\n            ignoreCreeps: true,\r\n            range: 1,\r\n            maxOps: 2000,\r\n            ensurePath: false,\r\n        });\r\n        if (startPos.roomName != endPos.roomName) {\r\n            log.error(`findBlockingPos() should only be used within a single room!`);\r\n            return undefined;\r\n        }\r\n        const matrix = new PathFinder.CostMatrix();\r\n        _.forEach(obstacles, obstacle => {\r\n            if (hasPos(obstacle)) {\r\n                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);\r\n            }\r\n            else {\r\n                matrix.set(obstacle.x, obstacle.y, 0xfe);\r\n            }\r\n        });\r\n        const callback = (roomName) => roomName == endPos.roomName ? matrix : false;\r\n        const ret = PathFinder.search(startPos, { pos: endPos, range: options.range }, {\r\n            maxOps: options.maxOps,\r\n            plainCost: 1,\r\n            swampCost: 5,\r\n            maxRooms: 1,\r\n            roomCallback: callback,\r\n        });\r\n        for (const pos of ret.path) {\r\n            if (matrix.get(pos.x, pos.y) > 100) {\r\n                return pos;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Find the first walkable position in the room, spiraling outward from the center\r\n     */\r\n    static findPathablePosition(roomName, clearance = { width: 1, height: 1 }) {\r\n        const terrain = Game.map.getRoomTerrain(roomName);\r\n        let x, y;\r\n        let allClear;\r\n        for (let radius = 0; radius < 23; radius++) {\r\n            for (let dx = -radius; dx <= radius; dx++) {\r\n                for (let dy = -radius; dy <= radius; dy++) {\r\n                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {\r\n                        continue;\r\n                    }\r\n                    x = 25 + dx;\r\n                    y = 25 + dy;\r\n                    allClear = true;\r\n                    for (let w = 0; w < clearance.width; w++) {\r\n                        for (let h = 0; h < clearance.height; h++) {\r\n                            if (terrain.get(x + w, y + h) === TERRAIN_MASK_WALL) {\r\n                                allClear = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (allClear) {\r\n                        return new RoomPosition(x, y, roomName);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Should never reach here!\r\n        return new RoomPosition(-10, -10, 'cannotFindPathablePosition');\r\n    }\r\n};\r\nPathing = Pathing_1 = tslib_1.__decorate([\r\n    profile\r\n], Pathing);\r\nexport { Pathing };\r\n// Register global instance\r\nglobal.Pathing = Pathing;\r\n","references":["C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/Cartographer.ts","C:/git/Overmind/src/visuals/Visualizer.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/movement/helpers.ts","C:/git/Overmind/src/movement/Movement.ts"]}
