{"code":"/*\r\n\r\n _____  _    _ _______  ______ _______ _____ __   _ ______\r\n|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\\r\n|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/\r\n....... R E I N F O R C E M E N T   L E A R N I N G .......\r\n\r\n*/\r\nimport { NeuralZerg } from '../zerg/NeuralZerg';\r\nimport { RL_TRAINING_VERBOSITY } from '../~settings';\r\nimport { TrainingOpponents } from './trainingOpponents';\r\nexport const RL_ACTION_SEGMENT = 70;\r\n/**\r\n * The ActionParser provides a line of direct interaction for the external Python optimizers to control\r\n * creep actions via the Memory.reinforcementLearning object.\r\n */\r\nexport class ActionParser {\r\n    /**\r\n     * Parse an individual action from its serialized format and command the actor to execute it.\r\n     * Returns whether the action was valid.\r\n     */\r\n    static parseAction(actor, action, autoEngage = true) {\r\n        const command = action[0];\r\n        const predicate = action[1];\r\n        const targ = typeof predicate == 'string' ? Game.getObjectById(predicate) : null;\r\n        switch (command) {\r\n            case 'move':\r\n                actor.move(predicate);\r\n                break;\r\n            case 'goTo':\r\n                if (targ)\r\n                    actor.goTo(targ);\r\n                break;\r\n            case 'attack':\r\n                if (targ)\r\n                    actor.attack(targ);\r\n                break;\r\n            case 'rangedAttack':\r\n                if (targ)\r\n                    actor.rangedAttack(targ);\r\n                break;\r\n            case 'rangedMassAttack':\r\n                actor.rangedMassAttack();\r\n                break;\r\n            case 'heal':\r\n                if (targ) {\r\n                    actor.heal(targ);\r\n                }\r\n                else if (typeof predicate != 'string') {\r\n                    actor.heal(actor);\r\n                }\r\n                break;\r\n            case 'rangedHeal':\r\n                if (targ)\r\n                    actor.rangedHeal(targ);\r\n                break;\r\n            case 'approachHostiles':\r\n                actor.approachHostiles();\r\n                break;\r\n            case 'avoidHostiles':\r\n                actor.avoidHostiles();\r\n                break;\r\n            case 'approachAllies':\r\n                actor.approachAllies();\r\n                break;\r\n            case 'avoidAllies':\r\n                actor.avoidAllies();\r\n                break;\r\n            case 'maneuver':\r\n                const approachNames = predicate[0];\r\n                const avoidNames = predicate[1];\r\n                const approachTargs = _.map(approachNames, name => Game.creeps[name]);\r\n                const avoidTargs = _.map(avoidNames, name => Game.creeps[name]);\r\n                actor.maneuver(approachTargs, avoidTargs);\r\n                break;\r\n            case 'noop':\r\n                break;\r\n            default:\r\n                console.log(`[${Game.time}] Invalid command: ${command}!`);\r\n                return false;\r\n        }\r\n        if (autoEngage) {\r\n            actor.autoEngage();\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Determine the list of actions for each Zerg to perform\r\n     */\r\n    static parseActions(actors, serializedActions) {\r\n        const receivedOrders = _.mapValues(actors, actor => false);\r\n        // Deserialize the actions for each actor\r\n        for (const creepName in serializedActions) {\r\n            const creep = actors[creepName];\r\n            if (!creep) {\r\n                console.log(`No creep with name ${creepName}!`);\r\n                continue;\r\n            }\r\n            // Parse and execute each action, recording whether it was valid\r\n            for (const action of serializedActions[creepName]) {\r\n                const validAction = ActionParser.parseAction(creep, action);\r\n                if (validAction) {\r\n                    receivedOrders[creepName] = true;\r\n                }\r\n            }\r\n        }\r\n        // Ensure each actor was given an order (possibly noop)\r\n        for (const actorName in actors) {\r\n            if (!receivedOrders[actorName]) {\r\n                console.log(`[${Game.time}] Actor with name ${actorName} did not receive an order this tick!`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Periodic logging functions that are used to describe state of training map and identify bugs\r\n     */\r\n    static logState(contents) {\r\n        console.log(`[${Game.time}] My creeps: `, _.map(Game.creeps, creep => creep.name + ' ' + creep.pos));\r\n        if (Memory.reinforcementLearning) {\r\n            console.log(`[${Game.time}] RL Segment: ${contents}`);\r\n        }\r\n    }\r\n    /**\r\n     * Wraps all creeps as Zerg\r\n     */\r\n    static getAllActors() {\r\n        return _.mapValues(Game.creeps, creep => new NeuralZerg(creep));\r\n    }\r\n    /**\r\n     * Read action commands from the designated memory segment, parse them, and run them\r\n     */\r\n    static run() {\r\n        // Wrap all creep as NeuralZerg and partition actors into controllable and uncontrollable (scripted) sets\r\n        const allActors = ActionParser.getAllActors();\r\n        const controllableActors = {};\r\n        const uncontrollableActors = {};\r\n        for (const name in allActors) {\r\n            const actor = allActors[name];\r\n            if (allActors[name].isBot) {\r\n                uncontrollableActors[name] = actor;\r\n            }\r\n            else {\r\n                controllableActors[name] = actor;\r\n            }\r\n        }\r\n        // Parse memory and relay actions to controllable actors\r\n        const raw = RawMemory.segments[RL_ACTION_SEGMENT];\r\n        if (raw != undefined && raw != '') {\r\n            const actions = JSON.parse(raw);\r\n            ActionParser.parseActions(controllableActors, actions);\r\n        }\r\n        else {\r\n            if (_.size(controllableActors) > 0) {\r\n                console.log(`[${Game.time}]: No actions received!`);\r\n            }\r\n        }\r\n        // Run uncontrollable actors on a script\r\n        for (const name in uncontrollableActors) {\r\n            const bot = uncontrollableActors[name];\r\n            // TrainingOpponents.stupidCombat(bot);\r\n            TrainingOpponents.simpleCombat(bot);\r\n        }\r\n        // Log state according to verbosity\r\n        if (RL_TRAINING_VERBOSITY == 0) {\r\n            // no logigng\r\n        }\r\n        else if (RL_TRAINING_VERBOSITY == 1) {\r\n            if (Game.time % 100 == 0 || Game.time % 100 == 1) {\r\n                this.logState(raw);\r\n            }\r\n        }\r\n        else if (RL_TRAINING_VERBOSITY == 2) {\r\n            this.logState(raw);\r\n        }\r\n        // Clear the segment and keep it requested\r\n        RawMemory.segments[RL_ACTION_SEGMENT] = '';\r\n        RawMemory.setActiveSegments([RL_ACTION_SEGMENT]);\r\n    }\r\n}\r\n","references":["C:/git/Overmind/src/zerg/NeuralZerg.ts","C:/git/Overmind/src/~settings.ts","C:/git/Overmind/src/reinforcementLearning/trainingOpponents.ts"]}
