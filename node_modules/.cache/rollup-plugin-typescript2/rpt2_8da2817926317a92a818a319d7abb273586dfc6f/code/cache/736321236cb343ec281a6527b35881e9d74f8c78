{"code":"import * as tslib_1 from \"tslib\";\r\nvar Mem_1;\r\nimport { log } from '../console/log';\r\nimport { profile } from '../profiler/decorator';\r\nimport { Stats } from '../stats/stats';\r\nimport { isIVM } from '../utilities/utils';\r\nimport { DEFAULT_OPERATION_MODE, DEFAULT_OVERMIND_SIGNATURE, PROFILER_COLONY_LIMIT, USE_PROFILER } from '../~settings';\r\nexport var Autonomy;\r\n(function (Autonomy) {\r\n    Autonomy[Autonomy[\"Manual\"] = 0] = \"Manual\";\r\n    Autonomy[Autonomy[\"SemiAutomatic\"] = 1] = \"SemiAutomatic\";\r\n    Autonomy[Autonomy[\"Automatic\"] = 2] = \"Automatic\";\r\n})(Autonomy || (Autonomy = {}));\r\nexport function getAutonomyLevel() {\r\n    switch (Memory.settings.operationMode) {\r\n        case ('manual'):\r\n            return Autonomy.Manual;\r\n        case ('semiautomatic'):\r\n            return Autonomy.SemiAutomatic;\r\n        case ('automatic'):\r\n            return Autonomy.Automatic;\r\n        default:\r\n            log.warning(`ERROR: ${Memory.settings.operationMode} is not a valid operation mode! ` +\r\n                `Defaulting to ${DEFAULT_OPERATION_MODE}; use setMode() to change.`);\r\n            Memory.settings.operationMode = DEFAULT_OPERATION_MODE;\r\n            return getAutonomyLevel();\r\n    }\r\n}\r\nlet lastMemory;\r\nlet lastTime = 0;\r\nconst MAX_BUCKET = 10000;\r\nconst HEAP_CLEAN_FREQUENCY = 200;\r\nconst BUCKET_CLEAR_CACHE = 7000;\r\nconst BUCKET_CPU_HALT = 4000;\r\n/**\r\n * This module contains a number of low-level memory clearing and caching functions\r\n */\r\nlet Mem = Mem_1 = class Mem {\r\n    static shouldRun() {\r\n        let shouldRun = true;\r\n        if (!isIVM()) {\r\n            log.warning(`Overmind requires isolated-VM to run. Change settings at screeps.com/a/#!/account/runtime`);\r\n            shouldRun = false;\r\n        }\r\n        if (USE_PROFILER && Game.time % 10 == 0) {\r\n            log.warning(`Profiling is currently enabled; only ${PROFILER_COLONY_LIMIT} colonies will be run!`);\r\n        }\r\n        if (Game.cpu.bucket < 500) {\r\n            if (_.keys(Game.spawns).length > 1 && !Memory.resetBucket && !Memory.haltTick) {\r\n                // don't run CPU reset routine at very beginning or if it's already triggered\r\n                log.warning(`CPU bucket is critically low (${Game.cpu.bucket})! Starting CPU reset routine.`);\r\n                Memory.resetBucket = true;\r\n                Memory.haltTick = Game.time + 1; // reset global next tick\r\n            }\r\n            else {\r\n                log.info(`CPU bucket is too low (${Game.cpu.bucket}). Postponing operation until bucket reaches 500.`);\r\n            }\r\n            shouldRun = false;\r\n        }\r\n        if (Memory.resetBucket) {\r\n            if (Game.cpu.bucket < MAX_BUCKET - Game.cpu.limit) {\r\n                log.info(`Operation suspended until bucket recovery. Bucket: ${Game.cpu.bucket}/${MAX_BUCKET}`);\r\n                shouldRun = false;\r\n            }\r\n            else {\r\n                delete Memory.resetBucket;\r\n            }\r\n        }\r\n        if (Memory.haltTick) {\r\n            if (Memory.haltTick == Game.time) {\r\n                Game.cpu.halt(); // TODO: remove any typing when typed-screeps updates to include this method\r\n                shouldRun = false;\r\n            }\r\n            else if (Memory.haltTick < Game.time) {\r\n                delete Memory.haltTick;\r\n            }\r\n        }\r\n        return shouldRun;\r\n    }\r\n    /**\r\n     * Attempt to load the parsed memory from a previous tick to avoid parsing costs\r\n     */\r\n    static load() {\r\n        if (lastTime && lastMemory && Game.time == lastTime + 1) {\r\n            delete global.Memory;\r\n            global.Memory = lastMemory;\r\n            RawMemory._parsed = lastMemory;\r\n        }\r\n        else {\r\n            // noinspection BadExpressionStatementJS\r\n            /* tslint:disable:no-unused-expression */\r\n            Memory.rooms; // forces parsing\r\n            /* tslint:enable:no-unused-expression */\r\n            lastMemory = RawMemory._parsed;\r\n            Memory.stats.persistent.lastMemoryReset = Game.time;\r\n        }\r\n        lastTime = Game.time;\r\n        // Handle global time\r\n        if (!global.age) {\r\n            global.age = 0;\r\n        }\r\n        global.age++;\r\n        Memory.stats.persistent.globalAge = global.age;\r\n    }\r\n    static garbageCollect(quick) {\r\n        if (global.gc) { // sometimes garbage collection isn't available\r\n            const start = Game.cpu.getUsed();\r\n            global.gc(quick);\r\n            log.debug(`Running ${quick ? 'quick' : 'FULL'} garbage collection. ` +\r\n                `Elapsed time: ${Game.cpu.getUsed() - start}.`);\r\n        }\r\n        else {\r\n            log.debug(`Manual garbage collection is unavailable on this server.`);\r\n        }\r\n    }\r\n    static wrap(memory, memName, defaults = {}, deep = false) {\r\n        if (!memory[memName]) {\r\n            memory[memName] = _.clone(defaults);\r\n        }\r\n        if (deep) {\r\n            _.defaultsDeep(memory[memName], defaults);\r\n        }\r\n        else {\r\n            _.defaults(memory[memName], defaults);\r\n        }\r\n        return memory[memName];\r\n    }\r\n    static _setDeep(object, keys, value) {\r\n        const key = _.first(keys);\r\n        keys = _.drop(keys);\r\n        if (keys.length == 0) { // at the end of the recursion\r\n            object[key] = value;\r\n            return;\r\n        }\r\n        else {\r\n            if (!object[key]) {\r\n                object[key] = {};\r\n            }\r\n            return Mem_1._setDeep(object[key], keys, value);\r\n        }\r\n    }\r\n    /**\r\n     * Recursively set a value of an object given a dot-separated key, adding intermediate properties as necessary\r\n     * Ex: Mem.setDeep(Memory.colonies, 'E1S1.miningSites.siteID.stats.uptime', 0.5)\r\n     */\r\n    static setDeep(object, keyString, value) {\r\n        const keys = keyString.split('.');\r\n        return Mem_1._setDeep(object, keys, value);\r\n    }\r\n    static formatOvermindMemory() {\r\n        if (!Memory.Overmind) {\r\n            Memory.Overmind = {};\r\n        }\r\n        if (!Memory.colonies) {\r\n            Memory.colonies = {};\r\n        }\r\n    }\r\n    static formatPathingMemory() {\r\n        if (!Memory.pathing) {\r\n            Memory.pathing = {}; // Hacky workaround\r\n        }\r\n        _.defaults(Memory.pathing, {\r\n            paths: {},\r\n            distances: {},\r\n            weightedDistances: {},\r\n        });\r\n    }\r\n    static formatDefaultMemory() {\r\n        if (!Memory.rooms) {\r\n            Memory.rooms = {};\r\n        }\r\n        if (!Memory.creeps) {\r\n            Memory.creeps = {};\r\n        }\r\n        if (!Memory.flags) {\r\n            Memory.flags = {};\r\n        }\r\n    }\r\n    static format() {\r\n        // Format the memory as needed, done once every global reset\r\n        this.formatDefaultMemory();\r\n        this.formatOvermindMemory();\r\n        this.formatPathingMemory();\r\n        // Rest of memory formatting\r\n        if (!Memory.settings) {\r\n            Memory.settings = {};\r\n        }\r\n        if (!USE_PROFILER) {\r\n            delete Memory.profiler;\r\n        }\r\n        _.defaults(Memory.settings, {\r\n            signature: DEFAULT_OVERMIND_SIGNATURE,\r\n            operationMode: DEFAULT_OPERATION_MODE,\r\n            log: {},\r\n            enableVisuals: true,\r\n        });\r\n        if (!Memory.stats) {\r\n            Memory.stats = {};\r\n        }\r\n        if (!Memory.stats.persistent) {\r\n            Memory.stats.persistent = {};\r\n        }\r\n        if (!Memory.constructionSites) {\r\n            Memory.constructionSites = {};\r\n        }\r\n        // Make global memory\r\n        this.initGlobalMemory();\r\n    }\r\n    static initGlobalMemory() {\r\n        global._cache = {\r\n            accessed: {},\r\n            expiration: {},\r\n            structures: {},\r\n            numbers: {},\r\n            lists: {},\r\n            costMatrices: {},\r\n            roomPositions: {},\r\n            things: {},\r\n        };\r\n    }\r\n    static clean() {\r\n        // Clean the memory of non-existent objects every tick\r\n        this.cleanHeap();\r\n        this.cleanCreeps();\r\n        this.cleanFlags();\r\n        this.cleanColonies();\r\n        this.cleanPathingMemory();\r\n        this.cleanConstructionSites();\r\n        Stats.clean();\r\n    }\r\n    /**\r\n     * Attempt to clear some things out of the global heap to prevent increasing CPU usage\r\n     */\r\n    static cleanHeap() {\r\n        if (Game.time % HEAP_CLEAN_FREQUENCY == HEAP_CLEAN_FREQUENCY - 3) {\r\n            if (Game.cpu.bucket < BUCKET_CPU_HALT) {\r\n                Game.cpu.halt();\r\n            }\r\n            else if (Game.cpu.bucket < BUCKET_CLEAR_CACHE) {\r\n                delete global._cache;\r\n                this.initGlobalMemory();\r\n            }\r\n        }\r\n    }\r\n    static cleanCreeps() {\r\n        // Clear memory for non-existent creeps\r\n        for (const name in Memory.creeps) {\r\n            if (!Game.creeps[name]) {\r\n                delete Memory.creeps[name];\r\n                delete global[name];\r\n            }\r\n        }\r\n    }\r\n    static cleanFlags() {\r\n        // Clear memory for non-existent flags\r\n        for (const name in Memory.flags) {\r\n            if (!Game.flags[name]) {\r\n                delete Memory.flags[name];\r\n                delete global[name];\r\n            }\r\n        }\r\n    }\r\n    static cleanColonies() {\r\n        // Clear memory of dead colonies\r\n        for (const name in Memory.colonies) {\r\n            const room = Game.rooms[name];\r\n            if (!(room && room.my)) {\r\n                // Delete only if \"persistent\" is not set - use case: praise rooms\r\n                if (!Memory.colonies[name].persistent) {\r\n                    delete Memory.colonies[name];\r\n                    delete global[name];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static cleanConstructionSites() {\r\n        // Remove ancient construction sites\r\n        if (Game.time % 10 == 0) {\r\n            const CONSTRUCTION_SITE_TIMEOUT = 50000;\r\n            // Add constructionSites to memory and remove really old ones\r\n            for (const id in Game.constructionSites) {\r\n                const site = Game.constructionSites[id];\r\n                if (!Memory.constructionSites[id]) {\r\n                    Memory.constructionSites[id] = Game.time;\r\n                }\r\n                else if (Game.time - Memory.constructionSites[id] > CONSTRUCTION_SITE_TIMEOUT) {\r\n                    site.remove();\r\n                }\r\n                // Remove duplicate construction sites that get placed on top of existing structures due to caching\r\n                if (site && site.pos.isVisible && site.pos.lookForStructure(site.structureType)) {\r\n                    site.remove();\r\n                }\r\n            }\r\n            // Remove dead constructionSites from memory\r\n            for (const id in Memory.constructionSites) {\r\n                if (!Game.constructionSites[id]) {\r\n                    delete Memory.constructionSites[id];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static cleanPathingMemory() {\r\n        const CLEAN_FREQUENCY = 5;\r\n        if (Game.time % CLEAN_FREQUENCY == 0) {\r\n            const distanceCleanProbability = 0.001 * CLEAN_FREQUENCY;\r\n            const weightedDistanceCleanProbability = 0.01 * CLEAN_FREQUENCY;\r\n            // Randomly clear some cached path lengths\r\n            for (const pos1Name in Memory.pathing.distances) {\r\n                if (_.isEmpty(Memory.pathing.distances[pos1Name])) {\r\n                    delete Memory.pathing.distances[pos1Name];\r\n                }\r\n                else {\r\n                    for (const pos2Name in Memory.pathing.distances[pos1Name]) {\r\n                        if (Math.random() < distanceCleanProbability) {\r\n                            delete Memory.pathing.distances[pos1Name][pos2Name];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Randomly clear weighted distances\r\n            for (const pos1Name in Memory.pathing.weightedDistances) {\r\n                if (_.isEmpty(Memory.pathing.weightedDistances[pos1Name])) {\r\n                    delete Memory.pathing.weightedDistances[pos1Name];\r\n                }\r\n                else {\r\n                    for (const pos2Name in Memory.pathing.weightedDistances[pos1Name]) {\r\n                        if (Math.random() < weightedDistanceCleanProbability) {\r\n                            delete Memory.pathing.weightedDistances[pos1Name][pos2Name];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nMem = Mem_1 = tslib_1.__decorate([\r\n    profile\r\n], Mem);\r\nexport { Mem };\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/stats/stats.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/~settings.ts"]}
