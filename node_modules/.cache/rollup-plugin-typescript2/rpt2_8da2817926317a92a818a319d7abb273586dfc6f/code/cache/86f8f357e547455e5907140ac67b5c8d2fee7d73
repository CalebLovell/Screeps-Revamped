{"code":"import * as tslib_1 from \"tslib\";\r\nvar MiningOverlord_1;\r\nimport { $ } from '../../caching/GlobalCache';\r\nimport { ColonyStage } from '../../Colony';\r\nimport { log } from '../../console/log';\r\nimport { bodyCost } from '../../creepSetups/CreepSetup';\r\nimport { Roles, Setups } from '../../creepSetups/setups';\r\nimport { DirectiveOutpost } from '../../directives/colony/outpost';\r\nimport { Pathing } from '../../movement/Pathing';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { Cartographer, ROOMTYPE_SOURCEKEEPER } from '../../utilities/Cartographer';\r\nimport { maxBy, minBy } from '../../utilities/utils';\r\nimport { Overlord } from '../Overlord';\r\nexport const StandardMinerSetupCost = bodyCost(Setups.drones.miners.standard.generateBody(Infinity));\r\nexport const DoubleMinerSetupCost = bodyCost(Setups.drones.miners.double.generateBody(Infinity));\r\nconst BUILD_OUTPUT_FREQUENCY = 15;\r\nconst SUICIDE_CHECK_FREQUENCY = 3;\r\nconst MINER_SUICIDE_THRESHOLD = 200;\r\n/**\r\n * Spawns miners to harvest from remote, owned, or sourcekeeper energy deposits. Standard mining actions have been\r\n * heavily CPU-optimized\r\n */\r\nlet MiningOverlord = MiningOverlord_1 = class MiningOverlord extends Overlord {\r\n    constructor(directive, priority) {\r\n        super(directive, 'mine', priority);\r\n        this.directive = directive;\r\n        this.priority += this.outpostIndex * OverlordPriority.remoteRoom.roomIncrement;\r\n        this.miners = this.zerg(Roles.drone);\r\n        // Populate structures\r\n        this.populateStructures();\r\n        // Compute energy output\r\n        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER) {\r\n            this.energyPerTick = SOURCE_ENERGY_KEEPER_CAPACITY / ENERGY_REGEN_TIME;\r\n        }\r\n        else if (this.colony.level >= DirectiveOutpost.settings.canSpawnReserversAtRCL) {\r\n            this.energyPerTick = SOURCE_ENERGY_CAPACITY / ENERGY_REGEN_TIME;\r\n        }\r\n        else {\r\n            this.energyPerTick = SOURCE_ENERGY_NEUTRAL_CAPACITY / ENERGY_REGEN_TIME;\r\n        }\r\n        this.miningPowerNeeded = Math.ceil(this.energyPerTick / HARVEST_POWER) + 1;\r\n        // Decide operating mode\r\n        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER) {\r\n            this.mode = 'SK';\r\n            this.setup = Setups.drones.miners.sourceKeeper;\r\n        }\r\n        else if (this.colony.room.energyCapacityAvailable < StandardMinerSetupCost) {\r\n            this.mode = 'early';\r\n            this.setup = Setups.drones.miners.default;\r\n        }\r\n        else if (this.link) {\r\n            this.mode = 'link';\r\n            this.setup = Setups.drones.miners.default;\r\n        }\r\n        else {\r\n            this.mode = 'standard';\r\n            this.setup = Setups.drones.miners.standard;\r\n            // todo: double miner condition\r\n        }\r\n        const miningPowerEach = this.setup.getBodyPotential(WORK, this.colony);\r\n        this.minersNeeded = Math.min(Math.ceil(this.miningPowerNeeded / miningPowerEach), this.pos.availableNeighbors(true).length);\r\n        // Allow drop mining at low levels\r\n        this.allowDropMining = this.colony.level < MiningOverlord_1.settings.dropMineUntilRCL;\r\n        if (this.mode != 'early' && !this.allowDropMining) {\r\n            if (this.container) {\r\n                this.harvestPos = this.container.pos;\r\n            }\r\n            else if (this.link) {\r\n                this.harvestPos = _.find(this.link.pos.availableNeighbors(true), pos => pos.getRangeTo(this) == 1);\r\n            }\r\n            else {\r\n                this.harvestPos = this.calculateContainerPos();\r\n            }\r\n        }\r\n    }\r\n    get distance() {\r\n        return this.directive.distance;\r\n    }\r\n    populateStructures() {\r\n        if (Game.rooms[this.pos.roomName]) {\r\n            this.source = _.first(this.pos.lookFor(LOOK_SOURCES));\r\n            this.constructionSite = _.first(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2));\r\n            this.container = this.pos.findClosestByLimitedRange(Game.rooms[this.pos.roomName].containers, 1);\r\n            this.link = this.pos.findClosestByLimitedRange(this.colony.availableLinks, 2);\r\n            // if (this.link) { // this won't cause repopulation problems since link rooms are always visible\r\n            // \tthis.colony.linkNetwork.claimLink(this.link);\r\n            // }\r\n        }\r\n    }\r\n    refresh() {\r\n        if (!this.room && Game.rooms[this.pos.roomName]) { // if you just gained vision of this room\r\n            this.populateStructures();\r\n        }\r\n        // if (!this.allowDropMining && Game.time % 100 == 0 && !this.container && !this.link) {\r\n        // \tlog.warning(`Mining site at ${this.pos.print} has no output!`);\r\n        // }\r\n        super.refresh();\r\n        $.refresh(this, 'source', 'container', 'link', 'constructionSite');\r\n    }\r\n    /**\r\n     * Calculate where the container output will be built for this site\r\n     */\r\n    calculateContainerPos() {\r\n        // log.debug(`Computing container position for mining overlord at ${this.pos.print}...`);\r\n        let originPos;\r\n        if (this.colony.storage) {\r\n            originPos = this.colony.storage.pos;\r\n        }\r\n        else if (this.colony.roomPlanner.storagePos) {\r\n            originPos = this.colony.roomPlanner.storagePos;\r\n        }\r\n        if (originPos) {\r\n            const path = Pathing.findShortestPath(this.pos, originPos).path;\r\n            const pos = _.find(path, pos => pos.getRangeTo(this) == 1);\r\n            if (pos)\r\n                return pos;\r\n        }\r\n        // Shouldn't ever get here\r\n        log.warning(`Last resort container position calculation for ${this.print}!`);\r\n        return _.first(this.pos.availableNeighbors(true));\r\n    }\r\n    /**\r\n     * Add or remove containers as needed to keep exactly one of contaner | link\r\n     */\r\n    addRemoveContainer() {\r\n        if (this.allowDropMining) {\r\n            return; // only build containers in reserved, owned, or SK rooms\r\n        }\r\n        // Create container if there is not already one being built and no link\r\n        if (!this.container && !this.constructionSite && !this.link) {\r\n            const containerPos = this.calculateContainerPos();\r\n            const container = containerPos.lookForStructure(STRUCTURE_CONTAINER);\r\n            if (container) {\r\n                log.warning(`${this.print}: this.container out of sync at ${containerPos.print}`);\r\n                this.container = container;\r\n                return;\r\n            }\r\n            log.info(`${this.print}: building container at ${containerPos.print}`);\r\n            const result = containerPos.createConstructionSite(STRUCTURE_CONTAINER);\r\n            if (result != OK) {\r\n                log.error(`${this.print}: cannot build container at ${containerPos.print}! Result: ${result}`);\r\n            }\r\n            return;\r\n        }\r\n        // Destroy container if link is nearby\r\n        if (this.container && this.link) {\r\n            // safety checks\r\n            if (this.colony.hatchery && this.container.pos.getRangeTo(this.colony.hatchery) > 2 &&\r\n                this.container.pos.getRangeTo(this.colony.upgradeSite) > 3) {\r\n                log.info(`${this.print}: container and link present; destroying container at ${this.container.pos.print}`);\r\n                this.container.destroy();\r\n            }\r\n        }\r\n    }\r\n    registerEnergyRequests() {\r\n        if (this.container) {\r\n            const transportCapacity = 200 * this.colony.level;\r\n            const threshold = this.colony.stage > ColonyStage.Larva ? 0.8 : 0.5;\r\n            if (_.sum(this.container.store) > threshold * transportCapacity) {\r\n                this.colony.logisticsNetwork.requestOutput(this.container, {\r\n                    resourceType: 'all',\r\n                    dAmountdt: this.energyPerTick\r\n                });\r\n            }\r\n        }\r\n        if (this.link) {\r\n            // If the link will be full with next deposit from the miner\r\n            const minerCapacity = 150;\r\n            if (this.link.energy + minerCapacity > this.link.energyCapacity) {\r\n                this.colony.linkNetwork.requestTransmit(this.link);\r\n            }\r\n        }\r\n    }\r\n    init() {\r\n        this.wishlist(this.minersNeeded, this.setup);\r\n        this.registerEnergyRequests();\r\n    }\r\n    /**\r\n     * Actions for handling mining at early RCL, when multiple miners and drop mining are used\r\n     */\r\n    earlyMiningActions(miner) {\r\n        if (miner.room != this.room) {\r\n            return miner.goToRoom(this.pos.roomName);\r\n        }\r\n        // Container mining\r\n        if (this.container) {\r\n            if (this.container.hits < this.container.hitsMax\r\n                && miner.carry.energy >= Math.min(miner.carryCapacity, REPAIR_POWER * miner.getActiveBodyparts(WORK))) {\r\n                return miner.goRepair(this.container);\r\n            }\r\n            else {\r\n                if (_.sum(miner.carry) < miner.carryCapacity) {\r\n                    return miner.goHarvest(this.source);\r\n                }\r\n                else {\r\n                    return miner.goTransfer(this.container);\r\n                }\r\n            }\r\n        }\r\n        // Build output site\r\n        if (this.constructionSite) {\r\n            if (miner.carry.energy >= Math.min(miner.carryCapacity, BUILD_POWER * miner.getActiveBodyparts(WORK))) {\r\n                return miner.goBuild(this.constructionSite);\r\n            }\r\n            else {\r\n                return miner.goHarvest(this.source);\r\n            }\r\n        }\r\n        // Drop mining\r\n        if (this.allowDropMining) {\r\n            miner.goHarvest(this.source);\r\n            if (miner.carry.energy > 0.8 * miner.carryCapacity) { // try to drop on top of largest drop if full\r\n                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), drop => drop.amount);\r\n                if (biggestDrop) {\r\n                    miner.goDrop(biggestDrop.pos, RESOURCE_ENERGY);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    /**\r\n     * Suicide outdated miners when their replacements arrive\r\n     */\r\n    suicideOldMiners() {\r\n        if (this.miners.length > this.minersNeeded && this.source) {\r\n            // if you have multiple miners and the source is visible\r\n            const targetPos = this.harvestPos || this.source.pos;\r\n            const minersNearSource = _.filter(this.miners, miner => miner.pos.getRangeTo(targetPos) <= SUICIDE_CHECK_FREQUENCY);\r\n            if (minersNearSource.length > this.minersNeeded) {\r\n                // if you have more miners by the source than you need\r\n                const oldestMiner = minBy(minersNearSource, miner => miner.ticksToLive || 9999);\r\n                if (oldestMiner && (oldestMiner.ticksToLive || 9999) < MINER_SUICIDE_THRESHOLD) {\r\n                    // if the oldest miner will die sufficiently soon\r\n                    oldestMiner.suicide();\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Actions for handling link mining\r\n     */\r\n    linkMiningActions(miner) {\r\n        // Approach mining site\r\n        if (this.goToMiningSite(miner))\r\n            return;\r\n        // Link mining\r\n        if (this.link) {\r\n            miner.harvest(this.source);\r\n            if (miner.carry.energy > 0.9 * miner.carryCapacity) {\r\n                miner.transfer(this.link, RESOURCE_ENERGY);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            log.warning(`Link miner ${miner.print} has no link!`);\r\n        }\r\n    }\r\n    /**\r\n     * Actions for handling mining at RCL high enough to spawn ideal miner body to saturate source\r\n     */\r\n    standardMiningActions(miner) {\r\n        // Approach mining site\r\n        if (this.goToMiningSite(miner))\r\n            return;\r\n        // Container mining\r\n        if (this.container) {\r\n            if (this.container.hits < this.container.hitsMax\r\n                && miner.carry.energy >= Math.min(miner.carryCapacity, REPAIR_POWER * miner.getActiveBodyparts(WORK))) {\r\n                return miner.repair(this.container);\r\n            }\r\n            else {\r\n                return miner.harvest(this.source);\r\n            }\r\n        }\r\n        // Build output site\r\n        if (this.constructionSite) {\r\n            if (miner.carry.energy >= Math.min(miner.carryCapacity, BUILD_POWER * miner.getActiveBodyparts(WORK))) {\r\n                return miner.build(this.constructionSite);\r\n            }\r\n            else {\r\n                return miner.harvest(this.source);\r\n            }\r\n        }\r\n        // Drop mining\r\n        if (this.allowDropMining) {\r\n            miner.harvest(this.source);\r\n            if (miner.carry.energy > 0.8 * miner.carryCapacity) { // move over the drop when you're close to full\r\n                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), drop => drop.amount);\r\n                if (biggestDrop) {\r\n                    miner.goTo(biggestDrop);\r\n                }\r\n            }\r\n            if (miner.carry.energy == miner.carryCapacity) { // drop when you are full\r\n                miner.drop(RESOURCE_ENERGY);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    /**\r\n     * Move onto harvesting position or near to source (depending on early/standard mode)\r\n     */\r\n    goToMiningSite(miner) {\r\n        if (this.harvestPos) {\r\n            if (!miner.pos.inRangeToPos(this.harvestPos, 0)) {\r\n                miner.goTo(this.harvestPos);\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            if (!miner.pos.inRangeToPos(this.pos, 1)) {\r\n                miner.goTo(this);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    handleMiner(miner) {\r\n        // Flee hostiles\r\n        if (miner.flee(miner.room.fleeDefaults, { dropEnergy: true })) {\r\n            return;\r\n        }\r\n        // Move onto harvesting position or near to source (depending on early/standard mode)\r\n        if (this.mode == 'early' || !this.harvestPos) {\r\n            if (!miner.pos.inRangeToPos(this.pos, 1)) {\r\n                return miner.goTo(this);\r\n            }\r\n        }\r\n        else {\r\n            if (!miner.pos.inRangeToPos(this.harvestPos, 0)) {\r\n                return miner.goTo(this.harvestPos, { range: 0 });\r\n            }\r\n        }\r\n        switch (this.mode) {\r\n            case 'early':\r\n                return this.earlyMiningActions(miner);\r\n            case 'link':\r\n                return this.linkMiningActions(miner);\r\n            case 'standard':\r\n                return this.standardMiningActions(miner);\r\n            case 'SK':\r\n                return this.standardMiningActions(miner);\r\n            case 'double':\r\n                return this.standardMiningActions(miner);\r\n            default:\r\n                log.error(`UNHANDLED MINER STATE FOR ${miner.print} (MODE: ${this.mode})`);\r\n        }\r\n    }\r\n    run() {\r\n        for (const miner of this.miners) {\r\n            this.handleMiner(miner);\r\n        }\r\n        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY == 1) {\r\n            this.addRemoveContainer();\r\n        }\r\n        if (Game.time % SUICIDE_CHECK_FREQUENCY == 0) {\r\n            this.suicideOldMiners();\r\n        }\r\n    }\r\n};\r\nMiningOverlord.settings = {\r\n    minLinkDistance: 10,\r\n    dropMineUntilRCL: 3,\r\n};\r\nMiningOverlord = MiningOverlord_1 = tslib_1.__decorate([\r\n    profile\r\n], MiningOverlord);\r\nexport { MiningOverlord };\r\n","references":["C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/creepSetups/CreepSetup.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/directives/colony/outpost.ts","C:/git/Overmind/src/directives/resource/harvest.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/Cartographer.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/overlords/Overlord.ts"]}
