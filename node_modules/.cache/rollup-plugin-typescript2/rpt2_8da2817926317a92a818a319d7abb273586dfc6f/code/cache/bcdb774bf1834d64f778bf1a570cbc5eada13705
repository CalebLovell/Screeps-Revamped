{"code":"import * as tslib_1 from \"tslib\";\r\nimport { assimilationLocked } from './assimilation/decorator';\r\nimport { $ } from './caching/GlobalCache';\r\nimport { log } from './console/log';\r\nimport { DirectiveExtract } from './directives/resource/extract';\r\nimport { _HARVEST_MEM_DOWNTIME, _HARVEST_MEM_USAGE, DirectiveHarvest } from './directives/resource/harvest';\r\nimport { CommandCenter } from './hiveClusters/commandCenter';\r\nimport { EvolutionChamber } from './hiveClusters/evolutionChamber';\r\nimport { Hatchery } from './hiveClusters/hatchery';\r\nimport { SporeCrawler } from './hiveClusters/sporeCrawler';\r\nimport { UpgradeSite } from './hiveClusters/upgradeSite';\r\nimport { Energetics } from './logistics/Energetics';\r\nimport { LinkNetwork } from './logistics/LinkNetwork';\r\nimport { LogisticsNetwork } from './logistics/LogisticsNetwork';\r\nimport { RoadLogistics } from './logistics/RoadLogistics';\r\nimport { TransportRequestGroup } from './logistics/TransportRequestGroup';\r\nimport { Mem } from './memory/Memory';\r\nimport { DefaultOverlord } from './overlords/core/default';\r\nimport { TransportOverlord } from './overlords/core/transporter';\r\nimport { WorkerOverlord } from './overlords/core/worker';\r\nimport { RandomWalkerScoutOverlord } from './overlords/scouting/randomWalker';\r\nimport { profile } from './profiler/decorator';\r\nimport { Abathur } from './resources/Abathur';\r\nimport { bunkerLayout, getPosFromBunkerCoord } from './roomPlanner/layouts/bunker';\r\nimport { RoomPlanner } from './roomPlanner/RoomPlanner';\r\nimport { LOG_STATS_INTERVAL, Stats } from './stats/stats';\r\nimport { EXPANSION_EVALUATION_FREQ, ExpansionEvaluator } from './strategy/ExpansionEvaluator';\r\nimport { Cartographer, ROOMTYPE_CONTROLLER } from './utilities/Cartographer';\r\nimport { maxBy, mergeSum, minBy } from './utilities/utils';\r\nimport { Visualizer } from './visuals/Visualizer';\r\nexport var ColonyStage;\r\n(function (ColonyStage) {\r\n    ColonyStage[ColonyStage[\"Larva\"] = 0] = \"Larva\";\r\n    ColonyStage[ColonyStage[\"Pupa\"] = 1] = \"Pupa\";\r\n    ColonyStage[ColonyStage[\"Adult\"] = 2] = \"Adult\";\r\n})(ColonyStage || (ColonyStage = {}));\r\nexport var DEFCON;\r\n(function (DEFCON) {\r\n    DEFCON[DEFCON[\"safe\"] = 0] = \"safe\";\r\n    DEFCON[DEFCON[\"invasionNPC\"] = 1] = \"invasionNPC\";\r\n    DEFCON[DEFCON[\"boostedInvasionNPC\"] = 2] = \"boostedInvasionNPC\";\r\n    DEFCON[DEFCON[\"playerInvasion\"] = 2] = \"playerInvasion\";\r\n    DEFCON[DEFCON[\"bigPlayerInvasion\"] = 3] = \"bigPlayerInvasion\";\r\n})(DEFCON || (DEFCON = {}));\r\nexport function getAllColonies() {\r\n    return _.values(Overmind.colonies);\r\n}\r\nconst defaultColonyMemory = {\r\n    defcon: {\r\n        level: DEFCON.safe,\r\n        tick: -Infinity\r\n    },\r\n    expansionData: {\r\n        possibleExpansions: {},\r\n        expiration: 0,\r\n    },\r\n};\r\n/**\r\n * Colonies are the highest-level object other than the global Overmind. A colony groups together all rooms, structures,\r\n * creeps, utilities, etc. which are run from a single owned room.\r\n */\r\nlet Colony = class Colony {\r\n    constructor(id, roomName, outposts) {\r\n        // Primitive colony setup\r\n        this.id = id;\r\n        this.name = roomName;\r\n        this.ref = roomName;\r\n        this.memory = Mem.wrap(Memory.colonies, roomName, defaultColonyMemory, true);\r\n        // Register colony globally to allow 'W1N1' and 'w1n1' to refer to Overmind.colonies.W1N1\r\n        global[this.name] = this;\r\n        global[this.name.toLowerCase()] = this;\r\n        // Build the colony\r\n        this.build(roomName, outposts);\r\n    }\r\n    /**\r\n     * Pretty-print the colony name in the console\r\n     */\r\n    get print() {\r\n        return '<a href=\"#!/room/' + Game.shard.name + '/' + this.room.name + '\">[' + this.name + ']</a>';\r\n    }\r\n    /**\r\n     * Builds the colony object\r\n     */\r\n    build(roomName, outposts) {\r\n        // Register rooms\r\n        this.roomNames = [roomName].concat(outposts);\r\n        this.room = Game.rooms[roomName];\r\n        this.outposts = _.compact(_.map(outposts, outpost => Game.rooms[outpost]));\r\n        this.rooms = [this.room].concat(this.outposts);\r\n        this.miningSites = {}; // filled in by harvest directives\r\n        this.extractionSites = {}; // filled in by extract directives\r\n        // Register creeps\r\n        this.creeps = Overmind.cache.creepsByColony[this.name] || [];\r\n        this.creepsByRole = _.groupBy(this.creeps, creep => creep.memory.role);\r\n        // Register the rest of the colony components; the order in which these are called is important!\r\n        this.registerRoomObjects_cached(); // Register real colony components\r\n        this.registerOperationalState(); // Set the colony operational state\r\n        this.registerUtilities(); // Register logistics utilities, room planners, and layout info\r\n        this.registerHiveClusters(); // Build the hive clusters\r\n        /* Colony.spawnMoarOverlords() gets called from Overmind.ts, along with Directive.spawnMoarOverlords() */\r\n    }\r\n    /**\r\n     * Refreshes the state of the colony object\r\n     */\r\n    refresh() {\r\n        this.memory = Mem.wrap(Memory.colonies, this.room.name, defaultColonyMemory, true);\r\n        // Refresh rooms\r\n        this.room = Game.rooms[this.room.name];\r\n        this.outposts = _.compact(_.map(this.outposts, outpost => Game.rooms[outpost.name]));\r\n        this.rooms = [this.room].concat(this.outposts);\r\n        // refresh creeps\r\n        this.creeps = Overmind.cache.creepsByColony[this.name] || [];\r\n        this.creepsByRole = _.groupBy(this.creeps, creep => creep.memory.role);\r\n        // Register the rest of the colony components; the order in which these are called is important!\r\n        this.refreshRoomObjects();\r\n        this.registerOperationalState();\r\n        this.refreshUtilities();\r\n        this.refreshHiveClusters();\r\n    }\r\n    /**\r\n     * Registers physical game objects to the colony\r\n     */\r\n    registerRoomObjects() {\r\n        // Create placeholder arrays for remaining properties to be filled in by the Overmind\r\n        this.flags = []; // filled in by directives\r\n        this.destinations = []; // filled in by various hive clusters and directives\r\n        // Register room objects across colony rooms\r\n        this.controller = this.room.controller; // must be controller since colonies are based in owned rooms\r\n        this.spawns = _.sortBy(_.filter(this.room.spawns, spawn => spawn.my && spawn.isActive()), spawn => spawn.ref);\r\n        this.extensions = this.room.extensions;\r\n        this.storage = this.room.storage && this.room.storage.isActive() ? this.room.storage : undefined;\r\n        this.links = this.room.links;\r\n        this.availableLinks = _.clone(this.room.links);\r\n        this.terminal = this.room.terminal && this.room.terminal.isActive() ? this.room.terminal : undefined;\r\n        this.towers = this.room.towers;\r\n        this.labs = _.sortBy(_.filter(this.room.labs, lab => lab.my && lab.isActive()), lab => 50 * lab.pos.y + lab.pos.x); // Labs are sorted in reading order of positions\r\n        this.powerSpawn = this.room.powerSpawn;\r\n        this.nuker = this.room.nuker;\r\n        this.observer = this.room.observer;\r\n        this.pos = (this.storage || this.terminal || this.spawns[0] || this.controller).pos;\r\n        // Register physical objects across all rooms in the colony\r\n        this.sources = _.sortBy(_.flatten(_.map(this.rooms, room => room.sources)), source => source.pos.getMultiRoomRangeTo(this.pos));\r\n        this.extractors = _(this.rooms)\r\n            .map(room => room.extractor)\r\n            .compact()\r\n            .filter(extractor => (extractor.my && extractor.room.my)\r\n            || Cartographer.roomType(extractor.room.name) != ROOMTYPE_CONTROLLER)\r\n            .sortBy(extractor => extractor.pos.getMultiRoomRangeTo(this.pos)).value();\r\n        this.constructionSites = _.flatten(_.map(this.rooms, room => room.constructionSites));\r\n        this.tombstones = _.flatten(_.map(this.rooms, room => room.tombstones));\r\n        this.drops = _.merge(_.map(this.rooms, room => room.drops));\r\n        this.repairables = _.flatten(_.map(this.rooms, room => room.repairables));\r\n        this.rechargeables = _.flatten(_.map(this.rooms, room => room.rechargeables));\r\n        // Register assets\r\n        this.assets = this.getAllAssets();\r\n    }\r\n    /**\r\n     * Version of Colony.registerRoomObjects with additional caching functionality\r\n     */\r\n    registerRoomObjects_cached() {\r\n        // Create placeholder arrays for remaining properties to be filled in by the Overmind\r\n        this.flags = []; // filled in by directives\r\n        this.destinations = []; // filled in by various hive clusters and directives\r\n        // Register room objects across colony rooms\r\n        this.controller = this.room.controller; // must be controller since colonies are based in owned rooms\r\n        this.extensions = this.room.extensions;\r\n        this.links = this.room.links;\r\n        this.availableLinks = _.clone(this.room.links);\r\n        this.towers = this.room.towers;\r\n        this.powerSpawn = this.room.powerSpawn;\r\n        this.nuker = this.room.nuker;\r\n        this.observer = this.room.observer;\r\n        $.set(this, 'spawns', () => _.sortBy(_.filter(this.room.spawns, spawn => spawn.my && spawn.isActive()), spawn => spawn.ref));\r\n        $.set(this, 'storage', () => this.room.storage && this.room.storage.isActive() ? this.room.storage : undefined);\r\n        // this.availableLinks = _.clone(this.room.links);\r\n        $.set(this, 'terminal', () => this.room.terminal && this.room.terminal.isActive() ? this.room.terminal : undefined);\r\n        $.set(this, 'labs', () => _.sortBy(_.filter(this.room.labs, lab => lab.my && lab.isActive()), lab => 50 * lab.pos.y + lab.pos.x));\r\n        this.pos = (this.storage || this.terminal || this.spawns[0] || this.controller).pos;\r\n        // Register physical objects across all rooms in the colony\r\n        $.set(this, 'sources', () => _.sortBy(_.flatten(_.map(this.rooms, room => room.sources)), source => source.pos.getMultiRoomRangeTo(this.pos)));\r\n        for (const source of this.sources) {\r\n            DirectiveHarvest.createIfNotPresent(source.pos, 'pos');\r\n        }\r\n        $.set(this, 'extractors', () => _(this.rooms)\r\n            .map(room => room.extractor)\r\n            .compact()\r\n            .filter(e => (e.my && e.room.my)\r\n            || Cartographer.roomType(e.room.name) != ROOMTYPE_CONTROLLER)\r\n            .sortBy(e => e.pos.getMultiRoomRangeTo(this.pos)).value());\r\n        if (this.controller.level >= 6) {\r\n            _.forEach(this.extractors, extractor => DirectiveExtract.createIfNotPresent(extractor.pos, 'pos'));\r\n        }\r\n        $.set(this, 'repairables', () => _.flatten(_.map(this.rooms, room => room.repairables)));\r\n        $.set(this, 'rechargeables', () => _.flatten(_.map(this.rooms, room => room.rechargeables)));\r\n        $.set(this, 'constructionSites', () => _.flatten(_.map(this.rooms, room => room.constructionSites)), 10);\r\n        $.set(this, 'tombstones', () => _.flatten(_.map(this.rooms, room => room.tombstones)), 5);\r\n        this.drops = _.merge(_.map(this.rooms, room => room.drops));\r\n        // Register assets\r\n        this.assets = this.getAllAssets();\r\n    }\r\n    /**\r\n     * Refresh the state of all physical game objects in the colony\r\n     */\r\n    refreshRoomObjects() {\r\n        $.refresh(this, 'controller', 'extensions', 'links', 'towers', 'powerSpawn', 'nuker', 'observer', 'spawns', 'storage', 'terminal', 'labs', 'sources', 'extractors', 'constructionSites', 'repairables', 'rechargeables');\r\n        $.set(this, 'constructionSites', () => _.flatten(_.map(this.rooms, room => room.constructionSites)), 10);\r\n        $.set(this, 'tombstones', () => _.flatten(_.map(this.rooms, room => room.tombstones)), 5);\r\n        this.drops = _.merge(_.map(this.rooms, room => room.drops));\r\n        // Re-compute assets\r\n        this.assets = this.getAllAssets();\r\n    }\r\n    /**\r\n     * Registers the operational state of the colony, computing things like colony maturity, DEFCON level, etc.\r\n     */\r\n    registerOperationalState() {\r\n        this.level = this.controller.level;\r\n        this.bootstrapping = false;\r\n        this.isIncubating = false;\r\n        if (this.storage && this.spawns[0]) {\r\n            // If the colony has storage and a hatchery\r\n            if (this.controller.level == 8) {\r\n                this.stage = ColonyStage.Adult;\r\n            }\r\n            else {\r\n                this.stage = ColonyStage.Pupa;\r\n            }\r\n        }\r\n        else {\r\n            this.stage = ColonyStage.Larva;\r\n        }\r\n        // this.incubatingColonies = [];\r\n        this.lowPowerMode = Energetics.lowPowerMode(this);\r\n        // Set DEFCON level\r\n        // TODO: finish this\r\n        let defcon = DEFCON.safe;\r\n        const defconDecayTime = 200;\r\n        if (this.room.dangerousHostiles.length > 0 && !this.controller.safeMode) {\r\n            const effectiveHostileCount = _.sum(_.map(this.room.dangerousHostiles, hostile => hostile.boosts.length > 0 ? 2 : 1));\r\n            if (effectiveHostileCount >= 3) {\r\n                defcon = DEFCON.boostedInvasionNPC;\r\n            }\r\n            else {\r\n                defcon = DEFCON.invasionNPC;\r\n            }\r\n        }\r\n        if (this.memory.defcon) {\r\n            if (defcon < this.memory.defcon.level) { // decay defcon level over time if defcon less than memory value\r\n                if (this.memory.defcon.tick + defconDecayTime < Game.time) {\r\n                    this.memory.defcon.level = defcon;\r\n                    this.memory.defcon.tick = Game.time;\r\n                }\r\n            }\r\n            else if (defcon > this.memory.defcon.level) { // refresh defcon time if it increases by a level\r\n                this.memory.defcon.level = defcon;\r\n                this.memory.defcon.tick = Game.time;\r\n            }\r\n        }\r\n        else {\r\n            this.memory.defcon = {\r\n                level: defcon,\r\n                tick: Game.time\r\n            };\r\n        }\r\n        this.defcon = this.memory.defcon.level;\r\n        this.breached = (this.room.dangerousHostiles.length > 0 &&\r\n            this.creeps.length == 0 &&\r\n            !this.controller.safeMode);\r\n        this.terminalState = undefined;\r\n    }\r\n    /**\r\n     * Registers utility classes such as logistics networks\r\n     */\r\n    registerUtilities() {\r\n        // Resource requests\r\n        this.linkNetwork = new LinkNetwork(this);\r\n        this.logisticsNetwork = new LogisticsNetwork(this);\r\n        this.transportRequests = new TransportRequestGroup();\r\n        // Register a room planner\r\n        this.roomPlanner = new RoomPlanner(this);\r\n        if (this.roomPlanner.memory.bunkerData && this.roomPlanner.memory.bunkerData.anchor) {\r\n            this.layout = 'bunker';\r\n            const anchor = derefRoomPosition(this.roomPlanner.memory.bunkerData.anchor);\r\n            // log.debug(JSON.stringify(`anchor for ${this.name}: ${anchor}`));\r\n            const spawnPositions = _.map(bunkerLayout[8].buildings.spawn.pos, c => getPosFromBunkerCoord(c, this));\r\n            // log.debug(JSON.stringify(`spawnPositions for ${this.name}: ${spawnPositions}`));\r\n            const rightSpawnPos = maxBy(spawnPositions, pos => pos.x);\r\n            const topSpawnPos = minBy(spawnPositions, pos => pos.y);\r\n            const coreSpawnPos = anchor.findClosestByRange(spawnPositions);\r\n            // log.debug(JSON.stringify(`spawnPoses: ${rightSpawnPos}, ${topSpawnPos}, ${coreSpawnPos}`));\r\n            this.bunker = {\r\n                anchor: anchor,\r\n                topSpawn: topSpawnPos.lookForStructure(STRUCTURE_SPAWN),\r\n                coreSpawn: coreSpawnPos.lookForStructure(STRUCTURE_SPAWN),\r\n                rightSpawn: rightSpawnPos.lookForStructure(STRUCTURE_SPAWN),\r\n            };\r\n        }\r\n        else {\r\n            this.layout = 'twoPart';\r\n        }\r\n        // Register road network\r\n        this.roadLogistics = new RoadLogistics(this);\r\n        // \"Organism Abathur with you.\"\r\n        this.abathur = new Abathur(this);\r\n    }\r\n    /**\r\n     * Calls utility.refresh() for each registered utility\r\n     */\r\n    refreshUtilities() {\r\n        this.linkNetwork.refresh();\r\n        this.logisticsNetwork.refresh();\r\n        this.transportRequests.refresh();\r\n        this.roomPlanner.refresh();\r\n        if (this.bunker) {\r\n            if (this.bunker.topSpawn) {\r\n                this.bunker.topSpawn = Game.getObjectById(this.bunker.topSpawn.id);\r\n            }\r\n            if (this.bunker.coreSpawn) {\r\n                this.bunker.coreSpawn = Game.getObjectById(this.bunker.coreSpawn.id);\r\n            }\r\n            if (this.bunker.rightSpawn) {\r\n                this.bunker.rightSpawn = Game.getObjectById(this.bunker.rightSpawn.id);\r\n            }\r\n        }\r\n        this.roadLogistics.refresh();\r\n        this.abathur.refresh();\r\n    }\r\n    /**\r\n     * Builds hive clusters for each structural group in a colony\r\n     */\r\n    registerHiveClusters() {\r\n        this.hiveClusters = [];\r\n        // Instantiate the command center if there is storage in the room - this must be done first!\r\n        if (this.stage > ColonyStage.Larva) {\r\n            this.commandCenter = new CommandCenter(this, this.storage);\r\n        }\r\n        // Instantiate the hatchery - the incubation directive assignes hatchery to incubator's hatchery if none exists\r\n        if (this.spawns[0]) {\r\n            this.hatchery = new Hatchery(this, this.spawns[0]);\r\n        }\r\n        // Instantiate evolution chamber once there are three labs all in range 2 of each other\r\n        if (this.terminal && _.filter(this.labs, lab => _.all(this.labs, otherLab => lab.pos.inRangeTo(otherLab, 2))).length >= 3) {\r\n            this.evolutionChamber = new EvolutionChamber(this, this.terminal);\r\n        }\r\n        // Instantiate the upgradeSite\r\n        this.upgradeSite = new UpgradeSite(this, this.controller);\r\n        // Instantiate spore crawlers to wrap towers\r\n        if (this.towers[0]) {\r\n            this.sporeCrawler = new SporeCrawler(this, this.towers[0]);\r\n        }\r\n        // Reverse the hive clusters for correct order for init() and run()\r\n        this.hiveClusters.reverse();\r\n    }\r\n    /**\r\n     * Refreshes the state of each hive cluster\r\n     */\r\n    refreshHiveClusters() {\r\n        for (let i = this.hiveClusters.length - 1; i >= 0; i--) {\r\n            this.hiveClusters[i].refresh();\r\n        }\r\n    }\r\n    /**\r\n     * Instantiate all overlords for the colony\r\n     */\r\n    spawnMoarOverlords() {\r\n        this.overlords = {\r\n            default: new DefaultOverlord(this),\r\n            work: new WorkerOverlord(this),\r\n            logistics: new TransportOverlord(this),\r\n        };\r\n        if (!this.observer) {\r\n            this.overlords.scout = new RandomWalkerScoutOverlord(this);\r\n        }\r\n        for (const hiveCluster of this.hiveClusters) {\r\n            hiveCluster.spawnMoarOverlords();\r\n        }\r\n    }\r\n    /**\r\n     * Get a list of creeps in the colony which have a specified role name\r\n     */\r\n    getCreepsByRole(roleName) {\r\n        return this.creepsByRole[roleName] || [];\r\n    }\r\n    /**\r\n     * Get a list of zerg in the colony which have a specified role name\r\n     */\r\n    getZergByRole(roleName) {\r\n        return _.map(this.getCreepsByRole(roleName), creep => Overmind.zerg[creep.name]);\r\n    }\r\n    /**\r\n     * Summarizes the total of all resources in colony store structures, labs, and some creeps\r\n     */\r\n    getAllAssets(verbose = false) {\r\n        // if (this.name == 'E8S45') verbose = true; // 18863\r\n        // Include storage structures, lab contents, and manager carry\r\n        const stores = _.map(_.compact([this.storage, this.terminal]), s => s.store);\r\n        const creepCarriesToInclude = _.map(this.creeps, creep => creep.carry);\r\n        const labContentsToInclude = _.map(_.filter(this.labs, lab => !!lab.mineralType), lab => ({ [lab.mineralType]: lab.mineralAmount }));\r\n        const allAssets = mergeSum([\r\n            ...stores,\r\n            ...creepCarriesToInclude,\r\n            ...labContentsToInclude\r\n        ]);\r\n        if (verbose)\r\n            log.debug(`${this.room.print} assets: ` + JSON.stringify(allAssets));\r\n        return allAssets;\r\n    }\r\n    /**\r\n     * Initializes the state of the colony each tick\r\n     */\r\n    init() {\r\n        _.forEach(this.hiveClusters, hiveCluster => hiveCluster.init()); // Initialize each hive cluster\r\n        this.roadLogistics.init(); // Initialize the road network\r\n        this.linkNetwork.init(); // Initialize link network\r\n        this.roomPlanner.init(); // Initialize the room planner\r\n        if (Game.time % EXPANSION_EVALUATION_FREQ == 5 * this.id) { // Re-evaluate expansion data if needed\r\n            ExpansionEvaluator.refreshExpansionData(this);\r\n        }\r\n    }\r\n    /**\r\n     * Runs the colony, performing state-changing actions each tick\r\n     */\r\n    run() {\r\n        _.forEach(this.hiveClusters, hiveCluster => hiveCluster.run()); // Run each hive cluster\r\n        this.linkNetwork.run(); // Run the link network\r\n        this.roadLogistics.run(); // Run the road network\r\n        this.roomPlanner.run(); // Run the room planner\r\n        this.stats(); // Log stats per tick\r\n    }\r\n    /**\r\n     * Register colony-wide statistics\r\n     */\r\n    stats() {\r\n        if (Game.time % LOG_STATS_INTERVAL == 0) {\r\n            // Log energy and rcl\r\n            Stats.log(`colonies.${this.name}.storage.energy`, this.storage ? this.storage.energy : undefined);\r\n            Stats.log(`colonies.${this.name}.rcl.level`, this.controller.level);\r\n            Stats.log(`colonies.${this.name}.rcl.progress`, this.controller.progress);\r\n            Stats.log(`colonies.${this.name}.rcl.progressTotal`, this.controller.progressTotal);\r\n            // Log average miningSite usage and uptime and estimated colony energy income\r\n            const numSites = _.keys(this.miningSites).length;\r\n            const avgDowntime = _.sum(this.miningSites, site => site.memory[_HARVEST_MEM_DOWNTIME]) / numSites;\r\n            const avgUsage = _.sum(this.miningSites, site => site.memory[_HARVEST_MEM_USAGE]) / numSites;\r\n            const energyInPerTick = _.sum(this.miningSites, site => site.overlords.mine.energyPerTick * site.memory[_HARVEST_MEM_USAGE]);\r\n            Stats.log(`colonies.${this.name}.miningSites.avgDowntime`, avgDowntime);\r\n            Stats.log(`colonies.${this.name}.miningSites.avgUsage`, avgUsage);\r\n            Stats.log(`colonies.${this.name}.miningSites.energyInPerTick`, energyInPerTick);\r\n            Stats.log(`colonies.${this.name}.assets`, this.assets);\r\n            // Log defensive properties\r\n            Stats.log(`colonies.${this.name}.defcon`, this.defcon);\r\n            const avgBarrierHits = _.sum(this.room.barriers, barrier => barrier.hits) / this.room.barriers.length;\r\n            Stats.log(`colonies.${this.name}.avgBarrierHits`, avgBarrierHits);\r\n        }\r\n    }\r\n    drawCreepReport(coord) {\r\n        let { x, y } = coord;\r\n        const roledata = Overmind.overseer.getCreepReport(this);\r\n        const tablePos = new RoomPosition(x, y, this.room.name);\r\n        y = Visualizer.infoBox(`${this.name} Creeps`, roledata, tablePos, 7);\r\n        return { x, y };\r\n    }\r\n    visuals() {\r\n        let x = 1;\r\n        let y = 11.5;\r\n        let coord;\r\n        coord = this.drawCreepReport({ x, y });\r\n        x = coord.x;\r\n        y = coord.y;\r\n        for (const hiveCluster of _.compact([this.hatchery, this.commandCenter, this.evolutionChamber])) {\r\n            coord = hiveCluster.visuals({ x, y });\r\n            x = coord.x;\r\n            y = coord.y;\r\n        }\r\n    }\r\n};\r\nColony.settings = {\r\n    remoteSourcesByLevel: {\r\n        1: 1,\r\n        2: 2,\r\n        3: 3,\r\n        4: 4,\r\n        5: 5,\r\n        6: 6,\r\n        7: 7,\r\n        8: 9,\r\n    },\r\n    maxSourceDistance: 100\r\n};\r\nColony = tslib_1.__decorate([\r\n    profile,\r\n    assimilationLocked\r\n], Colony);\r\nexport { Colony };\r\n","references":["C:/git/Overmind/src/assimilation/decorator.ts","C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/directives/resource/extract.ts","C:/git/Overmind/src/directives/resource/harvest.ts","C:/git/Overmind/src/hiveClusters/_HiveCluster.ts","C:/git/Overmind/src/hiveClusters/commandCenter.ts","C:/git/Overmind/src/hiveClusters/evolutionChamber.ts","C:/git/Overmind/src/hiveClusters/hatchery.ts","C:/git/Overmind/src/hiveClusters/sporeCrawler.ts","C:/git/Overmind/src/hiveClusters/upgradeSite.ts","C:/git/Overmind/src/logistics/Energetics.ts","C:/git/Overmind/src/logistics/LinkNetwork.ts","C:/git/Overmind/src/logistics/LogisticsNetwork.ts","C:/git/Overmind/src/logistics/RoadLogistics.ts","C:/git/Overmind/src/logistics/SpawnGroup.ts","C:/git/Overmind/src/logistics/TransportRequestGroup.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/overlords/core/default.ts","C:/git/Overmind/src/overlords/core/transporter.ts","C:/git/Overmind/src/overlords/core/worker.ts","C:/git/Overmind/src/overlords/scouting/randomWalker.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/resources/Abathur.ts","C:/git/Overmind/src/roomPlanner/layouts/bunker.ts","C:/git/Overmind/src/roomPlanner/RoomPlanner.ts","C:/git/Overmind/src/stats/stats.ts","C:/git/Overmind/src/strategy/ExpansionEvaluator.ts","C:/git/Overmind/src/utilities/Cartographer.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/visuals/Visualizer.ts","C:/git/Overmind/src/zerg/Zerg.ts"]}
