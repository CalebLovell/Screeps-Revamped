{"code":"import * as tslib_1 from \"tslib\";\r\nvar Abathur_1;\r\nimport { getAllColonies } from '../Colony';\r\nimport { maxMarketPrices, TraderJoe } from '../logistics/TradeNetwork';\r\nimport { Mem } from '../memory/Memory';\r\nimport { profile } from '../profiler/decorator';\r\nimport { mergeSum, minMax, onPublicServer } from '../utilities/utils';\r\nimport { REAGENTS } from './map_resources';\r\nexport const priorityStockAmounts = {\r\n    XGHO2: 1000,\r\n    XLHO2: 1000,\r\n    XZHO2: 1000,\r\n    XZH2O: 1000,\r\n    XKHO2: 1000,\r\n    XUH2O: 1000,\r\n    GHO2: 1000,\r\n    LHO2: 1000,\r\n    ZHO2: 1000,\r\n    ZH2O: 1000,\r\n    UH2O: 1000,\r\n    KHO2: 1000,\r\n    GO: 1000,\r\n    LO: 1000,\r\n    ZO: 1000,\r\n    ZH: 1000,\r\n    UH: 1000,\r\n    KO: 1000,\r\n    G: 2000,\r\n};\r\nexport const wantedStockAmounts = {\r\n    UH: 3000,\r\n    KO: 3000,\r\n    XGHO2: 10000,\r\n    XLHO2: 10000,\r\n    XZHO2: 6000,\r\n    XZH2O: 6000,\r\n    XKHO2: 8000,\r\n    XUH2O: 8000,\r\n    G: 5000,\r\n    XLH2O: 3000,\r\n    LH: 3000,\r\n    XUHO2: 3000,\r\n    XKH2O: 3000,\r\n    ZK: 800,\r\n    UL: 800,\r\n    GH: 800,\r\n    KH: 800,\r\n    OH: 800,\r\n    GH2O: 800,\r\n    LH2O: 800,\r\n    KH2O: 800,\r\n    XGH2O: 12000,\r\n};\r\nexport const baseStockAmounts = {\r\n    [RESOURCE_CATALYST]: 5000,\r\n    [RESOURCE_ZYNTHIUM]: 5000,\r\n    [RESOURCE_LEMERGIUM]: 5000,\r\n    [RESOURCE_KEANIUM]: 5000,\r\n    [RESOURCE_UTRIUM]: 5000,\r\n    [RESOURCE_OXYGEN]: 5000,\r\n    [RESOURCE_HYDROGEN]: 5000\r\n};\r\n// Compute priority and wanted stock\r\nconst _priorityStock = [];\r\nfor (const resourceType in priorityStockAmounts) {\r\n    const stock = {\r\n        mineralType: resourceType,\r\n        amount: priorityStockAmounts[resourceType]\r\n    };\r\n    _priorityStock.push(stock);\r\n}\r\nconst _wantedStock = [];\r\nfor (const resourceType in wantedStockAmounts) {\r\n    const stock = {\r\n        mineralType: resourceType,\r\n        amount: wantedStockAmounts[resourceType]\r\n    };\r\n    _wantedStock.push(stock);\r\n}\r\nexport const priorityStock = _priorityStock;\r\nexport const wantedStock = _wantedStock;\r\nconst AbathurMemoryDefaults = {\r\n    sleepUntil: 0\r\n};\r\n/**\r\n * Abathur is responsible for the evolution of the swarm and directs global production of minerals. Abathur likes\r\n * efficiency, XGHO2, and high lab uptime, and dislikes pronouns.\r\n */\r\nlet Abathur = Abathur_1 = class Abathur {\r\n    constructor(colony) {\r\n        this.colony = colony;\r\n        this.memory = Mem.wrap(this.colony.memory, 'abathur', AbathurMemoryDefaults);\r\n        this.priorityStock = priorityStock;\r\n        this.wantedStock = wantedStock;\r\n        this.assets = colony.assets;\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(this.colony.memory, 'abathur', AbathurMemoryDefaults);\r\n        this.assets = this.colony.assets;\r\n    }\r\n    /**\r\n     * Summarizes the total of all resources currently in a colony store structure\r\n     */\r\n    computeGlobalAssets() {\r\n        const colonyAssets = [];\r\n        for (const colony of getAllColonies()) {\r\n            colonyAssets.push(colony.assets);\r\n        }\r\n        return mergeSum(colonyAssets);\r\n    }\r\n    get globalAssets() {\r\n        if (!this._globalAssets) {\r\n            this._globalAssets = this.computeGlobalAssets();\r\n        }\r\n        return this._globalAssets;\r\n    }\r\n    canReceiveBasicMineralsForReaction(mineralQuantities, amount) {\r\n        for (const mineral in mineralQuantities) {\r\n            if (!this.someColonyHasExcess(mineral, mineralQuantities[mineral])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    canBuyBasicMineralsForReaction(mineralQuantities) {\r\n        if (Game.market.credits < TraderJoe.settings.market.reserveCredits) {\r\n            return false;\r\n        }\r\n        for (const mineral in mineralQuantities) {\r\n            let maxPrice = maxMarketPrices[mineral] || maxMarketPrices.default;\r\n            if (!onPublicServer()) {\r\n                maxPrice = Infinity;\r\n            }\r\n            if (Overmind.tradeNetwork.priceOf(mineral) > maxPrice) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static stockAmount(resource) {\r\n        return (wantedStockAmounts[resource] || priorityStockAmounts[resource] || baseStockAmounts[resource] || 0);\r\n    }\r\n    hasExcess(mineralType, excessAmount = 0) {\r\n        return this.assets[mineralType] - excessAmount > Abathur_1.stockAmount(mineralType);\r\n    }\r\n    someColonyHasExcess(mineralType, excessAmount = 0) {\r\n        return _.any(getAllColonies(), colony => colony.abathur.hasExcess(mineralType, excessAmount));\r\n    }\r\n    /**\r\n     * Generate a queue of reactions to produce the most needed compound\r\n     */\r\n    getReactionQueue(verbose = false) {\r\n        // Return nothing if you are sleeping; prevents wasteful reaction queue calculations\r\n        if (Game.time < this.memory.sleepUntil) {\r\n            return [];\r\n        }\r\n        // Compute the reaction queue for the highest priority item that you should be and can be making\r\n        const stocksToCheck = [priorityStockAmounts, wantedStockAmounts];\r\n        for (const stocks of stocksToCheck) {\r\n            for (const resourceType in stocks) {\r\n                const amountOwned = this.assets[resourceType] || 0;\r\n                const amountNeeded = stocks[resourceType];\r\n                if (amountOwned < amountNeeded) { // if there is a shortage of this resource\r\n                    const reactionQueue = this.buildReactionQueue(resourceType, amountNeeded - amountOwned, verbose);\r\n                    const missingBaseMinerals = this.getMissingBasicMinerals(reactionQueue);\r\n                    if (!_.any(missingBaseMinerals)\r\n                        || this.canReceiveBasicMineralsForReaction(missingBaseMinerals, amountNeeded + 1000)\r\n                        || this.canBuyBasicMineralsForReaction(missingBaseMinerals)) {\r\n                        return reactionQueue;\r\n                    }\r\n                    else {\r\n                        if (verbose)\r\n                            console.log(`Missing minerals for ${resourceType}: ${JSON.stringify(missingBaseMinerals)}`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // If there's nothing you can make, sleep for 100 ticks\r\n        this.memory.sleepUntil = Game.time + Abathur_1.settings.sleepTime;\r\n        return [];\r\n    }\r\n    /**\r\n     * Build a reaction queue for a target compound\r\n     */\r\n    buildReactionQueue(mineral, amount, verbose = false) {\r\n        amount = minMax(amount, Abathur_1.settings.minBatchSize, Abathur_1.settings.maxBatchSize);\r\n        if (verbose)\r\n            console.log(`Abathur@${this.colony.room.print}: building reaction queue for ${amount} ${mineral}`);\r\n        let reactionQueue = [];\r\n        for (const ingredient of this.ingredientsList(mineral)) {\r\n            let productionAmount = amount;\r\n            if (ingredient != mineral) {\r\n                if (verbose)\r\n                    console.log(`productionAmount: ${productionAmount}, assets: ${this.assets[ingredient]}`);\r\n                productionAmount = Math.max(productionAmount - (this.assets[ingredient] || 0), 0);\r\n            }\r\n            productionAmount = Math.min(productionAmount, Abathur_1.settings.maxBatchSize);\r\n            reactionQueue.push({ mineralType: ingredient, amount: productionAmount });\r\n        }\r\n        if (verbose)\r\n            console.log(`Pre-trim queue: ${JSON.stringify(reactionQueue)}`);\r\n        reactionQueue = this.trimReactionQueue(reactionQueue);\r\n        if (verbose)\r\n            console.log(`Post-trim queue: ${JSON.stringify(reactionQueue)}`);\r\n        reactionQueue = _.filter(reactionQueue, rxn => rxn.amount > 0);\r\n        if (verbose)\r\n            console.log(`Final queue: ${JSON.stringify(reactionQueue)}`);\r\n        return reactionQueue;\r\n    }\r\n    /**\r\n     * Trim a reaction queue, reducing the amounts of precursor compounds which need to be produced\r\n     */\r\n    trimReactionQueue(reactionQueue) {\r\n        // Scan backwards through the queue and reduce the production amount of subsequently baser resources as needed\r\n        reactionQueue.reverse();\r\n        for (const reaction of reactionQueue) {\r\n            const [ing1, ing2] = REAGENTS[reaction.mineralType];\r\n            const precursor1 = _.findIndex(reactionQueue, rxn => rxn.mineralType == ing1);\r\n            const precursor2 = _.findIndex(reactionQueue, rxn => rxn.mineralType == ing2);\r\n            for (const index of [precursor1, precursor2]) {\r\n                if (index != -1) {\r\n                    if (reactionQueue[index].amount == 0) {\r\n                        reactionQueue[index].amount = 0;\r\n                    }\r\n                    else {\r\n                        reactionQueue[index].amount = minMax(reaction.amount, Abathur_1.settings.minBatchSize, reactionQueue[index].amount);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        reactionQueue.reverse();\r\n        return reactionQueue;\r\n    }\r\n    /**\r\n     * Figure out which basic minerals are missing and how much\r\n     */\r\n    getMissingBasicMinerals(reactionQueue, verbose = false) {\r\n        const requiredBasicMinerals = this.getRequiredBasicMinerals(reactionQueue);\r\n        if (verbose)\r\n            console.log(`Required basic minerals: ${JSON.stringify(requiredBasicMinerals)}`);\r\n        if (verbose)\r\n            console.log(`assets: ${JSON.stringify(this.assets)}`);\r\n        const missingBasicMinerals = {};\r\n        for (const mineralType in requiredBasicMinerals) {\r\n            const amountMissing = requiredBasicMinerals[mineralType] - (this.assets[mineralType] || 0);\r\n            if (amountMissing > 0) {\r\n                missingBasicMinerals[mineralType] = amountMissing;\r\n            }\r\n        }\r\n        if (verbose)\r\n            console.log(`Missing basic minerals: ${JSON.stringify(missingBasicMinerals)}`);\r\n        return missingBasicMinerals;\r\n    }\r\n    /**\r\n     * Get the required amount of basic minerals for a reaction queue\r\n     */\r\n    getRequiredBasicMinerals(reactionQueue) {\r\n        const requiredBasicMinerals = {\r\n            [RESOURCE_HYDROGEN]: 0,\r\n            [RESOURCE_OXYGEN]: 0,\r\n            [RESOURCE_UTRIUM]: 0,\r\n            [RESOURCE_KEANIUM]: 0,\r\n            [RESOURCE_LEMERGIUM]: 0,\r\n            [RESOURCE_ZYNTHIUM]: 0,\r\n            [RESOURCE_CATALYST]: 0,\r\n        };\r\n        for (const reaction of reactionQueue) {\r\n            const ingredients = REAGENTS[reaction.mineralType];\r\n            for (const ingredient of ingredients) {\r\n                if (!REAGENTS[ingredient]) { // resource is base mineral\r\n                    requiredBasicMinerals[ingredient] += reaction.amount;\r\n                }\r\n            }\r\n        }\r\n        return requiredBasicMinerals;\r\n    }\r\n    /**\r\n     * Recursively generate a list of ingredients required to produce a compound\r\n     */\r\n    ingredientsList(mineral) {\r\n        if (!REAGENTS[mineral] || _.isEmpty(mineral)) {\r\n            return [];\r\n        }\r\n        else {\r\n            return this.ingredientsList(REAGENTS[mineral][0])\r\n                .concat(this.ingredientsList(REAGENTS[mineral][1]), mineral);\r\n        }\r\n    }\r\n};\r\nAbathur.settings = {\r\n    minBatchSize: 100,\r\n    maxBatchSize: 800,\r\n    sleepTime: 100,\r\n};\r\nAbathur = Abathur_1 = tslib_1.__decorate([\r\n    profile\r\n], Abathur);\r\nexport { Abathur };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/logistics/TradeNetwork.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/resources/map_resources.ts"]}
