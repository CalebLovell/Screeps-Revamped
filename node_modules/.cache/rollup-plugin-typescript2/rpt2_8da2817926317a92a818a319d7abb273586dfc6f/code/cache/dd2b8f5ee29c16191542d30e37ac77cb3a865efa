{"code":"/* tslint:disable:no-eval */\r\nimport { log } from '../console/log';\r\nimport { Segmenter } from '../memory/Segmenter';\r\nimport { alignedNewline } from '../utilities/stringConstants';\r\nimport { color } from '../utilities/utils';\r\nimport { MUON, MY_USERNAME } from '../~settings';\r\nconst DEBUG_SEGMENT = 97;\r\nconst DEBUG_TIMEOUT = 1000;\r\nconst NO_COMMAND = 'No command';\r\nconst defaultDebuggerMemory = {\r\n    username: undefined,\r\n    enabled: false,\r\n    expiration: 0,\r\n    command: undefined,\r\n    response: undefined,\r\n};\r\nconst DEBUGGER = color('[DEBUGGER]', '#ff00ff');\r\n/**\r\n * Debugging tool which lets me remotely debug other Overmind players' code by communicating through public memory\r\n * segments. Can be toggled on and off with console commands startRemoteDebugSession() and endRemoteDebugSession().\r\n */\r\nexport class RemoteDebugger {\r\n    constructor() {\r\n        if (!Memory.remoteDebugger) {\r\n            Memory.remoteDebugger = {};\r\n        }\r\n        _.defaultsDeep(Memory.remoteDebugger, defaultDebuggerMemory);\r\n    }\r\n    get memory() {\r\n        return Memory.remoteDebugger;\r\n    }\r\n    /**\r\n     * Push all commands from secret memory to public memory and clear secret memory commands\r\n     */\r\n    pushCommands_master() {\r\n        Segmenter.setSegmentProperty(DEBUG_SEGMENT, 'command', this.memory.command);\r\n        if (this.memory.command) {\r\n            log.info(`[DEBUGGER] Sending command: ${this.memory.command}`);\r\n        }\r\n        this.memory.command = undefined;\r\n    }\r\n    /**\r\n     * Fetch the response from the debugee\r\n     */\r\n    fetchResponse_master() {\r\n        const response = Segmenter.getForeignSegmentProperty('response');\r\n        return response;\r\n    }\r\n    /**\r\n     * Execute the commands you are given\r\n     */\r\n    fetchCommands_slave() {\r\n        const cmd = Segmenter.getForeignSegmentProperty('command');\r\n        if (cmd) {\r\n            log.info(`[DEBUGGER] Executing command: ${cmd}`);\r\n            const response = eval(cmd);\r\n            log.info(`[DEBUGGER] Relaying response: ${response}`);\r\n            this.memory.response = JSON.stringify(response);\r\n        }\r\n        else {\r\n            this.memory.response = NO_COMMAND;\r\n        }\r\n    }\r\n    /**\r\n     * Push the response from the last run command\r\n     */\r\n    pushResponse_slave() {\r\n        Segmenter.setSegmentProperty(DEBUG_SEGMENT, 'response', this.memory.response);\r\n        this.memory.response = undefined;\r\n    }\r\n    extendSession() {\r\n        this.memory.expiration = Game.time + DEBUG_TIMEOUT;\r\n    }\r\n    enable() {\r\n        this.memory.enabled = true;\r\n        this.memory.expiration = Game.time + DEBUG_TIMEOUT;\r\n        log.info(`[DEBUGGER] Starting remote debug session. Timeout: ${this.memory.expiration} ` + alignedNewline +\r\n            `Warning: this enables remote arbitrary code execution!`);\r\n    }\r\n    disable() {\r\n        this.memory.enabled = false;\r\n        this.memory.expiration = -1;\r\n        log.info(`[DEBUGGER] Remote debugging session ended`);\r\n    }\r\n    connect(username) {\r\n        this.memory.username = username;\r\n        this.memory.enabled = true;\r\n        this.memory.expiration = Game.time + DEBUG_TIMEOUT;\r\n        log.info(`[DEBUGGER] Starting remote debug session with ${username}. Timeout: ${this.memory.expiration}`);\r\n    }\r\n    cancelCommand() {\r\n        this.memory.command = undefined;\r\n    }\r\n    /* Register a debug command to be sent to the user */\r\n    debug(command) {\r\n        this.memory.command = command;\r\n        return `[DEBUGGER] Sending command next tick.`;\r\n    }\r\n    run_master() {\r\n        if (Game.time % 2 == 0) {\r\n            const response = this.fetchResponse_master();\r\n            if (response && response != NO_COMMAND) {\r\n                log.info(`[DEBUGGER] Response: ` + response);\r\n            }\r\n            this.pushCommands_master();\r\n        }\r\n    }\r\n    run_slave() {\r\n        if (Game.time % 2 == 1) {\r\n            this.fetchCommands_slave();\r\n            this.pushResponse_slave();\r\n        }\r\n    }\r\n    run() {\r\n        if (this.memory.enabled) {\r\n            // Run the debugger\r\n            if (MY_USERNAME == MUON) {\r\n                if (this.memory.username) {\r\n                    Segmenter.requestSegments(DEBUG_SEGMENT);\r\n                    Segmenter.requestForeignSegment(this.memory.username, DEBUG_SEGMENT);\r\n                    Segmenter.markSegmentAsPublic(DEBUG_SEGMENT);\r\n                    this.run_master();\r\n                }\r\n            }\r\n            else {\r\n                Segmenter.requestSegments(DEBUG_SEGMENT);\r\n                Segmenter.requestForeignSegment(MUON, DEBUG_SEGMENT);\r\n                Segmenter.markSegmentAsPublic(DEBUG_SEGMENT);\r\n                this.run_slave();\r\n            }\r\n            if (Game.time % 20 == 0) {\r\n                log.alert(`[DEBUGGER] Remote session is still enabled! Expiration: ${this.memory.expiration}`);\r\n            }\r\n            // Disable after timeout\r\n            if (!this.memory.expiration || Game.time > this.memory.expiration) {\r\n                this.disable();\r\n            }\r\n        }\r\n    }\r\n}\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/memory/Segmenter.ts","C:/git/Overmind/src/utilities/stringConstants.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/~settings.ts"]}
