{"code":"import * as tslib_1 from \"tslib\";\r\nvar Overseer_1;\r\nimport { Colony, ColonyStage } from './Colony';\r\nimport { log } from './console/log';\r\nimport { bodyCost } from './creepSetups/CreepSetup';\r\nimport { Roles } from './creepSetups/setups';\r\nimport { DirectiveClearRoom } from './directives/colony/clearRoom';\r\nimport { DirectiveColonize } from './directives/colony/colonize';\r\nimport { DirectiveOutpost } from './directives/colony/outpost';\r\nimport { DirectiveGuard } from './directives/defense/guard';\r\nimport { DirectiveInvasionDefense } from './directives/defense/invasionDefense';\r\nimport { DirectiveOutpostDefense } from './directives/defense/outpostDefense';\r\nimport { Notifier } from './directives/Notifier';\r\nimport { DirectiveBootstrap } from './directives/situational/bootstrap';\r\nimport { DirectiveNukeResponse } from './directives/situational/nukeResponse';\r\nimport { DirectiveTerminalEvacuateState } from './directives/terminalState/terminalState_evacuate';\r\nimport { RoomIntel } from './intel/RoomIntel';\r\nimport { LogisticsNetwork } from './logistics/LogisticsNetwork';\r\nimport { Autonomy, getAutonomyLevel, Mem } from './memory/Memory';\r\nimport { Pathing } from './movement/Pathing';\r\nimport { profile } from './profiler/decorator';\r\nimport { CombatPlanner } from './strategy/CombatPlanner';\r\nimport { Cartographer, ROOMTYPE_CONTROLLER, ROOMTYPE_SOURCEKEEPER } from './utilities/Cartographer';\r\nimport { derefCoords, hasJustSpawned, minBy, onPublicServer } from './utilities/utils';\r\nimport { MUON, MY_USERNAME, USE_TRY_CATCH } from './~settings';\r\nconst defaultOverseerMemory = {\r\n    suspendUntil: {},\r\n};\r\n/**\r\n * The Overseer object acts as a scheduler, running directives and overlords for all colonies each tick. It is also\r\n * in charge of starting new \"processes\" (directives) to respond to various situations.\r\n */\r\nlet Overseer = Overseer_1 = class Overseer {\r\n    constructor() {\r\n        this.memory = Mem.wrap(Memory, 'overseer', defaultOverseerMemory);\r\n        this.directives = [];\r\n        this.overlords = [];\r\n        this.overlordsByColony = {};\r\n        this.sorted = false;\r\n        this.notifier = new Notifier();\r\n        this.combatPlanner = new CombatPlanner();\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(Memory, 'overseer', defaultOverseerMemory);\r\n        this.notifier.clear();\r\n    }\r\n    try(callback, identifier) {\r\n        if (USE_TRY_CATCH) {\r\n            try {\r\n                callback();\r\n            }\r\n            catch (e) {\r\n                if (identifier) {\r\n                    e.name = `Caught unhandled exception at ${'' + callback} (identifier: ${identifier}): \\n`\r\n                        + e.name + '\\n' + e.stack;\r\n                }\r\n                else {\r\n                    e.name = `Caught unhandled exception at ${'' + callback}: \\n` + e.name + '\\n' + e.stack;\r\n                }\r\n                Overmind.exceptions.push(e);\r\n            }\r\n        }\r\n        else {\r\n            callback();\r\n        }\r\n    }\r\n    get colonies() {\r\n        return _.values(Overmind.colonies);\r\n    }\r\n    registerDirective(directive) {\r\n        this.directives.push(directive);\r\n    }\r\n    removeDirective(directive) {\r\n        _.remove(this.directives, dir => dir.name == directive.name);\r\n        for (const name in directive.overlords) {\r\n            this.removeOverlord(directive.overlords[name]);\r\n        }\r\n    }\r\n    registerOverlord(overlord) {\r\n        this.overlords.push(overlord);\r\n        if (!this.overlordsByColony[overlord.colony.name]) {\r\n            this.overlordsByColony[overlord.colony.name] = [];\r\n        }\r\n        this.overlordsByColony[overlord.colony.name].push(overlord);\r\n    }\r\n    getOverlordsForColony(colony) {\r\n        return this.overlordsByColony[colony.name];\r\n    }\r\n    removeOverlord(overlord) {\r\n        _.remove(this.overlords, o => o.ref == overlord.ref);\r\n        if (this.overlordsByColony[overlord.colony.name]) {\r\n            _.remove(this.overlordsByColony[overlord.colony.name], o => o.ref == overlord.ref);\r\n        }\r\n    }\r\n    isOverlordSuspended(overlord) {\r\n        if (this.memory.suspendUntil[overlord.ref]) {\r\n            if (Game.time < this.memory.suspendUntil[overlord.ref]) {\r\n                return true;\r\n            }\r\n            else {\r\n                delete this.memory.suspendUntil[overlord.ref];\r\n                return false;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    suspendOverlordFor(overlord, ticks) {\r\n        this.memory.suspendUntil[overlord.ref] = Game.time + ticks;\r\n    }\r\n    suspendOverlordUntil(overlord, untilTick) {\r\n        this.memory.suspendUntil[overlord.ref] = untilTick;\r\n    }\r\n    registerLogisticsRequests(colony) {\r\n        // Register logistics requests for all dropped resources and tombstones\r\n        for (const room of colony.rooms) {\r\n            // Pick up all nontrivial dropped resources\r\n            for (const resourceType in room.drops) {\r\n                for (const drop of room.drops[resourceType]) {\r\n                    if (drop.amount > LogisticsNetwork.settings.droppedEnergyThreshold\r\n                        || drop.resourceType != RESOURCE_ENERGY) {\r\n                        colony.logisticsNetwork.requestOutput(drop);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Place a logistics request directive for every tombstone with non-empty store that isn't on a container\r\n        for (const tombstone of colony.tombstones) {\r\n            if (_.sum(tombstone.store) > LogisticsNetwork.settings.droppedEnergyThreshold\r\n                || _.sum(tombstone.store) > tombstone.store.energy) {\r\n                if (colony.bunker && tombstone.pos.isEqualTo(colony.bunker.anchor))\r\n                    continue;\r\n                colony.logisticsNetwork.requestOutput(tombstone, { resourceType: 'all' });\r\n            }\r\n        }\r\n    }\r\n    handleBootstrapping(colony) {\r\n        // Bootstrap directive: in the event of catastrophic room crash, enter emergency spawn mode.\r\n        // Doesn't apply to incubating colonies.\r\n        if (!colony.isIncubating) {\r\n            const noQueen = colony.getCreepsByRole(Roles.queen).length == 0;\r\n            if (noQueen && colony.hatchery && !colony.spawnGroup) {\r\n                const setup = colony.hatchery.overlord.queenSetup;\r\n                const energyToMakeQueen = bodyCost(setup.generateBody(colony.room.energyCapacityAvailable));\r\n                if (colony.room.energyAvailable < energyToMakeQueen || hasJustSpawned()) {\r\n                    const result = DirectiveBootstrap.createIfNotPresent(colony.hatchery.pos, 'pos');\r\n                    if (typeof result == 'string' || result == OK) { // successfully made flag\r\n                        colony.hatchery.settings.suppressSpawning = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    handleOutpostDefense(colony) {\r\n        // Guard directive: defend your outposts and all rooms of colonies that you are incubating\r\n        for (const room of colony.outposts) {\r\n            // Handle player defense\r\n            if (room.dangerousPlayerHostiles.length > 0) {\r\n                DirectiveOutpostDefense.createIfNotPresent(Pathing.findPathablePosition(room.name), 'room');\r\n                return;\r\n            }\r\n            // Handle NPC invasion directives\r\n            if (Cartographer.roomType(room.name) != ROOMTYPE_SOURCEKEEPER) { // SK rooms can fend for themselves\r\n                const defenseFlags = _.filter(room.flags, flag => DirectiveGuard.filter(flag) ||\r\n                    DirectiveOutpostDefense.filter(flag));\r\n                if (room.dangerousHostiles.length > 0 && defenseFlags.length == 0) {\r\n                    DirectiveGuard.create(room.dangerousHostiles[0].pos);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    handleColonyInvasions(colony) {\r\n        // Defend against invasions in owned rooms\r\n        if (colony.room) {\r\n            // See if invasion is big enough to warrant creep defenses\r\n            const effectiveInvaderCount = _.sum(_.map(colony.room.hostiles, invader => invader.boosts.length > 0 ? 2 : 1));\r\n            const needsDefending = effectiveInvaderCount >= 3 || colony.room.dangerousPlayerHostiles.length > 0;\r\n            if (needsDefending) {\r\n                // Place defensive directive after hostiles have been present for a long enough time\r\n                const safetyData = RoomIntel.getSafetyData(colony.room.name);\r\n                const invasionIsPersistent = safetyData.unsafeFor > 20;\r\n                if (invasionIsPersistent) {\r\n                    DirectiveInvasionDefense.createIfNotPresent(colony.controller.pos, 'room');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    handleNukeResponse(colony) {\r\n        // Place nuke response directive if there is a nuke present in colony room\r\n        if (colony.room && colony.level >= DirectiveNukeResponse.requiredRCL) {\r\n            for (const nuke of colony.room.find(FIND_NUKES)) {\r\n                DirectiveNukeResponse.createIfNotPresent(nuke.pos, 'pos');\r\n            }\r\n        }\r\n    }\r\n    computePossibleOutposts(colony, depth = 3) {\r\n        return _.filter(Cartographer.findRoomsInRange(colony.room.name, depth), roomName => {\r\n            if (Cartographer.roomType(roomName) != ROOMTYPE_CONTROLLER) {\r\n                return false;\r\n            }\r\n            const alreadyAnOutpost = _.any(Overmind.cache.outpostFlags, flag => (flag.memory.setPosition || flag.pos).roomName == roomName);\r\n            const alreadyAColony = !!Overmind.colonies[roomName];\r\n            if (alreadyAColony || alreadyAnOutpost) {\r\n                return false;\r\n            }\r\n            const alreadyOwned = RoomIntel.roomOwnedBy(roomName);\r\n            const alreadyReserved = RoomIntel.roomReservedBy(roomName);\r\n            const disregardReservations = !onPublicServer() || MY_USERNAME == MUON;\r\n            if (alreadyOwned || (alreadyReserved && !disregardReservations)) {\r\n                return false;\r\n            }\r\n            const neighboringRooms = _.values(Game.map.describeExits(roomName));\r\n            const isReachableFromColony = _.any(neighboringRooms, r => colony.roomNames.includes(r));\r\n            return isReachableFromColony && Game.map.isRoomAvailable(roomName);\r\n        });\r\n    }\r\n    handleNewOutposts(colony) {\r\n        const numSources = _.sum(colony.roomNames, roomName => Memory.rooms[roomName] && Memory.rooms[roomName][\"s\" /* SOURCES */]\r\n            ? Memory.rooms[roomName][\"s\" /* SOURCES */].length\r\n            : 0);\r\n        const numRemotes = numSources - colony.room.sources.length;\r\n        if (numRemotes < Colony.settings.remoteSourcesByLevel[colony.level]) {\r\n            const possibleOutposts = this.computePossibleOutposts(colony);\r\n            const origin = colony.pos;\r\n            const bestOutpost = minBy(possibleOutposts, function (roomName) {\r\n                if (!Memory.rooms[roomName])\r\n                    return false;\r\n                const sourceCoords = Memory.rooms[roomName][\"s\" /* SOURCES */];\r\n                if (!sourceCoords)\r\n                    return false;\r\n                const sourcePositions = _.map(sourceCoords, src => derefCoords(src.c, roomName));\r\n                const sourceDistances = _.map(sourcePositions, pos => Pathing.distance(origin, pos));\r\n                if (_.any(sourceDistances, dist => dist == undefined || dist > Colony.settings.maxSourceDistance)) {\r\n                    return false;\r\n                }\r\n                return _.sum(sourceDistances) / sourceDistances.length;\r\n            });\r\n            if (bestOutpost) {\r\n                const pos = Pathing.findPathablePosition(bestOutpost);\r\n                log.info(`Colony ${colony.room.print} now remote mining from ${pos.print}`);\r\n                DirectiveOutpost.createIfNotPresent(pos, 'room', { memory: { [\"C\" /* COLONY */]: colony.name } });\r\n            }\r\n        }\r\n    }\r\n    /* Place new event-driven flags where needed to be instantiated on the next tick */\r\n    placeDirectives(colony) {\r\n        this.handleBootstrapping(colony);\r\n        this.handleOutpostDefense(colony);\r\n        this.handleColonyInvasions(colony);\r\n        this.handleNukeResponse(colony);\r\n        if (getAutonomyLevel() > Autonomy.Manual) {\r\n            if (Game.time % Overseer_1.settings.outpostCheckFrequency == 2 * colony.id) {\r\n                this.handleNewOutposts(colony);\r\n            }\r\n            // Place pioneer directives in case the colony doesn't have a spawn for some reason\r\n            if (Game.time % 25 == 0 && colony.spawns.length == 0 &&\r\n                !DirectiveClearRoom.isPresent(colony.pos, 'room')) {\r\n                // verify that there are no spawns (not just a caching glitch)\r\n                const spawns = Game.rooms[colony.name].find(FIND_MY_SPAWNS);\r\n                if (spawns.length == 0) {\r\n                    const pos = Pathing.findPathablePosition(colony.room.name);\r\n                    DirectiveColonize.createIfNotPresent(pos, 'room');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Safe mode condition =============================================================================================\r\n    handleSafeMode(colony) {\r\n        if (colony.stage == ColonyStage.Larva && onPublicServer()) {\r\n            return;\r\n        }\r\n        // Safe mode activates when there are dangerous player hostiles that can reach the spawn\r\n        const criticalStructures = _.compact([...colony.spawns,\r\n            colony.storage,\r\n            colony.terminal]);\r\n        for (const structure of criticalStructures) {\r\n            if (structure.hits < structure.hitsMax &&\r\n                structure.pos.findInRange(colony.room.dangerousPlayerHostiles, 2).length > 0) {\r\n                const ret = colony.controller.activateSafeMode();\r\n                if (ret != OK && !colony.controller.safeMode) {\r\n                    if (colony.terminal) {\r\n                        DirectiveTerminalEvacuateState.createIfNotPresent(colony.terminal.pos, 'room');\r\n                    }\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        const firstHostile = _.first(colony.room.dangerousPlayerHostiles);\r\n        if (firstHostile && colony.spawns[0]) {\r\n            const barriers = _.map(colony.room.barriers, barrier => barrier.pos);\r\n            if (Pathing.isReachable(firstHostile.pos, colony.spawns[0].pos, barriers)) {\r\n                const ret = colony.controller.activateSafeMode();\r\n                if (ret != OK && !colony.controller.safeMode) {\r\n                    if (colony.terminal) {\r\n                        DirectiveTerminalEvacuateState.createIfNotPresent(colony.terminal.pos, 'room');\r\n                    }\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Initialization ==================================================================================================\r\n    init() {\r\n        // Initialize directives\r\n        for (const directive of this.directives) {\r\n            directive.init();\r\n        }\r\n        // Sort overlords by priority if needed (assumes priority does not change after constructor phase\r\n        if (!this.sorted) {\r\n            this.overlords.sort((o1, o2) => o1.priority - o2.priority);\r\n            for (const colName in this.overlordsByColony) {\r\n                this.overlordsByColony[colName].sort((o1, o2) => o1.priority - o2.priority);\r\n            }\r\n            this.sorted = true;\r\n        }\r\n        // Initialize overlords\r\n        for (const overlord of this.overlords) {\r\n            if (!this.isOverlordSuspended(overlord)) {\r\n                overlord.preInit();\r\n                this.try(() => overlord.init());\r\n            }\r\n        }\r\n        // Register cleanup requests to logistics network\r\n        for (const colony of this.colonies) {\r\n            this.registerLogisticsRequests(colony);\r\n        }\r\n    }\r\n    // Operation =======================================================================================================\r\n    run() {\r\n        for (const directive of this.directives) {\r\n            directive.run();\r\n        }\r\n        for (const overlord of this.overlords) {\r\n            if (!this.isOverlordSuspended(overlord)) {\r\n                this.try(() => overlord.run());\r\n            }\r\n        }\r\n        for (const colony of this.colonies) {\r\n            this.handleSafeMode(colony);\r\n            this.placeDirectives(colony);\r\n        }\r\n    }\r\n    getCreepReport(colony) {\r\n        const spoopyBugFix = false;\r\n        const roleOccupancy = {};\r\n        for (const overlord of this.overlordsByColony[colony.name]) {\r\n            for (const role in overlord.creepUsageReport) {\r\n                const report = overlord.creepUsageReport[role];\r\n                if (report == undefined) {\r\n                    if (Game.time % 100 == 0) {\r\n                        log.info(`Role ${role} is not reported by ${overlord.ref}!`);\r\n                    }\r\n                }\r\n                else {\r\n                    if (roleOccupancy[role] == undefined) {\r\n                        roleOccupancy[role] = [0, 0];\r\n                    }\r\n                    roleOccupancy[role][0] += report[0];\r\n                    roleOccupancy[role][1] += report[1];\r\n                    if (spoopyBugFix) { // bizzarely, if you comment these lines out, the creep report is incorrect\r\n                        log.debug(`report: ${JSON.stringify(report)}`);\r\n                        log.debug(`occupancy: ${JSON.stringify(roleOccupancy)}`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // let padLength = _.max(_.map(_.keys(roleOccupancy), str => str.length)) + 2;\r\n        const roledata = [];\r\n        for (const role in roleOccupancy) {\r\n            const [current, needed] = roleOccupancy[role];\r\n            // if (needed > 0) {\r\n            // \tstringReport.push('| ' + `${role}:`.padRight(padLength) +\r\n            // \t\t\t\t\t  `${Math.floor(100 * current / needed)}%`.padLeft(4));\r\n            // }\r\n            roledata.push([role, `${current}/${needed}`]);\r\n        }\r\n        return roledata;\r\n    }\r\n    visuals() {\r\n        for (const directive of this.directives) {\r\n            directive.visuals();\r\n        }\r\n        for (const overlord of this.overlords) {\r\n            overlord.visuals();\r\n        }\r\n        this.notifier.visuals();\r\n        // for (let colony of this.colonies) {\r\n        // \tthis.drawCreepReport(colony);\r\n        // }\r\n    }\r\n};\r\nOverseer.settings = {\r\n    outpostCheckFrequency: onPublicServer() ? 250 : 100\r\n};\r\nOverseer = Overseer_1 = tslib_1.__decorate([\r\n    profile\r\n], Overseer);\r\nexport { Overseer };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/creepSetups/CreepSetup.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/directives/colony/clearRoom.ts","C:/git/Overmind/src/directives/colony/colonize.ts","C:/git/Overmind/src/directives/colony/outpost.ts","C:/git/Overmind/src/directives/defense/guard.ts","C:/git/Overmind/src/directives/defense/invasionDefense.ts","C:/git/Overmind/src/directives/defense/outpostDefense.ts","C:/git/Overmind/src/directives/Directive.ts","C:/git/Overmind/src/directives/Notifier.ts","C:/git/Overmind/src/directives/situational/bootstrap.ts","C:/git/Overmind/src/directives/situational/nukeResponse.ts","C:/git/Overmind/src/directives/terminalState/terminalState_evacuate.ts","C:/git/Overmind/src/intel/RoomIntel.ts","C:/git/Overmind/src/logistics/LogisticsNetwork.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/overlords/Overlord.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/strategy/CombatPlanner.ts","C:/git/Overmind/src/utilities/Cartographer.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/~settings.ts"]}
