{"code":"import * as tslib_1 from \"tslib\";\r\nvar TerminalNetwork_1;\r\nimport { assimilationLocked } from '../assimilation/decorator';\r\nimport { $ } from '../caching/GlobalCache';\r\nimport { getAllColonies } from '../Colony';\r\nimport { log } from '../console/log';\r\nimport { Mem } from '../memory/Memory';\r\nimport { profile } from '../profiler/decorator';\r\nimport { Abathur } from '../resources/Abathur';\r\nimport { RESOURCE_IMPORTANCE } from '../resources/map_resources';\r\nimport { alignedNewline, bullet, rightArrow } from '../utilities/stringConstants';\r\nimport { maxBy, mergeSum, minBy, minMax } from '../utilities/utils';\r\nimport { Energetics } from './Energetics';\r\nimport { MAX_ENERGY_BUY_ORDERS, MAX_ENERGY_SELL_ORDERS, TraderJoe } from './TradeNetwork';\r\nconst TerminalNetworkMemoryDefaults = {\r\n    equalizeIndex: 0\r\n};\r\nconst TerminalNetworkStatsDefaults = {\r\n    transfers: {\r\n        costs: {},\r\n    },\r\n};\r\nfunction colonyOf(terminal) {\r\n    return Overmind.colonies[terminal.room.name];\r\n}\r\nfunction wantedAmount(colony, resource) {\r\n    return Abathur.stockAmount(resource) - (colony.assets[resource] || 0);\r\n}\r\n/**\r\n * The terminal network controls inter-colony resource transfers and requests, equalizing resources between rooms and\r\n * responding to on-demand resource requests\r\n */\r\nlet TerminalNetwork = TerminalNetwork_1 = class TerminalNetwork {\r\n    constructor(terminals) {\r\n        this.allTerminals = terminals;\r\n        this.terminals = _.clone(terminals);\r\n        this.readyTerminals = _.filter(terminals, t => t.cooldown == 0);\r\n        this.memory = Mem.wrap(Memory.Overmind, 'terminalNetwork', TerminalNetworkMemoryDefaults);\r\n        this.stats = Mem.wrap(Memory.stats.persistent, 'terminalNetwork', TerminalNetworkStatsDefaults, true);\r\n        this.alreadyReceived = [];\r\n        this.alreadySent = [];\r\n        this.exceptionTerminals = {}; // populated in init()\r\n        this.assets = {}; // populated in init()\r\n        this.notifications = [];\r\n        this.averageFullness = _.sum(this.terminals, t => _.sum(t.store) / t.storeCapacity) / this.terminals.length;\r\n    }\r\n    refresh() {\r\n        $.refresh(this, 'allTerminals');\r\n        this.terminals = _.clone(this.allTerminals);\r\n        this.readyTerminals = _.filter(this.terminals, t => t.cooldown == 0);\r\n        this.memory = Mem.wrap(Memory.Overmind, 'terminalNetwork', TerminalNetworkMemoryDefaults);\r\n        this.stats = Mem.wrap(Memory.stats.persistent, 'terminalNetwork', TerminalNetworkStatsDefaults);\r\n        this.alreadyReceived = [];\r\n        this.alreadySent = [];\r\n        this.exceptionTerminals = {}; // populated in init()\r\n        this.assets = {}; // populated in init()\r\n        this.notifications = [];\r\n        this.averageFullness = _.sum(this.terminals, t => _.sum(t.store) / t.storeCapacity) / this.terminals.length;\r\n    }\r\n    /* Summarizes the total of all resources currently in a colony store structure */\r\n    getAllAssets() {\r\n        return mergeSum(_.map(this.terminals, terminal => colonyOf(terminal).assets));\r\n    }\r\n    logTransfer(resourceType, amount, origin, destination) {\r\n        if (!this.stats.transfers[resourceType])\r\n            this.stats.transfers[resourceType] = {};\r\n        if (!this.stats.transfers[resourceType][origin])\r\n            this.stats.transfers[resourceType][origin] = {};\r\n        if (!this.stats.transfers[resourceType][origin][destination]) {\r\n            this.stats.transfers[resourceType][origin][destination] = 0;\r\n        }\r\n        this.stats.transfers[resourceType][origin][destination] += amount;\r\n        this.logTransferCosts(amount, origin, destination);\r\n    }\r\n    logTransferCosts(amount, origin, destination) {\r\n        if (!this.stats.transfers.costs[origin])\r\n            this.stats.transfers.costs[origin] = {};\r\n        if (!this.stats.transfers.costs[origin][destination])\r\n            this.stats.transfers.costs[origin][destination] = 0;\r\n        const transactionCost = Game.market.calcTransactionCost(amount, origin, destination);\r\n        this.stats.transfers.costs[origin][destination] += transactionCost;\r\n    }\r\n    notify(msg) {\r\n        this.notifications.push(bullet + msg);\r\n    }\r\n    /**\r\n     * Whether the terminal is actively requesting energy\r\n     */\r\n    terminalNeedsEnergy(terminal) {\r\n        return terminal.energy < Energetics.settings.terminal.energy.inThreshold;\r\n    }\r\n    /**\r\n     * Amount of space available in storage and terminal\r\n     */\r\n    remainingRoomCapacity(room) {\r\n        let remainingCapacity = 0;\r\n        if (room.storage) {\r\n            remainingCapacity += room.storage.storeCapacity - _.sum(room.storage.store);\r\n        }\r\n        if (room.terminal) {\r\n            remainingCapacity += room.terminal.storeCapacity - _.sum(room.terminal.store);\r\n        }\r\n        return remainingCapacity;\r\n    }\r\n    /**\r\n     * Amount of energy in storage and terminal\r\n     */\r\n    energyInRoom(room) {\r\n        let energyInRoom = 0;\r\n        if (room.storage) {\r\n            energyInRoom += room.storage.energy;\r\n        }\r\n        if (room.terminal) {\r\n            energyInRoom += room.terminal.energy;\r\n        }\r\n        return energyInRoom;\r\n    }\r\n    /**\r\n     * Transfer resources from one terminal to another, logging the results\r\n     */\r\n    transfer(sender, receiver, resourceType, amount, description) {\r\n        const cost = Game.market.calcTransactionCost(amount, sender.room.name, receiver.room.name);\r\n        const response = sender.send(resourceType, amount, receiver.room.name);\r\n        if (response == OK) {\r\n            let msg = `${sender.room.print} ${rightArrow} ${amount} ${resourceType} ${rightArrow} ` +\r\n                `${receiver.room.print} `;\r\n            if (description) {\r\n                msg += `(for ${description})`;\r\n            }\r\n            this.notify(msg);\r\n            // log.info(`Sent ${amount} ${resourceType} from ${sender.room.print} to ` +\r\n            // \t\t `${receiver.room.print}. Fee: ${cost}.`);\r\n            this.logTransfer(resourceType, amount, sender.room.name, receiver.room.name);\r\n            this.alreadySent.push(sender);\r\n            this.alreadyReceived.push(receiver);\r\n            _.remove(this.readyTerminals, terminal => terminal.id == sender.id);\r\n        }\r\n        else {\r\n            log.warning(`Could not send ${amount} ${resourceType} from ${sender.room.print} to ` +\r\n                `${receiver.room.print}! Response: ${response}`);\r\n        }\r\n        return response;\r\n    }\r\n    /**\r\n     * Request resources from the terminal network, purchasing from market if unavailable and allowable\r\n     */\r\n    requestResource(receiver, resourceType, amount, allowBuy = true, minDifference = 4000) {\r\n        if (this.exceptionTerminals[receiver.ref]) {\r\n            return; // don't send to abandoning terminals\r\n        }\r\n        amount = Math.max(amount, TERMINAL_MIN_SEND);\r\n        const possibleSenders = _.filter(this.terminals, terminal => (terminal.store[resourceType] || 0) > amount + minDifference &&\r\n            terminal.cooldown == 0 && !this.alreadySent.includes(terminal) &&\r\n            terminal.id != receiver.id);\r\n        const sender = maxBy(possibleSenders, t => (t.store[resourceType] || 0));\r\n        if (sender) {\r\n            this.transfer(sender, receiver, resourceType, amount, 'resource request');\r\n        }\r\n        else if (allowBuy) {\r\n            Overmind.tradeNetwork.buy(receiver, resourceType, amount);\r\n        }\r\n    }\r\n    /**\r\n     * Sell excess minerals on the market\r\n     */\r\n    handleExcess(terminal, threshold = 25000) {\r\n        const terminalNearCapacity = _.sum(terminal.store) > 0.95 * terminal.storeCapacity;\r\n        for (const resource in terminal.store) {\r\n            if (resource == RESOURCE_POWER) {\r\n                continue;\r\n            }\r\n            if (resource == RESOURCE_ENERGY) {\r\n                let energyThreshold = Energetics.settings.terminal.energy.outThreshold;\r\n                if (terminalNearCapacity) { // if you're close to full, be more agressive with selling energy\r\n                    energyThreshold = Energetics.settings.terminal.energy.equilibrium\r\n                        + Energetics.settings.terminal.energy.tolerance;\r\n                }\r\n                const amount = Energetics.settings.terminal.energy.tradeAmount;\r\n                if (terminal.store[RESOURCE_ENERGY] > energyThreshold) {\r\n                    // don't do anything if you have storage that is below energy cap and energy can be moved there\r\n                    const storage = colonyOf(terminal).storage;\r\n                    const storageEnergyCap = Energetics.settings.storage.total.cap;\r\n                    if (!storage || storage.energy >= storageEnergyCap) {\r\n                        if (terminalNearCapacity) { // just get rid of stuff at high capacities\r\n                            const response = Overmind.tradeNetwork.sellDirectly(terminal, RESOURCE_ENERGY, amount, true);\r\n                            if (response == OK)\r\n                                return;\r\n                        }\r\n                        else {\r\n                            const response = Overmind.tradeNetwork.sell(terminal, RESOURCE_ENERGY, amount, MAX_ENERGY_SELL_ORDERS);\r\n                            if (response == OK)\r\n                                return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (terminal.store[resource] > threshold) {\r\n                    const receiver = maxBy(this.terminals, terminal => wantedAmount(colonyOf(terminal), resource));\r\n                    if (receiver && wantedAmount(colonyOf(receiver), resource) > TERMINAL_MIN_SEND) {\r\n                        // Try to send internally first\r\n                        const response = this.transfer(terminal, receiver, resource, 1000, 'excess resources');\r\n                        if (response == OK)\r\n                            return;\r\n                    }\r\n                    else {\r\n                        // Sell excess\r\n                        if (terminalNearCapacity || terminal.store[resource] > 2 * threshold) {\r\n                            const response = Overmind.tradeNetwork.sellDirectly(terminal, resource, 1000);\r\n                            if (response == OK)\r\n                                return;\r\n                        }\r\n                        else {\r\n                            const response = Overmind.tradeNetwork.sell(terminal, resource, 10000);\r\n                            if (response == OK)\r\n                                return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // private sendExcessEnergy(terminal: StructureTerminal): void {\r\n    // \tlet {sendSize, inThreshold, outThreshold, equilibrium} = Energetics.settings.terminal.energy;\r\n    // \t// See if there are any rooms actively needing energy first\r\n    // \tlet needyTerminals = _.filter(this.terminals, t =>\r\n    // \t\tt != terminal && this.terminalNeedsEnergy(t) && !this.alreadyReceived.includes(t));\r\n    // \tif (needyTerminals.length > 0) {\r\n    // \t\t// Send to the most cost-efficient needy terminal\r\n    // \t\tlet bestTerminal = minBy(needyTerminals, (receiver: StructureTerminal) =>\r\n    // \t\t\tGame.market.calcTransactionCost(sendSize, terminal.room.name, receiver.room.name));\r\n    // \t\tif (bestTerminal) this.transferEnergy(terminal, bestTerminal);\r\n    // \t} else {\r\n    // \t\t// Send to the terminal with least energy that is not already trying to get rid of stuff\r\n    // \t\tlet okTerminals = _.filter(this.terminals, t =>\r\n    // \t\t\tt != terminal && t.store.energy < outThreshold - sendSize && !this.alreadyReceived.includes(t));\r\n    // \t\tlet bestTerminal = minBy(okTerminals, (receiver: StructureTerminal) => this.energyInRoom(receiver.room));\r\n    // \t\tif (bestTerminal) this.transferEnergy(terminal, bestTerminal);\r\n    // \t}\r\n    // }\r\n    /**\r\n     * Equalize resource amounts of each type through all non-exceptional terminals in the network\r\n     */\r\n    equalize(resourceType, terminals = this.terminals, verbose = false) {\r\n        log.debug(`Equalizing ${resourceType} within terminal network`);\r\n        const maxSendSize = resourceType == RESOURCE_ENERGY ? TerminalNetwork_1.settings.equalize.maxEnergySendSize\r\n            : TerminalNetwork_1.settings.equalize.maxMineralSendSize;\r\n        const averageAmount = _.sum(_.map(terminals, terminal => (colonyOf(terminal).assets[resourceType] || 0))) / terminals.length;\r\n        const terminalsByResource = _.sortBy(terminals, terminal => (colonyOf(terminal).assets[resourceType] || 0));\r\n        if (verbose)\r\n            log.debug(_.map(terminalsByResource, t => `${t.room.name}: ${colonyOf(t).assets[resourceType]}`));\r\n        // Min-max match terminals\r\n        const receivers = _.take(terminalsByResource, Math.floor(terminalsByResource.length / 2));\r\n        terminalsByResource.reverse();\r\n        const senders = _.take(terminalsByResource, Math.floor(terminalsByResource.length / 2));\r\n        if (verbose)\r\n            log.debug(`Receivers: ${_.map(receivers, t => t.room.print)}`);\r\n        if (verbose)\r\n            log.debug(`Senders:   ${_.map(senders, t => t.room.print)}`);\r\n        for (const [sender, receiver] of _.zip(senders, receivers)) {\r\n            if (verbose)\r\n                log.debug(` > ${sender.room.print} to ${receiver.room.print}...`);\r\n            const senderAmount = colonyOf(sender).assets[resourceType] || 0;\r\n            const receiverAmount = colonyOf(receiver).assets[resourceType] || 0;\r\n            const tolerance = TerminalNetwork_1.settings.equalize.tolerance[resourceType]\r\n                || TerminalNetwork_1.settings.equalize.tolerance.default;\r\n            if (verbose) {\r\n                log.debug(`    sender amt: ${senderAmount}  receiver amt: ${receiverAmount}  tolerance: ${tolerance}`);\r\n            }\r\n            if (senderAmount - receiverAmount < tolerance\r\n                && receiverAmount > Energetics.settings.terminal.energy.inThreshold) {\r\n                if (verbose)\r\n                    log.debug(`   Low tolerance`);\r\n                continue; // skip if colonies are close to equilibrium\r\n            }\r\n            const senderSurplus = senderAmount - averageAmount;\r\n            const receiverDeficit = averageAmount - receiverAmount;\r\n            let sendAmount = Math.min(senderSurplus, receiverDeficit, maxSendSize);\r\n            sendAmount = Math.floor(Math.max(sendAmount, 0));\r\n            const sendCost = Game.market.calcTransactionCost(sendAmount, sender.room.name, receiver.room.name);\r\n            sendAmount = Math.min(sendAmount, (sender.store[resourceType] || 0) - sendCost - 10, (receiver.storeCapacity - _.sum(receiver.store)));\r\n            if (sendAmount < TERMINAL_MIN_SEND) {\r\n                if (verbose)\r\n                    log.debug(`    Size too small`);\r\n                continue;\r\n            }\r\n            const ret = this.transfer(sender, receiver, resourceType, sendAmount, 'equalize');\r\n            if (verbose)\r\n                log.debug(`Response: ${ret}`);\r\n        }\r\n    }\r\n    equalizeCycle() {\r\n        const equalizeResources = TerminalNetwork_1.settings.equalize.resources;\r\n        if (this.memory.equalizeIndex >= equalizeResources.length) {\r\n            this.memory.equalizeIndex = 0;\r\n        }\r\n        // Equalize current resource type\r\n        const resource = equalizeResources[this.memory.equalizeIndex];\r\n        const terminals = resource == RESOURCE_POWER ? _.filter(this.terminals, t => colonyOf(t).powerSpawn != undefined)\r\n            : this.terminals;\r\n        if (resource) { // resource is undefined if there is nothing to equalize\r\n            this.equalize(resource, terminals);\r\n        }\r\n        // Determine next resource type to equalize; most recent resourceType gets cycled to end\r\n        const resourceEqualizeOrder = equalizeResources.slice(this.memory.equalizeIndex + 1)\r\n            .concat(equalizeResources.slice(0, this.memory.equalizeIndex + 1));\r\n        const allColonies = getAllColonies();\r\n        const nextResourceType = _.find(resourceEqualizeOrder, resource => {\r\n            if (resource == RESOURCE_ENERGY) {\r\n                return true;\r\n            }\r\n            const amounts = _.map(this.terminals, terminal => colonyOf(terminal).assets[resource] || 0);\r\n            const tolerance = TerminalNetwork_1.settings.equalize.tolerance[resource]\r\n                || TerminalNetwork_1.settings.equalize.tolerance.default;\r\n            return _.max(amounts) - _.min(amounts) > tolerance;\r\n        });\r\n        // Set next equalize resource index\r\n        this.memory.equalizeIndex = _.findIndex(equalizeResources, resource => resource == nextResourceType);\r\n    }\r\n    /**\r\n     * Register a terminal to be placed in an exceptional state\r\n     */\r\n    registerTerminalState(terminal, state) {\r\n        this.exceptionTerminals[terminal.ref] = state;\r\n        colonyOf(terminal).terminalState = state;\r\n        _.remove(this.terminals, t => t.id == terminal.id);\r\n    }\r\n    /**\r\n     * Handles exceptional terminal states\r\n     */\r\n    handleTerminalState(terminal, state) {\r\n        for (const resourceType of RESOURCE_IMPORTANCE) {\r\n            const maxSendSize = resourceType == RESOURCE_ENERGY ? TerminalNetwork_1.settings.equalize.maxEnergySendSize\r\n                : TerminalNetwork_1.settings.equalize.maxMineralSendSize;\r\n            const amount = (terminal.store[resourceType] || 0);\r\n            const targetAmount = state.amounts[resourceType] || 0;\r\n            const tolerance = targetAmount == 0 ? TERMINAL_MIN_SEND : state.tolerance;\r\n            // Terminal input state - request resources be sent to this colony\r\n            if (state.type == 'in' || state.type == 'in/out') {\r\n                if (amount < targetAmount - tolerance) {\r\n                    // Request needed resources from most plentiful colony\r\n                    const sender = maxBy(this.readyTerminals, t => t.store[resourceType] || 0);\r\n                    if (sender) {\r\n                        const receiveAmount = minMax(targetAmount - amount, TERMINAL_MIN_SEND, maxSendSize);\r\n                        if ((sender.store[resourceType] || 0) > TERMINAL_MIN_SEND) {\r\n                            this.transfer(sender, terminal, resourceType, receiveAmount, 'exception state in');\r\n                            _.remove(this.readyTerminals, t => t.ref == sender.ref);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Terminal output state - push resources away from this colony\r\n            if (state.type == 'out' || state.type == 'in/out') {\r\n                if (terminal.cooldown == 0 && amount > targetAmount + tolerance) {\r\n                    const receiver = minBy(this.terminals, t => _.sum(t.store));\r\n                    if (receiver) {\r\n                        let sendAmount;\r\n                        if (resourceType == RESOURCE_ENERGY) {\r\n                            const cost = Game.market.calcTransactionCost(amount, terminal.room.name, receiver.room.name);\r\n                            sendAmount = minMax(amount - targetAmount - cost, TERMINAL_MIN_SEND, maxSendSize);\r\n                        }\r\n                        else {\r\n                            sendAmount = minMax(amount - targetAmount, TERMINAL_MIN_SEND, maxSendSize);\r\n                        }\r\n                        if (receiver.storeCapacity - _.sum(receiver.store) > sendAmount) {\r\n                            this.transfer(terminal, receiver, resourceType, sendAmount, 'exception state out');\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    init() {\r\n        this.assets = this.getAllAssets();\r\n    }\r\n    run() {\r\n        // Handle terminals with special operational states\r\n        for (const terminalID in this.exceptionTerminals) {\r\n            this.handleTerminalState(deref(terminalID), this.exceptionTerminals[terminalID]);\r\n        }\r\n        // Equalize resources\r\n        if (Game.time % TerminalNetwork_1.settings.equalize.frequency == 0) {\r\n            this.equalizeCycle();\r\n        }\r\n        // else if (Game.time % this.settings.equalize.frequency == 20) {\r\n        // \tlet powerTerminals = _.filter(this.terminals, t => colonyOf(t).powerSpawn != undefined);\r\n        // \tthis.equalize(RESOURCE_POWER, powerTerminals);\r\n        // }\r\n        else {\r\n            // Get rid of excess resources as needed\r\n            const terminalToSellExcess = this.terminals[Game.time % this.terminals.length];\r\n            if (terminalToSellExcess && terminalToSellExcess.cooldown == 0) {\r\n                this.handleExcess(terminalToSellExcess);\r\n            }\r\n            // Order more energy if needed\r\n            if (Game.market.credits > TraderJoe.settings.market.energyCredits) {\r\n                const averageEnergy = _.sum(this.terminals, terminal => colonyOf(terminal).assets[RESOURCE_ENERGY] || 0)\r\n                    / this.terminals.length;\r\n                if (averageEnergy < TerminalNetwork_1.settings.buyEnergyThreshold) {\r\n                    const poorestTerminal = minBy(this.terminals, terminal => colonyOf(terminal).assets[RESOURCE_ENERGY] || 0);\r\n                    if (poorestTerminal) {\r\n                        const amount = Energetics.settings.terminal.energy.tradeAmount;\r\n                        Overmind.tradeNetwork.maintainBuyOrder(poorestTerminal, RESOURCE_ENERGY, amount, MAX_ENERGY_BUY_ORDERS);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Do notifications\r\n        if (this.notifications.length > 0) {\r\n            log.info(`Terminal network activity: ` + alignedNewline + this.notifications.join(alignedNewline));\r\n        }\r\n    }\r\n};\r\nTerminalNetwork.settings = {\r\n    equalize: {\r\n        frequency: 2 * (TERMINAL_COOLDOWN + 1),\r\n        maxEnergySendSize: 25000,\r\n        maxMineralSendSize: 5000,\r\n        tolerance: {\r\n            [RESOURCE_ENERGY]: 100000,\r\n            [RESOURCE_POWER]: 2000,\r\n            default: 5000\r\n        },\r\n        resources: [\r\n            RESOURCE_ENERGY,\r\n            RESOURCE_POWER,\r\n            RESOURCE_CATALYST,\r\n            RESOURCE_ZYNTHIUM,\r\n            RESOURCE_LEMERGIUM,\r\n            RESOURCE_KEANIUM,\r\n            RESOURCE_UTRIUM,\r\n            RESOURCE_OXYGEN,\r\n            RESOURCE_HYDROGEN,\r\n        ],\r\n    },\r\n    buyEnergyThreshold: 200000,\r\n};\r\nTerminalNetwork = TerminalNetwork_1 = tslib_1.__decorate([\r\n    profile,\r\n    assimilationLocked\r\n], TerminalNetwork);\r\nexport { TerminalNetwork };\r\n","references":["C:/git/Overmind/src/assimilation/decorator.ts","C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/resources/Abathur.ts","C:/git/Overmind/src/resources/map_resources.ts","C:/git/Overmind/src/utilities/stringConstants.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/logistics/Energetics.ts","C:/git/Overmind/src/logistics/TradeNetwork.ts"]}
