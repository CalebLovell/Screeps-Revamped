{"code":"import * as tslib_1 from \"tslib\";\r\nvar Zerg_1;\r\nimport { log } from '../console/log';\r\nimport { isCreep, isZerg } from '../declarations/typeGuards';\r\nimport { CombatIntel } from '../intel/CombatIntel';\r\nimport { Movement } from '../movement/Movement';\r\nimport { profile } from '../profiler/decorator';\r\nimport { initializeTask } from '../tasks/initializer';\r\nimport { NEW_OVERMIND_INTERVAL } from '../~settings';\r\nexport function getOverlord(creep) {\r\n    if (creep.memory[\"O\" /* OVERLORD */]) {\r\n        return Overmind.overlords[creep.memory[\"O\" /* OVERLORD */]] || null;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexport function setOverlord(creep, newOverlord) {\r\n    // Remove cache references to old assignments\r\n    const roleName = creep.memory.role;\r\n    const ref = creep.memory[\"O\" /* OVERLORD */];\r\n    const oldOverlord = ref ? Overmind.overlords[ref] : null;\r\n    if (ref && Overmind.cache.overlords[ref] && Overmind.cache.overlords[ref][roleName]) {\r\n        _.remove(Overmind.cache.overlords[ref][roleName], name => name == creep.name);\r\n    }\r\n    if (newOverlord) {\r\n        // Change to the new overlord's colony\r\n        creep.memory[\"C\" /* COLONY */] = newOverlord.colony.name;\r\n        // Change assignments in memory\r\n        creep.memory[\"O\" /* OVERLORD */] = newOverlord.ref;\r\n        // Update the cache references\r\n        if (!Overmind.cache.overlords[newOverlord.ref]) {\r\n            Overmind.cache.overlords[newOverlord.ref] = {};\r\n        }\r\n        if (!Overmind.cache.overlords[newOverlord.ref][roleName]) {\r\n            Overmind.cache.overlords[newOverlord.ref][roleName] = [];\r\n        }\r\n        Overmind.cache.overlords[newOverlord.ref][roleName].push(creep.name);\r\n    }\r\n    else {\r\n        creep.memory[\"O\" /* OVERLORD */] = null;\r\n    }\r\n    if (oldOverlord)\r\n        oldOverlord.recalculateCreeps();\r\n    if (newOverlord)\r\n        newOverlord.recalculateCreeps();\r\n}\r\nexport function normalizeZerg(creep) {\r\n    return Overmind.zerg[creep.name] || creep;\r\n}\r\nexport function toCreep(creep) {\r\n    return isZerg(creep) ? creep.creep : creep;\r\n}\r\n// Last pipeline is more complex because it depends on the energy a creep has; sidelining this for now\r\nconst actionPipelines = [\r\n    ['harvest', 'attack', 'build', 'repair', 'dismantle', 'attackController', 'rangedHeal', 'heal'],\r\n    ['rangedAttack', 'rangedMassAttack', 'build', 'repair', 'rangedHeal'],\r\n];\r\nconst RANGES = {\r\n    BUILD: 3,\r\n    REPAIR: 3,\r\n    TRANSFER: 1,\r\n    WITHDRAW: 1,\r\n    HARVEST: 1,\r\n    DROP: 0,\r\n};\r\n/**\r\n * The Zerg class is a wrapper for owned creeps and contains all wrapped creep methods and many additional methods for\r\n * direct control of a creep.\r\n */\r\nlet Zerg = Zerg_1 = class Zerg {\r\n    constructor(creep, notifyWhenAttacked = true) {\r\n        // Copy over creep references\r\n        this.creep = creep;\r\n        this.body = creep.body;\r\n        this.carry = creep.carry;\r\n        this.carryCapacity = creep.carryCapacity;\r\n        this.fatigue = creep.fatigue;\r\n        this.hits = creep.hits;\r\n        this.hitsMax = creep.hitsMax;\r\n        this.id = creep.id;\r\n        this.memory = creep.memory;\r\n        this.name = creep.name;\r\n        this.pos = creep.pos;\r\n        this.nextPos = creep.pos;\r\n        this.ref = creep.ref;\r\n        this.roleName = creep.memory.role;\r\n        this.room = creep.room;\r\n        this.saying = creep.saying;\r\n        this.spawning = creep.spawning;\r\n        this.ticksToLive = creep.ticksToLive;\r\n        // Extra properties\r\n        this.lifetime = this.getBodyparts(CLAIM) > 0 ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;\r\n        this.actionLog = {};\r\n        this.blockMovement = false;\r\n        // Register global references\r\n        Overmind.zerg[this.name] = this;\r\n        global[this.name] = this;\r\n        // Handle attack notification when at lifetime - 1\r\n        if (!notifyWhenAttacked && (this.ticksToLive || 0) >= this.lifetime - (NEW_OVERMIND_INTERVAL + 1)) {\r\n            // creep.notifyWhenAttacked only uses the 0.2CPU intent cost if it changes the intent value\r\n            this.notifyWhenAttacked(notifyWhenAttacked);\r\n        }\r\n    }\r\n    /**\r\n     * Refresh all changeable properties of the creep or delete from Overmind and global when dead\r\n     */\r\n    refresh() {\r\n        const creep = Game.creeps[this.name];\r\n        if (creep) {\r\n            this.creep = creep;\r\n            this.pos = creep.pos;\r\n            this.nextPos = creep.pos;\r\n            this.body = creep.body;\r\n            this.carry = creep.carry;\r\n            this.carryCapacity = creep.carryCapacity;\r\n            this.fatigue = creep.fatigue;\r\n            this.hits = creep.hits;\r\n            this.memory = creep.memory;\r\n            this.roleName = creep.memory.role;\r\n            this.room = creep.room;\r\n            this.saying = creep.saying;\r\n            this.spawning = creep.spawning;\r\n            this.ticksToLive = creep.ticksToLive;\r\n            this.actionLog = {};\r\n            this.blockMovement = false;\r\n            this._task = null; // todo\r\n        }\r\n        else {\r\n            log.debug(`Deleting from global`);\r\n            delete Overmind.zerg[this.name];\r\n            delete global[this.name];\r\n        }\r\n    }\r\n    debug(...args) {\r\n        if (this.memory.debug) {\r\n            log.debug(this.print, args);\r\n        }\r\n    }\r\n    get ticksUntilSpawned() {\r\n        if (this.spawning) {\r\n            const spawner = this.pos.lookForStructure(STRUCTURE_SPAWN);\r\n            if (spawner && spawner.spawning) {\r\n                return spawner.spawning.remainingTime;\r\n            }\r\n            else {\r\n                // Shouldn't ever get here\r\n                console.log(`Error determining ticks to spawn for ${this.name} @ ${this.pos.print}!`);\r\n            }\r\n        }\r\n    }\r\n    get print() {\r\n        return '<a href=\"#!/room/' + Game.shard.name + '/' + this.pos.roomName + '\">[' + this.name + ']</a>';\r\n    }\r\n    // Wrapped creep methods ===========================================================================================\r\n    attack(target) {\r\n        const result = this.creep.attack(target);\r\n        if (result == OK) {\r\n            this.actionLog.attack = true;\r\n            if (isCreep(target)) {\r\n                if (target.hitsPredicted == undefined)\r\n                    target.hitsPredicted = target.hits;\r\n                target.hitsPredicted -= CombatIntel.predictedDamageAmount(this.creep, target, 'attack');\r\n                // account for hitback effects\r\n                if (this.creep.hitsPredicted == undefined)\r\n                    this.creep.hitsPredicted = this.creep.hits;\r\n                this.creep.hitsPredicted -= CombatIntel.predictedDamageAmount(target, this.creep, 'attack');\r\n            }\r\n            if (this.memory.talkative)\r\n                this.say(`ðŸ’¥`);\r\n        }\r\n        return result;\r\n    }\r\n    attackController(controller) {\r\n        const result = this.creep.attackController(controller);\r\n        if (!this.actionLog.attackController)\r\n            this.actionLog.attackController = (result == OK);\r\n        return result;\r\n    }\r\n    build(target) {\r\n        const result = this.creep.build(target);\r\n        if (!this.actionLog.build)\r\n            this.actionLog.build = (result == OK);\r\n        return result;\r\n    }\r\n    goBuild(target) {\r\n        if (this.pos.inRangeToPos(target.pos, RANGES.BUILD)) {\r\n            return this.build(target);\r\n        }\r\n        else {\r\n            return this.goTo(target);\r\n        }\r\n    }\r\n    cancelOrder(methodName) {\r\n        const result = this.creep.cancelOrder(methodName);\r\n        if (result == OK)\r\n            this.actionLog[methodName] = false;\r\n        return result;\r\n    }\r\n    claimController(controller) {\r\n        const result = this.creep.claimController(controller);\r\n        if (!this.actionLog.claimController)\r\n            this.actionLog.claimController = (result == OK);\r\n        return result;\r\n    }\r\n    dismantle(target) {\r\n        const result = this.creep.dismantle(target);\r\n        if (!this.actionLog.dismantle)\r\n            this.actionLog.dismantle = (result == OK);\r\n        return result;\r\n    }\r\n    drop(resourceType, amount) {\r\n        const result = this.creep.drop(resourceType, amount);\r\n        if (!this.actionLog.drop)\r\n            this.actionLog.drop = (result == OK);\r\n        return result;\r\n    }\r\n    goDrop(pos, resourceType, amount) {\r\n        if (this.pos.inRangeToPos(pos, RANGES.DROP)) {\r\n            return this.drop(resourceType, amount);\r\n        }\r\n        else {\r\n            return this.goTo(pos);\r\n        }\r\n    }\r\n    generateSafeMode(target) {\r\n        return this.creep.generateSafeMode(target);\r\n    }\r\n    harvest(source) {\r\n        const result = this.creep.harvest(source);\r\n        if (!this.actionLog.harvest)\r\n            this.actionLog.harvest = (result == OK);\r\n        return result;\r\n    }\r\n    goHarvest(source) {\r\n        if (this.pos.inRangeToPos(source.pos, RANGES.HARVEST)) {\r\n            return this.harvest(source);\r\n        }\r\n        else {\r\n            return this.goTo(source);\r\n        }\r\n    }\r\n    move(direction, force = false) {\r\n        if (!this.blockMovement && !force) {\r\n            const result = this.creep.move(direction);\r\n            if (result == OK) {\r\n                if (!this.actionLog.move)\r\n                    this.actionLog.move = true;\r\n                this.nextPos = this.pos.getPositionAtDirection(direction);\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            return ERR_BUSY;\r\n        }\r\n    }\r\n    notifyWhenAttacked(enabled) {\r\n        return this.creep.notifyWhenAttacked(enabled);\r\n    }\r\n    pickup(resource) {\r\n        const result = this.creep.pickup(resource);\r\n        if (!this.actionLog.pickup)\r\n            this.actionLog.pickup = (result == OK);\r\n        return result;\r\n    }\r\n    rangedAttack(target) {\r\n        const result = this.creep.rangedAttack(target);\r\n        if (result == OK) {\r\n            this.actionLog.rangedAttack = true;\r\n            if (isCreep(target)) {\r\n                if (target.hitsPredicted == undefined)\r\n                    target.hitsPredicted = target.hits;\r\n                target.hitsPredicted -= CombatIntel.predictedDamageAmount(this, target, 'rangedAttack');\r\n            }\r\n            if (this.memory.talkative)\r\n                this.say(`ðŸ”«`);\r\n        }\r\n        return result;\r\n    }\r\n    rangedMassAttack() {\r\n        const result = this.creep.rangedMassAttack();\r\n        if (result == OK) {\r\n            this.actionLog.rangedMassAttack = true;\r\n            for (const target of this.pos.findInRange(this.room.hostiles, 3)) {\r\n                if (target.hitsPredicted == undefined)\r\n                    target.hitsPredicted = target.hits;\r\n                target.hitsPredicted -= CombatIntel.getMassAttackDamageTo(this, target);\r\n            }\r\n            if (this.memory.talkative)\r\n                this.say(`ðŸ’£`);\r\n        }\r\n        return result;\r\n    }\r\n    repair(target) {\r\n        const result = this.creep.repair(target);\r\n        if (!this.actionLog.repair)\r\n            this.actionLog.repair = (result == OK);\r\n        return result;\r\n    }\r\n    goRepair(target) {\r\n        if (this.pos.inRangeToPos(target.pos, RANGES.REPAIR)) {\r\n            return this.repair(target);\r\n        }\r\n        else {\r\n            return this.goTo(target);\r\n        }\r\n    }\r\n    reserveController(controller) {\r\n        const result = this.creep.reserveController(controller);\r\n        if (!this.actionLog.reserveController)\r\n            this.actionLog.reserveController = (result == OK);\r\n        return result;\r\n    }\r\n    /* Say a message; maximum message length is 10 characters */\r\n    say(message, pub) {\r\n        return this.creep.say(message, pub);\r\n    }\r\n    signController(target, text) {\r\n        const result = this.creep.signController(target, text);\r\n        if (!this.actionLog.signController)\r\n            this.actionLog.signController = (result == OK);\r\n        return result;\r\n    }\r\n    suicide() {\r\n        return this.creep.suicide();\r\n    }\r\n    upgradeController(controller) {\r\n        const result = this.creep.upgradeController(controller);\r\n        if (!this.actionLog.upgradeController)\r\n            this.actionLog.upgradeController = (result == OK);\r\n        // Determine amount of upgrade power\r\n        // let weightedUpgraderParts = _.map(this.boostCounts, )\r\n        // let upgradeAmount = this.getActiveBodyparts(WORK) * UPGRADE_CONTROLLER_POWER;\r\n        // let upgrade\r\n        // Stats.accumulate(`colonies.${this.colony.name}.rcl.progressTotal`, upgradeAmount);\r\n        return result;\r\n    }\r\n    heal(target, rangedHealInstead = false) {\r\n        if (rangedHealInstead && !this.pos.isNearTo(target)) {\r\n            return this.rangedHeal(target);\r\n        }\r\n        const creep = toCreep(target);\r\n        const result = this.creep.heal(creep);\r\n        if (result == OK) {\r\n            this.actionLog.heal = true;\r\n            if (creep.hitsPredicted == undefined)\r\n                creep.hitsPredicted = creep.hits;\r\n            creep.hitsPredicted += CombatIntel.getHealAmount(this);\r\n            if (this.memory.talkative)\r\n                this.say('ðŸš‘');\r\n        }\r\n        return result;\r\n    }\r\n    rangedHeal(target) {\r\n        const creep = toCreep(target);\r\n        const result = this.creep.rangedHeal(creep);\r\n        if (result == OK) {\r\n            this.actionLog.rangedHeal = true;\r\n            if (creep.hitsPredicted == undefined)\r\n                creep.hitsPredicted = creep.hits;\r\n            creep.hitsPredicted += CombatIntel.getRangedHealAmount(this);\r\n            if (this.memory.talkative)\r\n                this.say(`ðŸ’‰`);\r\n        }\r\n        return result;\r\n    }\r\n    transfer(target, resourceType = RESOURCE_ENERGY, amount) {\r\n        let result;\r\n        if (target instanceof Zerg_1) {\r\n            result = this.creep.transfer(target.creep, resourceType, amount);\r\n        }\r\n        else {\r\n            result = this.creep.transfer(target, resourceType, amount);\r\n        }\r\n        if (!this.actionLog.transfer)\r\n            this.actionLog.transfer = (result == OK);\r\n        return result;\r\n    }\r\n    goTransfer(target, resourceType = RESOURCE_ENERGY, amount) {\r\n        if (this.pos.inRangeToPos(target.pos, RANGES.TRANSFER)) {\r\n            return this.transfer(target, resourceType, amount);\r\n        }\r\n        else {\r\n            return this.goTo(target);\r\n        }\r\n    }\r\n    withdraw(target, resourceType = RESOURCE_ENERGY, amount) {\r\n        const result = this.creep.withdraw(target, resourceType, amount);\r\n        if (!this.actionLog.withdraw)\r\n            this.actionLog.withdraw = (result == OK);\r\n        return result;\r\n    }\r\n    goWithdraw(target, resourceType = RESOURCE_ENERGY, amount) {\r\n        if (this.pos.inRangeToPos(target.pos, RANGES.WITHDRAW)) {\r\n            return this.withdraw(target, resourceType, amount);\r\n        }\r\n        else {\r\n            return this.goTo(target);\r\n        }\r\n    }\r\n    // Simultaneous creep actions --------------------------------------------------------------------------------------\r\n    /**\r\n     * Determine whether the given action will conflict with an action the creep has already taken.\r\n     * See http://docs.screeps.com/simultaneous-actions.html for more details.\r\n     */\r\n    canExecute(actionName) {\r\n        // Only one action can be executed from within a single pipeline\r\n        let conflictingActions = [actionName];\r\n        for (const pipeline of actionPipelines) {\r\n            if (pipeline.includes(actionName))\r\n                conflictingActions = conflictingActions.concat(pipeline);\r\n        }\r\n        for (const action of conflictingActions) {\r\n            if (this.actionLog[action]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    // Body configuration and related data -----------------------------------------------------------------------------\r\n    getActiveBodyparts(type) {\r\n        return this.creep.getActiveBodyparts(type);\r\n    }\r\n    /* The same as creep.getActiveBodyparts, but just counts bodyparts regardless of condition. */\r\n    getBodyparts(partType) {\r\n        return _.filter(this.body, (part) => part.type == partType).length;\r\n    }\r\n    // Custom creep methods ============================================================================================\r\n    // Carry methods\r\n    get hasMineralsInCarry() {\r\n        for (const resourceType in this.carry) {\r\n            if (resourceType != RESOURCE_ENERGY && (this.carry[resourceType] || 0) > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    // Boosting logic --------------------------------------------------------------------------------------------------\r\n    get boosts() {\r\n        return this.creep.boosts;\r\n    }\r\n    get boostCounts() {\r\n        return this.creep.boostCounts;\r\n    }\r\n    get needsBoosts() {\r\n        if (this.overlord) {\r\n            return this.overlord.shouldBoost(this);\r\n        }\r\n        return false;\r\n    }\r\n    // Overlord logic --------------------------------------------------------------------------------------------------\r\n    get overlord() {\r\n        return getOverlord(this);\r\n    }\r\n    set overlord(newOverlord) {\r\n        setOverlord(this, newOverlord);\r\n    }\r\n    /* Reassigns the creep to work under a new overlord and as a new role. */\r\n    reassign(newOverlord, newRole, invalidateTask = true) {\r\n        this.overlord = newOverlord;\r\n        this.roleName = newRole;\r\n        this.memory.role = newRole;\r\n        if (invalidateTask) {\r\n            this.task = null;\r\n        }\r\n    }\r\n    // Task logic ------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * Wrapper for _task\r\n     */\r\n    get task() {\r\n        if (!this._task) {\r\n            this._task = this.memory.task ? initializeTask(this.memory.task) : null;\r\n        }\r\n        return this._task;\r\n    }\r\n    /**\r\n     * Assign the creep a task with the setter, replacing creep.assign(Task)\r\n     */\r\n    set task(task) {\r\n        // Unregister target from old task if applicable\r\n        const oldProtoTask = this.memory.task;\r\n        if (oldProtoTask) {\r\n            const oldRef = oldProtoTask._target.ref;\r\n            if (Overmind.cache.targets[oldRef]) {\r\n                _.remove(Overmind.cache.targets[oldRef], name => name == this.name);\r\n            }\r\n        }\r\n        // Set the new task\r\n        this.memory.task = task ? task.proto : null;\r\n        if (task) {\r\n            if (task.target) {\r\n                // Register task target in cache if it is actively targeting something (excludes goTo and similar)\r\n                if (!Overmind.cache.targets[task.target.ref]) {\r\n                    Overmind.cache.targets[task.target.ref] = [];\r\n                }\r\n                Overmind.cache.targets[task.target.ref].push(this.name);\r\n            }\r\n            // Register references to creep\r\n            task.creep = this;\r\n        }\r\n        // Clear cache\r\n        this._task = null;\r\n    }\r\n    /**\r\n     * Does the creep have a valid task at the moment?\r\n     */\r\n    get hasValidTask() {\r\n        return !!this.task && this.task.isValid();\r\n    }\r\n    /**\r\n     * Creeps are idle if they don't have a task.\r\n     */\r\n    get isIdle() {\r\n        return !this.task || !this.task.isValid();\r\n    }\r\n    /**\r\n     * Execute the task you currently have.\r\n     */\r\n    run() {\r\n        if (this.task) {\r\n            return this.task.run();\r\n        }\r\n    }\r\n    // Colony association ----------------------------------------------------------------------------------------------\r\n    /**\r\n     * Colony that the creep belongs to.\r\n     */\r\n    get colony() {\r\n        if (this.memory[\"C\" /* COLONY */] != null) {\r\n            return Overmind.colonies[this.memory[\"C\" /* COLONY */]];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    set colony(newColony) {\r\n        if (newColony != null) {\r\n            this.memory[\"C\" /* COLONY */] = newColony.name;\r\n        }\r\n        else {\r\n            this.memory[\"C\" /* COLONY */] = null;\r\n        }\r\n    }\r\n    /**\r\n     * If the creep is in a colony room or outpost\r\n     */\r\n    get inColonyRoom() {\r\n        return Overmind.colonyMap[this.room.name] == this.memory[\"C\" /* COLONY */];\r\n    }\r\n    // Movement and location -------------------------------------------------------------------------------------------\r\n    goTo(destination, options = {}) {\r\n        return Movement.goTo(this, destination, options);\r\n    }\r\n    goToRoom(roomName, options = {}) {\r\n        return Movement.goToRoom(this, roomName, options);\r\n    }\r\n    inSameRoomAs(target) {\r\n        return this.pos.roomName == target.pos.roomName;\r\n    }\r\n    safelyInRoom(roomName) {\r\n        return this.room.name == roomName && !this.pos.isEdge;\r\n    }\r\n    get inRampart() {\r\n        return this.creep.inRampart;\r\n    }\r\n    get isMoving() {\r\n        const moveData = this.memory._go;\r\n        return !!moveData && !!moveData.path && moveData.path.length > 1;\r\n    }\r\n    /**\r\n     * Kite around hostiles in the room\r\n     */\r\n    kite(avoidGoals = this.room.hostiles, options = {}) {\r\n        _.defaults(options, {\r\n            fleeRange: 5\r\n        });\r\n        return Movement.kite(this, avoidGoals, options);\r\n    }\r\n    defaultFleeGoals() {\r\n        let fleeGoals = [];\r\n        fleeGoals = fleeGoals.concat(this.room.hostiles)\r\n            .concat(_.filter(this.room.keeperLairs, lair => (lair.ticksToSpawn || Infinity) < 10));\r\n        return fleeGoals;\r\n    }\r\n    /**\r\n     * Flee from hostiles in the room, while not repathing every tick\r\n     */\r\n    flee(avoidGoals = this.room.fleeDefaults, fleeOptions = {}, moveOptions = {}) {\r\n        if (avoidGoals.length == 0) {\r\n            return false;\r\n        }\r\n        else if (this.room.controller && this.room.controller.my && this.room.controller.safeMode) {\r\n            return false;\r\n        }\r\n        else {\r\n            const fleeing = Movement.flee(this, avoidGoals, fleeOptions.dropEnergy, moveOptions) != undefined;\r\n            if (fleeing) {\r\n                // Drop energy if needed\r\n                if (fleeOptions.dropEnergy && this.carry.energy > 0) {\r\n                    const nearbyContainers = this.pos.findInRange(this.room.storageUnits, 1);\r\n                    if (nearbyContainers.length > 0) {\r\n                        this.transfer(_.first(nearbyContainers), RESOURCE_ENERGY);\r\n                    }\r\n                    else {\r\n                        this.drop(RESOURCE_ENERGY);\r\n                    }\r\n                }\r\n                // Invalidate task\r\n                if (fleeOptions.invalidateTask) {\r\n                    this.task = null;\r\n                }\r\n            }\r\n            return fleeing;\r\n        }\r\n    }\r\n    /**\r\n     * Park the creep off-roads\r\n     */\r\n    park(pos = this.pos, maintainDistance = false) {\r\n        return Movement.park(this, pos, maintainDistance);\r\n    }\r\n    /**\r\n     * Moves a creep off of the current tile to the first available neighbor\r\n     */\r\n    moveOffCurrentPos() {\r\n        return Movement.moveOffCurrentPos(this);\r\n    }\r\n    /**\r\n     * Moves onto an exit tile\r\n     */\r\n    moveOnExit() {\r\n        return Movement.moveOnExit(this);\r\n    }\r\n    /**\r\n     * Moves off of an exit tile\r\n     */\r\n    moveOffExit(avoidSwamp = true) {\r\n        return Movement.moveOffExit(this, avoidSwamp);\r\n    }\r\n    moveOffExitToward(pos, detour = true) {\r\n        return Movement.moveOffExitToward(this, pos, detour);\r\n    }\r\n    // Miscellaneous fun stuff -----------------------------------------------------------------------------------------\r\n    sayLoop(messageList, pub) {\r\n        return this.say(messageList[Game.time % messageList.length], pub);\r\n    }\r\n    sayRandom(phrases, pub) {\r\n        return this.say(phrases[Math.floor(Math.random() * phrases.length)], pub);\r\n    }\r\n};\r\nZerg = Zerg_1 = tslib_1.__decorate([\r\n    profile\r\n], Zerg);\r\nexport { Zerg };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/intel/CombatIntel.ts","C:/git/Overmind/src/movement/Movement.ts","C:/git/Overmind/src/overlords/Overlord.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/tasks/initializer.ts","C:/git/Overmind/src/tasks/Task.ts","C:/git/Overmind/src/~settings.ts"]}
