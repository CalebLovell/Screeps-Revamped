{"code":"/* tslint:disable:no-string-literal */\r\nimport { log } from '../console/log';\r\nimport { Mem } from '../memory/Memory';\r\n/**\r\n * The VersionMigration class contains ad-hoc methods for migrating older versions of Overmind to newer versions\r\n */\r\nexport class VersionMigration {\r\n    static run() {\r\n        /*\r\n        if (!this.memory.versions['02Xto03X']) {\r\n            this.migrate_02X_03X();\r\n        }\r\n        if (!this.memory.versions['03Xto04X']) {\r\n            this.migrate_03X_04X();\r\n        }\r\n        if (!this.memory.versions['04Xto05X']) {\r\n            this.migrate_04X_05X();\r\n        }\r\n        if (!this.memory.versions['04Xto05X_part2']) {\r\n            this.migrate_04X_05X_part2();\r\n        }\r\n        if (!this.memory.versions['04Xto05X_part3']) {\r\n            this.migrate_04X_05X_part3();\r\n        }\r\n        */\r\n        if (!this.memory.versions['05Xto051']) {\r\n            this.migrate_050_051();\r\n        }\r\n        if (!this.memory.versions['05Xto051_part2']) {\r\n            this.migrate_050_051_part2();\r\n        }\r\n        if (!this.memory.versions['05Xto051_part3']) {\r\n            this.migrate_050_051_part3();\r\n        }\r\n        if (!this.memory.versions['05Xto051_part4']) {\r\n            this.migrate_050_051_part4();\r\n        }\r\n        if (!this.memory.versions['051to052']) {\r\n            this.migrate_051_052();\r\n        }\r\n        if (!this.memory.versions['052to053']) {\r\n            this.migrate_052_053();\r\n        }\r\n    }\r\n    static get memory() {\r\n        return Mem.wrap(Memory.Overmind, 'versionMigrator', {\r\n            versions: {}\r\n        });\r\n    }\r\n    /*\r\n    static migrate_02X_03X() {\r\n        // This technically won't run correctly because it gets run only on global reset, but no one is using v0.2.x\r\n        // anymore anyway, so I don't feel the need to maintain support for this function\r\n        let allColoniesUpdated = true;\r\n        let i = 0;\r\n        for (let name in Memory.colonies) {\r\n            let rpMemory = Memory.colonies[name].roomPlanner;\r\n            let lastBuilt = rpMemory.lastGenerated;\r\n            // Reboot colony room planners one at a time every 3 ticks\r\n            if (!lastBuilt) {\r\n                allColoniesUpdated = false;\r\n                if (Game.time % 100 == 3 * i) {\r\n                    // Delete all white/white routing hints from memory\r\n                    rpMemory.savedFlags = _.filter(rpMemory.savedFlags, (flag: {secondaryColor: number}) =>\r\n                        flag.secondaryColor != COLOR_WHITE);\r\n                    rpMemory.active = true;\r\n                    log.alert(`Version migration: rebooting roomPlanner for colony ${name}!`);\r\n                } else if (Game.time % 100 == 3 * i + 1) {\r\n                    colony.roomPlanner.finalize(true);\r\n                }\r\n            }\r\n        }\r\n        if (allColoniesUpdated) {\r\n            this.memory.versions['02Xto03X'] = true;\r\n            log.alert(`Version migration from 0.2.x -> 0.3.x completed successfully.`);\r\n        }\r\n    }\r\n\r\n    static migrate_03X_04X() {\r\n        // Update creep memory\r\n        for (let i in Memory.creeps) {\r\n            // Migrate all old-style overlord references to new ones\r\n            if (Memory.creeps[i].overlord) {\r\n                let hcName = Memory.creeps[i].overlord!.split(':')[0];\r\n                if (hcName == 'commandCenter'\r\n                    || hcName == 'hatchery'\r\n                    || hcName == 'evolutionChamber'\r\n                    || hcName == 'miningSite'\r\n                    || hcName == 'upgradeSite') {\r\n                    let id = Memory.creeps[i].overlord!.split(':')[1];\r\n                    let roomObject = Game.getObjectById(id) as RoomObject | undefined;\r\n                    if (roomObject) {\r\n                        let overlordName = Memory.creeps[i].overlord!.split(':')[2];\r\n                        Memory.creeps[i].overlord = hcName + '@' + roomObject.pos.name + ':' + overlordName;\r\n                    }\r\n                }\r\n            }\r\n            // Change all miner roles to drone roles\r\n            if (Memory.creeps[i].role == 'miner') {\r\n                Memory.creeps[i].role = 'drone';\r\n            }\r\n        }\r\n        // Delete old-style miningSite overlords from memory\r\n        OvermindConsole.deepCleanMemory();\r\n        this.memory.versions['03Xto04X'] = true;\r\n        log.alert(`Version migration from 0.3.x -> 0.4.x completed successfully.`);\r\n    }\r\n\r\n    static migrate_04X_05X() {\r\n        let migrateClusterNames = ['commandCenter', 'evolutionChamber', 'hatchery', 'upgradeSite'];\r\n        for (let i in Memory.creeps) {\r\n            if (Memory.creeps[i].overlord) {\r\n                let hcName = Memory.creeps[i].overlord!.split('@')[0];\r\n                if (migrateClusterNames.includes(hcName)) {\r\n                    let overlordName = _.last(Memory.creeps[i].overlord!.split(':'));\r\n                    if (overlordName == 'hatchery') {\r\n                        overlordName = 'supply';\r\n                    }\r\n                    let colonyName = Memory.creeps[i].colony;\r\n                    Memory.creeps[i].overlord = hcName + '@' + colonyName + ':' + overlordName;\r\n                }\r\n            }\r\n        }\r\n        for (let i in Memory.rooms) {\r\n            delete (<any>Memory.rooms[i]).tick;\r\n            delete (<any>Memory.rooms[i]).score;\r\n        }\r\n        // Change to new signature\r\n        let oldSignature = '[Overmind]';\r\n        if ((<any>Memory).signature && (<any>Memory).signature.includes(oldSignature)) {\r\n            (<any>Memory).signature = (<any>Memory).signature.replace(oldSignature, DEFAULT_OVERMIND_SIGNATURE);\r\n        }\r\n        this.memory.versions['04Xto05X'] = true;\r\n        log.alert(`Version migration from 0.4.x -> 0.5.x (part 1) completed successfully.`);\r\n    }\r\n\r\n    static migrate_04X_05X_part2() {\r\n        // Copy old memory to new memory locations\r\n        if (Memory.signature) {\r\n            Memory.settings.signature = (<any>Memory).signature;\r\n        }\r\n        delete (<any>Memory).signature;\r\n        delete (<any>Memory).bot;\r\n        delete (<any>Memory).log;\r\n        delete (<any>Memory).autoclaim;\r\n        this.memory.versions['04Xto05X_part2'] = true;\r\n        log.alert(`Version migration from 0.4.x -> 0.5.x (part 2) completed successfully.`);\r\n    }\r\n\r\n    static migrate_04X_05X_part3() {\r\n        for (let i in Memory.creeps) {\r\n            if (Memory.creeps[i].overlord) {\r\n                let ref = Memory.creeps[i].overlord as string;\r\n                let n = ref.lastIndexOf(':');\r\n                ref = ref.slice(0, n) + ref.slice(n).replace(':', '>');\r\n                Memory.creeps[i].overlord = ref;\r\n            }\r\n        }\r\n        this.memory.versions['04Xto05X_part3'] = true;\r\n        log.alert(`Version migration from 0.4.x -> 0.5.x (part 3) completed successfully.`);\r\n    }\r\n\r\n    */\r\n    static migrate_050_051() {\r\n        // Destroy all links that aren't hatchery or commandCenter links\r\n        for (const id in Game.structures) {\r\n            const s = Game.structures[id];\r\n            if (s.structureType == STRUCTURE_LINK) {\r\n                const isCommandCenterLink = s.pos.findInRange(_.compact([s.room.storage,\r\n                    s.room.terminal]), 2).length > 0;\r\n                const isHatcheryLink = s.pos.findInRange(s.room.spawns, 2).length > 0;\r\n                if (!isCommandCenterLink && !isHatcheryLink) {\r\n                    s.destroy();\r\n                }\r\n            }\r\n        }\r\n        let count = 0;\r\n        for (const name in Game.creeps) {\r\n            const creep = Game.creeps[name];\r\n            if (creep.memory.role == 'drone' &&\r\n                creep.memory.overlord && creep.memory.overlord.includes('miningSite')) {\r\n                creep.suicide();\r\n                count++;\r\n            }\r\n        }\r\n        this.memory.versions['05Xto051'] = true;\r\n        log.alert(`Genocide complete: suicided ${count} innocent drones.`);\r\n        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 1) completed successfully.`);\r\n    }\r\n    static migrate_050_051_part2() {\r\n        // Destroy all links that aren't hatchery or commandCenter links\r\n        for (const name in Game.creeps) {\r\n            const creep = Game.creeps[name];\r\n            if (creep.memory.role == 'reserver') {\r\n                creep.memory.role = 'infestor';\r\n            }\r\n            else if (creep.memory.role == 'guard') {\r\n                creep.memory.role = 'broodling';\r\n            }\r\n        }\r\n        this.memory.versions['05Xto051_part2'] = true;\r\n        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 2) completed successfully.`);\r\n    }\r\n    static migrate_050_051_part3() {\r\n        if (Memory.assimilator && Memory.assimilator.users) {\r\n            delete Memory.assimilator.users;\r\n        }\r\n        this.memory.versions['05Xto051_part3'] = true;\r\n        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 3) completed successfully.`);\r\n    }\r\n    static migrate_050_051_part4() {\r\n        const protectedKeywords = ['suspendUntil', 'amount', 'created', 'persistent', 'setPosition', 'rotation',\r\n            'colony', 'parent', 'pathing', 'stats', 'safeTick', 'enhanced', 'persistent',\r\n            'recoveryWaypoint', 'totalResources', 'maxPathLength', 'maxLinearRange'];\r\n        for (const name in Memory.flags) {\r\n            for (const prop in Memory.flags[name]) {\r\n                if (!protectedKeywords.includes(prop)) {\r\n                    delete Memory.flags[name][prop];\r\n                }\r\n            }\r\n        }\r\n        this.memory.versions['05Xto051_part4'] = true;\r\n        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 4) completed successfully.`);\r\n    }\r\n    static migrate_051_052() {\r\n        if (__VERSION__ == '0.5.2') {\r\n            for (const name in Game.creeps) {\r\n                if (name.includes('mutalisk')) {\r\n                    Game.creeps[name].suicide();\r\n                }\r\n            }\r\n        }\r\n        this.memory.versions['051to052'] = true;\r\n        log.alert(`Version migration from 0.5.1 -> 0.5.2 completed successfully.`);\r\n    }\r\n    static migrate_052_053() {\r\n        // Reformat flag and harvest directive memory\r\n        const newFlagKeys = {\r\n            created: \"T\" /* TICK */,\r\n            expiration: \"X\" /* EXPIRATION */,\r\n            overlord: \"O\" /* OVERLORD */,\r\n            colony: \"C\" /* COLONY */,\r\n        };\r\n        for (const name in Memory.flags) {\r\n            // Replace old keys with new ones\r\n            Memory.flags[name] = _.mapKeys(Memory.flags[name], function (value, key) {\r\n                return newFlagKeys[key] || key;\r\n            });\r\n            // Special opertions for harvest flags\r\n            if (name.includes('harvest:')) {\r\n                const pathing = Memory.flags[name].pathing;\r\n                if (pathing) {\r\n                    Memory.flags[name]['P'] = {\r\n                        D: pathing.distance,\r\n                        X: pathing.expiration,\r\n                    };\r\n                    delete Memory.flags[name].pathing;\r\n                }\r\n                Memory.flags[name]['u'] = Memory.flags[name].stats.usage;\r\n                Memory.flags[name]['d'] = Memory.flags[name].stats.downtime;\r\n                delete Memory.flags[name].stats;\r\n            }\r\n        }\r\n        // Reformat creep memory\r\n        const newCreepKeys = {\r\n            overlord: \"O\" /* OVERLORD */,\r\n            colony: \"C\" /* COLONY */,\r\n        };\r\n        for (const name in Memory.creeps) {\r\n            // Replace old keys with new ones\r\n            Memory.creeps[name] = _.mapKeys(Memory.creeps[name], function (value, key) {\r\n                return newCreepKeys[key] || key;\r\n            });\r\n        }\r\n        // Delete outdated colony memory properties\r\n        for (const name in Memory.colonies) {\r\n            for (const key in Memory.colonies[name]) {\r\n                if (key.includes('miningSite@')) {\r\n                    delete Memory.colonies[name][key];\r\n                }\r\n            }\r\n        }\r\n        // Delete ALL room memory\r\n        for (const name in Memory.rooms) {\r\n            delete Memory.rooms[name];\r\n        }\r\n        this.memory.versions['052to053'] = true;\r\n        log.alert(`Version migration from 0.5.2 -> 0.5.3 completed successfully.`);\r\n    }\r\n}\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/memory/Memory.ts"]}
