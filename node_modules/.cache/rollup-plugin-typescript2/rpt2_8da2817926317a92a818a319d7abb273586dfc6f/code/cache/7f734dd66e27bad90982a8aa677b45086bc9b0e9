{"code":"import * as tslib_1 from \"tslib\";\r\nvar RoomPlanner_1;\r\nimport { getAllColonies } from '../Colony';\r\nimport { log } from '../console/log';\r\nimport { isOwnedStructure } from '../declarations/typeGuards';\r\nimport { DirectiveTerminalRebuildState } from '../directives/terminalState/terminalState_rebuild';\r\nimport { Energetics } from '../logistics/Energetics';\r\nimport { Autonomy, getAutonomyLevel, Mem } from '../memory/Memory';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { BuildPriorities, DemolishStructurePriorities } from '../priorities/priorities_structures';\r\nimport { profile } from '../profiler/decorator';\r\nimport { bullet } from '../utilities/stringConstants';\r\nimport { derefCoords, maxBy, onPublicServer } from '../utilities/utils';\r\nimport { Visualizer } from '../visuals/Visualizer';\r\nimport { MY_USERNAME } from '../~settings';\r\nimport { BarrierPlanner } from './BarrierPlanner';\r\nimport { bunkerLayout } from './layouts/bunker';\r\nimport { commandCenterLayout } from './layouts/commandCenter';\r\nimport { hatcheryLayout } from './layouts/hatchery';\r\nimport { RoadPlanner } from './RoadPlanner';\r\nconst memoryDefaults = {\r\n    active: true,\r\n    savedFlags: [],\r\n};\r\nexport function getAllStructureCoordsFromLayout(layout, rcl) {\r\n    if (!layout[rcl]) {\r\n        return [];\r\n    }\r\n    const positionsByType = layout[rcl].buildings;\r\n    let coords = [];\r\n    for (const structureType in positionsByType) {\r\n        coords = coords.concat(positionsByType[structureType].pos);\r\n    }\r\n    return _.unique(coords, coord => coord.x + 50 * coord.y);\r\n}\r\nexport function translatePositions(positions, fromAnchor, toAnchor) {\r\n    const dx = toAnchor.x - fromAnchor.x;\r\n    const dy = toAnchor.y - fromAnchor.y;\r\n    const newPositions = [];\r\n    for (const pos of positions) {\r\n        newPositions.push(new RoomPosition(pos.x + dx, pos.y + dy, pos.roomName));\r\n    }\r\n    return newPositions;\r\n}\r\n/**\r\n * The room planner handles structure placement within a room automatically or (in manual or semiautomatic mode) with\r\n * manual guidance from room planner flags.\r\n */\r\nlet RoomPlanner = RoomPlanner_1 = class RoomPlanner {\r\n    constructor(colony) {\r\n        this.colony = colony;\r\n        this.memory = Mem.wrap(this.colony.memory, 'roomPlanner', memoryDefaults);\r\n        this.barrierPlanner = new BarrierPlanner(this);\r\n        this.roadPlanner = new RoadPlanner(this);\r\n        this.refresh();\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(this.colony.memory, 'roomPlanner', memoryDefaults);\r\n        this.placements = {\r\n            hatchery: undefined,\r\n            commandCenter: undefined,\r\n            bunker: undefined,\r\n        };\r\n        this.plan = {};\r\n        this.map = {};\r\n        this.barrierPlanner.refresh();\r\n        this.roadPlanner.refresh();\r\n        if (this.active && Game.time % 25 == 0) {\r\n            log.alert(`RoomPlanner for ${this.colony.room.print} is still active! Close to save CPU.`);\r\n        }\r\n    }\r\n    get active() {\r\n        return this.memory.active;\r\n    }\r\n    set active(active) {\r\n        this.memory.active = active;\r\n        if (active) {\r\n            this.reactivate();\r\n        }\r\n    }\r\n    /**\r\n     * Recall or reconstruct the appropriate map from memory\r\n     */\r\n    recallMap(level = this.colony.controller.level) {\r\n        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {\r\n            this.map = this.getStructureMapForBunkerAt(this.memory.bunkerData.anchor, level);\r\n        }\r\n        else if (this.memory.mapsByLevel) {\r\n            this.map = _.mapValues(this.memory.mapsByLevel[level], posArr => _.map(posArr, protoPos => derefRoomPosition(protoPos)));\r\n        }\r\n    }\r\n    /**\r\n     * Return a list of room positions for planned structure locations at RCL8 (or undefined if plan isn't made yet)\r\n     */\r\n    plannedStructurePositions(structureType) {\r\n        if (this.map[structureType]) {\r\n            return this.map[structureType];\r\n        }\r\n        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {\r\n            return this.getBunkerStructurePlacement(structureType, this.memory.bunkerData.anchor);\r\n        }\r\n        const roomMap = this.memory.mapsByLevel ? this.memory.mapsByLevel[8] : undefined;\r\n        if (roomMap && roomMap[structureType]) {\r\n            return _.map(roomMap[structureType], protoPos => derefRoomPosition(protoPos));\r\n        }\r\n    }\r\n    /**\r\n     * Return the planned location of the storage structure\r\n     */\r\n    get storagePos() {\r\n        if (this.placements.commandCenter) {\r\n            return this.placements.commandCenter;\r\n        }\r\n        const positions = this.plannedStructurePositions(STRUCTURE_STORAGE);\r\n        if (positions) {\r\n            return positions[0];\r\n        }\r\n    }\r\n    /**\r\n     * Return the planned location of the spawning structure\r\n     */\r\n    get hatcheryPos() {\r\n        if (this.placements.hatchery) {\r\n            return this.placements.hatchery;\r\n        }\r\n        const positions = this.plannedStructurePositions(STRUCTURE_SPAWN);\r\n        if (positions) {\r\n            return positions[0];\r\n        }\r\n    }\r\n    get bunkerPos() {\r\n        if (this.placements.bunker) {\r\n            return this.placements.bunker;\r\n        }\r\n        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {\r\n            return new RoomPosition(this.memory.bunkerData.anchor.x, this.memory.bunkerData.anchor.y, this.colony.name);\r\n        }\r\n    }\r\n    reactivate() {\r\n        // Reinstantiate flags\r\n        for (const protoFlag of this.memory.savedFlags) {\r\n            const pos = derefRoomPosition(protoFlag.pos);\r\n            const result = pos.createFlag(undefined, COLOR_WHITE, protoFlag.secondaryColor);\r\n            if (typeof result == 'string') {\r\n                Memory.flags[result] = protoFlag.memory; // restore old memory\r\n            }\r\n        }\r\n        this.memory.savedFlags = [];\r\n        // Display the activation message\r\n        const msg = [\r\n            `Room planner activated for ${this.colony.name}. Reinstantiating flags from previous session on next tick.`,\r\n            'Place colony components with room planner flags:',\r\n            bullet + 'Place bunker (recommended)  white/red',\r\n            bullet + 'Place hatchery:             white/green',\r\n            bullet + 'Place command center:       white/blue',\r\n            // 'Set component rotation by writing an angle (0,90,180,270 or 0,1,2,3) to flag.memory.rotation.',\r\n            'Finalize layout '\r\n        ];\r\n        _.forEach(msg, command => console.log(command));\r\n    }\r\n    /**\r\n     * Run the room planner to generate a plan and map\r\n     */\r\n    make(level = 8) {\r\n        // Reset everything\r\n        this.plan = {};\r\n        this.map = {};\r\n        // Generate a plan, placing components by flags\r\n        this.plan = this.generatePlan(level);\r\n        // Flatten it into a map\r\n        this.map = this.mapFromPlan(this.plan);\r\n    }\r\n    /**\r\n     * Adds the specified structure directly to the map. Only callable after this.map is generated.\r\n     * Doesn't check for conflicts, so don't use freely.\r\n     */\r\n    placeStructure(type, pos) {\r\n        if (!this.map[type])\r\n            this.map[type] = [];\r\n        this.map[type].push(pos);\r\n    }\r\n    addComponent(componentName, pos, rotation = 0) {\r\n        this.placements[componentName] = pos;\r\n    }\r\n    /**\r\n     * Switcher that takes a component name and returns a layout\r\n     */\r\n    getLayout(name) {\r\n        switch (name) {\r\n            case 'hatchery':\r\n                return hatcheryLayout;\r\n            case 'commandCenter':\r\n                return commandCenterLayout;\r\n            case 'bunker':\r\n                return bunkerLayout;\r\n        }\r\n    }\r\n    /**\r\n     * Generate a plan of component placements for a given RCL\r\n     */\r\n    generatePlan(level = 8) {\r\n        const plan = {};\r\n        for (const name in this.placements) {\r\n            const layout = this.getLayout(name);\r\n            if (layout) {\r\n                const anchor = layout.data.anchor;\r\n                const pos = this.placements[name];\r\n                if (!pos)\r\n                    continue;\r\n                // let rotation: number = pos!.lookFor(LOOK_FLAGS)[0]!.memory.rotation || 0;\r\n                const componentMap = this.parseLayout(layout, level);\r\n                this.translateComponent(componentMap, anchor, pos);\r\n                // if (rotation != 0) this.rotateComponent(componentMap, pos!, rotation);\r\n                plan[name] = {\r\n                    map: componentMap,\r\n                    pos: new RoomPosition(anchor.x, anchor.y, this.colony.name),\r\n                    rotation: 0,\r\n                };\r\n            }\r\n        }\r\n        return plan;\r\n    }\r\n    /**\r\n     * Generate a map of (structure type: RoomPositions[]) for a given layout\r\n     */\r\n    parseLayout(structureLayout, level = 8) {\r\n        const map = {};\r\n        const layout = structureLayout[level];\r\n        if (layout) {\r\n            for (const buildingName in layout.buildings) {\r\n                map[buildingName] = _.map(layout.buildings[buildingName].pos, pos => new RoomPosition(pos.x, pos.y, this.colony.name));\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n    /**\r\n     * Generate a flatened map from a plan\r\n     */\r\n    mapFromPlan(plan) {\r\n        const map = {};\r\n        const componentMaps = _.map(plan, componentPlan => componentPlan.map);\r\n        const structureNames = _.unique(_.flatten(_.map(componentMaps, map => _.keys(map))));\r\n        for (const name of structureNames) {\r\n            map[name] = _.compact(_.flatten(_.map(componentMaps, map => map[name])));\r\n        }\r\n        return map;\r\n    }\r\n    /**\r\n     * Aligns the component position to the desired position; operations done in-place\r\n     */\r\n    translateComponent(map, fromPos, toPos) {\r\n        const dx = toPos.x - fromPos.x;\r\n        const dy = toPos.y - fromPos.y;\r\n        for (const structureType in map) {\r\n            for (const pos of map[structureType]) {\r\n                pos.x += dx;\r\n                pos.y += dy;\r\n            }\r\n        }\r\n    }\r\n    // TODO: component rotation isn't currently fully supported\r\n    /* Rotates component positions about a pivot point counterclockwise by the given angle; done in-place */\r\n    rotateComponent(map, pivot, angle) {\r\n        let R = ([x, y]) => ([x, y]);\r\n        if (angle == 0) {\r\n            return;\r\n        }\r\n        else if (angle == 90 || angle == 1) {\r\n            R = ([x, y]) => ([-y, x]);\r\n        }\r\n        else if (angle == 180 || angle == 2) {\r\n            R = ([x, y]) => ([-x, -y]);\r\n        }\r\n        else if (angle == 270 || angle == 3) {\r\n            R = ([x, y]) => ([y, -x]);\r\n        }\r\n        // Apply the rotation to the map\r\n        let offset, dx, dy;\r\n        for (const structureType in map) {\r\n            for (const pos of map[structureType]) {\r\n                offset = [pos.x - pivot.x, pos.y - pivot.y];\r\n                [dx, dy] = R(offset);\r\n                pos.x = pivot.x + dx;\r\n                pos.y = pivot.y + dy;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get bunker building placements as a StructureMap\r\n     */\r\n    getStructureMapForBunkerAt(anchor, level = 8) {\r\n        const dx = anchor.x - bunkerLayout.data.anchor.x;\r\n        const dy = anchor.y - bunkerLayout.data.anchor.y;\r\n        const structureLayout = _.mapValues(bunkerLayout[level].buildings, obj => obj.pos);\r\n        return _.mapValues(structureLayout, coordArr => _.map(coordArr, coord => new RoomPosition(coord.x + dx, coord.y + dy, this.colony.name)));\r\n    }\r\n    /**\r\n     * Get the placement for a single type of structure for bunker layout\r\n     */\r\n    getBunkerStructurePlacement(structureType, anchor, level = 8) {\r\n        const dx = anchor.x - bunkerLayout.data.anchor.x;\r\n        const dy = anchor.y - bunkerLayout.data.anchor.y;\r\n        return _.map(bunkerLayout[level].buildings[structureType].pos, coord => new RoomPosition(coord.x + dx, coord.y + dy, this.colony.name));\r\n    }\r\n    /**\r\n     * Generates a list of impassible obstacles from this.map or from this.memory.map\r\n     */\r\n    getObstacles() {\r\n        let obstacles = [];\r\n        const passableStructureTypes = [STRUCTURE_ROAD, STRUCTURE_CONTAINER, STRUCTURE_RAMPART];\r\n        if (_.keys(this.map).length > 0) { // if room planner has made the map, use that\r\n            for (const structureType in this.map) {\r\n                if (!passableStructureTypes.includes(structureType)) {\r\n                    obstacles = obstacles.concat(this.map[structureType]);\r\n                }\r\n            }\r\n        }\r\n        else { // else, serialize from memory\r\n            if (this.memory.bunkerData && this.memory.bunkerData.anchor) {\r\n                const structureMap = this.getStructureMapForBunkerAt(this.memory.bunkerData.anchor);\r\n                for (const structureType in structureMap) {\r\n                    if (!passableStructureTypes.includes(structureType)) {\r\n                        obstacles = obstacles.concat(structureMap[structureType]);\r\n                    }\r\n                }\r\n            }\r\n            else if (this.memory.mapsByLevel) {\r\n                for (const structureType in this.memory.mapsByLevel[8]) {\r\n                    if (!passableStructureTypes.includes(structureType)) {\r\n                        obstacles = obstacles.concat(_.map(this.memory.mapsByLevel[8][structureType], protoPos => derefRoomPosition(protoPos)));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return _.unique(obstacles);\r\n    }\r\n    /**\r\n     * Check to see if there are any structures that can't be built\r\n     */\r\n    findCollision(ignoreRoads = false) {\r\n        const terrain = Game.map.getRoomTerrain(this.colony.room.name);\r\n        for (const structureType in this.map) {\r\n            if (ignoreRoads && structureType == STRUCTURE_ROAD) {\r\n                continue;\r\n            }\r\n            for (const pos of this.map[structureType]) {\r\n                if (terrain.get(pos.x, pos.y) == TERRAIN_MASK_WALL) {\r\n                    return pos;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Write everything to memory at the end of activation. If ignoreRoads is set, it will allow collisions with\r\n     * roads, but will continue to alert you every time it fails to build a road in the terrain pos (WIP)\r\n     */\r\n    finalize(ignoreRoads = false) {\r\n        const collision = this.findCollision(ignoreRoads);\r\n        if (collision) {\r\n            log.warning(`Invalid layout: collision detected at ${collision.print}!`);\r\n            return;\r\n        }\r\n        const layoutIsValid = (!!this.placements.commandCenter && !!this.placements.hatchery)\r\n            || !!this.placements.bunker;\r\n        if (layoutIsValid) { // Write everything to memory\r\n            // Generate maps for each rcl\r\n            delete this.memory.bunkerData;\r\n            delete this.memory.mapsByLevel;\r\n            if (this.placements.bunker) {\r\n                this.memory.bunkerData = {\r\n                    anchor: this.placements.bunker,\r\n                };\r\n            }\r\n            else {\r\n                this.memory.mapsByLevel = {};\r\n                for (let rcl = 1; rcl <= 8; rcl++) {\r\n                    this.make(rcl);\r\n                    this.memory.mapsByLevel[rcl] = this.map;\r\n                }\r\n            }\r\n            // Finalize the barrier planner\r\n            this.barrierPlanner.finalize();\r\n            // Finalize the road planner\r\n            this.roadPlanner.finalize();\r\n            // Save flags and remove them\r\n            const flagsToWrite = _.filter(this.colony.flags, flag => flag.color == COLOR_WHITE);\r\n            for (const flag of flagsToWrite) {\r\n                this.memory.savedFlags.push({\r\n                    secondaryColor: flag.secondaryColor,\r\n                    pos: flag.pos,\r\n                    memory: flag.memory,\r\n                });\r\n                flag.remove();\r\n            }\r\n            this.memory.lastGenerated = Game.time;\r\n            console.log('Room layout and flag positions have been saved.');\r\n            // Destroy needed buildings\r\n            if (this.colony.level == 1) { // clear out room if setting in for first time\r\n                this.demolishMisplacedStructures(true, true);\r\n                // Demolish all barriers that aren't yours\r\n                for (const barrier of this.colony.room.barriers) {\r\n                    if (barrier.structureType == STRUCTURE_WALL || !barrier.my) {\r\n                        barrier.destroy();\r\n                    }\r\n                }\r\n            }\r\n            this.memory.recheckStructuresAt = Game.time + 3;\r\n            this.active = false;\r\n        }\r\n        else {\r\n            log.warning('Not a valid room layout! Must have both hatchery and commandCenter placements ' +\r\n                'or bunker placement.');\r\n        }\r\n    }\r\n    /* Whether a constructionSite should be placed at a position */\r\n    static canBuild(structureType, pos) {\r\n        if (!pos.room)\r\n            return false;\r\n        const buildings = _.filter(pos.lookFor(LOOK_STRUCTURES), s => s && s.structureType == structureType);\r\n        const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);\r\n        if (!buildings || buildings.length == 0) {\r\n            if (!sites || sites.length == 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Whether a structure (or constructionSite) of given type should be at location.\r\n     */\r\n    structureShouldBeHere(structureType, pos, level = this.colony.controller.level) {\r\n        if (structureType == STRUCTURE_ROAD) {\r\n            return this.roadShouldBeHere(pos);\r\n        }\r\n        else if (structureType == STRUCTURE_RAMPART) {\r\n            return this.barrierPlanner.barrierShouldBeHere(pos);\r\n        }\r\n        else if (structureType == STRUCTURE_EXTRACTOR) {\r\n            return pos.lookFor(LOOK_MINERALS).length > 0;\r\n        }\r\n        else {\r\n            if (_.isEmpty(this.map)) {\r\n                this.recallMap(level);\r\n            }\r\n            const positions = this.map[structureType];\r\n            if (positions && _.find(positions, p => p.isEqualTo(pos))) {\r\n                return true;\r\n            }\r\n            if (structureType == STRUCTURE_CONTAINER || structureType == STRUCTURE_LINK) {\r\n                const thingsBuildingLinksAndContainers = _.map([...this.colony.room.sources,\r\n                    this.colony.room.mineral,\r\n                    this.colony.controller], thing => thing.pos);\r\n                const maxRange = 4;\r\n                return pos.findInRange(thingsBuildingLinksAndContainers, 4).length > 0;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Demolish all hostile structures in the room\r\n     */\r\n    demolishHostileStructures(destroyStorageUnits = false) {\r\n        _.forEach(this.colony.room.walls, wall => wall.destroy()); // overmind never uses walls\r\n        for (const structure of _.filter(this.colony.room.hostileStructures)) {\r\n            if ((structure.structureType != STRUCTURE_STORAGE && structure.structureType != STRUCTURE_TERMINAL)\r\n                || destroyStorageUnits) {\r\n                structure.destroy();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Remove all hostile constructionSites and ones which are misplaced\r\n     */\r\n    removeMisplacedConstructionSites() {\r\n        for (const site of this.colony.room.find(FIND_CONSTRUCTION_SITES)) {\r\n            if (site.owner.username != MY_USERNAME) {\r\n                site.remove();\r\n            }\r\n            else if (!this.structureShouldBeHere(site.structureType, site.pos)) {\r\n                site.remove();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Create construction sites for any buildings that need to be built\r\n     */\r\n    demolishMisplacedStructures(skipRamparts = true, destroyAllStructureTypes = false) {\r\n        this.demolishHostileStructures();\r\n        this.removeMisplacedConstructionSites();\r\n        if (getAllColonies().length <= 1 && !this.colony.storage) {\r\n            return; // Not safe to move structures until you have multiple colonies or a storage\r\n        }\r\n        // Start terminal evacuation if it needs to be moved\r\n        if (this.colony.terminal) {\r\n            if (this.colony.storage && !this.structureShouldBeHere(STRUCTURE_STORAGE, this.colony.storage.pos)\r\n                || !this.structureShouldBeHere(STRUCTURE_TERMINAL, this.colony.terminal.pos)) {\r\n                DirectiveTerminalRebuildState.createIfNotPresent(this.colony.terminal.pos, 'pos');\r\n            }\r\n        }\r\n        // Max buildings that can be placed each tick\r\n        const count = RoomPlanner_1.settings.maxSitesPerColony - this.colony.constructionSites.length;\r\n        // Recall the appropriate map\r\n        this.recallMap();\r\n        if (!this.map || this.map == {}) { // in case a map hasn't been generated yet\r\n            log.info(this.colony.name + ' does not have a room plan yet! Unable to demolish errant structures.');\r\n        }\r\n        // Destroy extractor if needed\r\n        if (this.colony.room.extractor && !this.colony.room.extractor.my) {\r\n            this.colony.room.extractor.destroy();\r\n        }\r\n        // Build missing structures from room plan\r\n        this.memory.relocating = false;\r\n        for (const priority of DemolishStructurePriorities) {\r\n            const structureType = priority.structureType;\r\n            // // don't demolish bunker baby ramparts until the new ones are sufficiently big\r\n            // if (structureType == STRUCTURE_RAMPART && this.colony.layout == 'bunker') {\r\n            // \tlet bunkerBarriers = _.filter(this.colony.room.barriers, b => insideBunkerBounds(b.pos, this.colony));\r\n            // \tlet avgBarrierHits = (_.sum(bunkerBarriers, barrier => barrier.hits) / bunkerBarriers.length) || 0;\r\n            // \tif (avgBarrierHits < 1e+6) continue;\r\n            // }\r\n            const maxRemoved = priority.maxRemoved || Infinity;\r\n            let removeCount = 0;\r\n            let structures = _.filter(this.colony.room.find(FIND_STRUCTURES), s => s.structureType == structureType);\r\n            if (structureType == STRUCTURE_WALL) {\r\n                structures = _.filter(structures, wall => wall.hits != undefined); // can't destroy newbie walls\r\n            }\r\n            // Loop through all structures and conditionally remove ones which are misplaced\r\n            for (const structure of structures) {\r\n                if (!this.structureShouldBeHere(structureType, structure.pos) ||\r\n                    (isOwnedStructure(structure) && !structure.my)) {\r\n                    // Don't demolish your own ramparts, just let them decay\r\n                    if (skipRamparts && !destroyAllStructureTypes && structure.structureType == STRUCTURE_RAMPART\r\n                        && structure.my) {\r\n                        continue;\r\n                    }\r\n                    // remove misplaced structures or hostile owned structures, with exceptions below\r\n                    if (this.colony.level < 4\r\n                        && (structureType == STRUCTURE_STORAGE || structureType == STRUCTURE_TERMINAL)) {\r\n                        break; // don't destroy terminal or storage when under RCL4 - can use energy inside\r\n                    }\r\n                    if (structureType != STRUCTURE_WALL && structureType != STRUCTURE_RAMPART) {\r\n                        this.memory.relocating = true;\r\n                    }\r\n                    // Don't remove the terminal until you have rebuilt storage\r\n                    if (this.colony.level >= 6 && structureType == STRUCTURE_TERMINAL) {\r\n                        if (!this.colony.storage) {\r\n                            log.info(`${this.colony.name}: waiting until storage is built to remove terminal`);\r\n                            return;\r\n                        }\r\n                        else if (this.colony.terminal &&\r\n                            _.sum(this.colony.terminal.store) - this.colony.terminal.energy > 1000) {\r\n                            log.info(`${this.colony.name}: waiting on resources to evacuate before removing terminal`);\r\n                            return;\r\n                        }\r\n                        else if (this.colony.storage &&\r\n                            this.structureShouldBeHere(STRUCTURE_STORAGE, this.colony.storage.pos) &&\r\n                            this.colony.storage.energy\r\n                                < Energetics.settings.storage.energy.destroyTerminalThreshold) {\r\n                            log.info(`${this.colony.name}: waiting to move energy to storage before removing terminal`);\r\n                            return;\r\n                        }\r\n                    }\r\n                    // Only remove a maximum number of structures at a time\r\n                    const amountMissing = CONTROLLER_STRUCTURES[structureType][this.colony.level] - structures.length\r\n                        + removeCount;\r\n                    if (amountMissing < maxRemoved) {\r\n                        if (structureType == STRUCTURE_SPAWN && this.colony.spawns.length == 1) {\r\n                            const spawnCost = 15000;\r\n                            if (this.colony.assets[RESOURCE_ENERGY] < spawnCost) {\r\n                                log.warning(`${this.colony.print}: Unsafe to destroy misplaced spawn: ` +\r\n                                    `${this.colony.assets[RESOURCE_ENERGY]}/${spawnCost} energy available`);\r\n                                if (!destroyAllStructureTypes) {\r\n                                    return;\r\n                                }\r\n                            }\r\n                            const workTicksNeeded = 15000 / BUILD_POWER;\r\n                            const workTicksAvailable = _.sum(this.colony.overlords.work.workers, worker => worker.getActiveBodyparts(WORK) * (worker.ticksToLive || 0));\r\n                            if (workTicksAvailable < workTicksNeeded) {\r\n                                log.warning(`${this.colony.print}: Unsafe to destroy misplaced spawn: ` +\r\n                                    `${workTicksAvailable}/${workTicksNeeded} [WORK * ticks] available`);\r\n                                if (!destroyAllStructureTypes) {\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n                        const result = structure.destroy();\r\n                        if (result != OK) {\r\n                            log.warning(`${this.colony.name}: couldn't destroy structure of type ` +\r\n                                `\"${structureType}\" at ${structure.pos.print}. Result: ${result}`);\r\n                        }\r\n                        else {\r\n                            log.info(`${this.colony.name}: destroyed ${structureType} at ${structure.pos.print}`);\r\n                        }\r\n                        removeCount++;\r\n                        this.memory.recheckStructuresAt = Game.time + RoomPlanner_1.settings.recheckAfter;\r\n                    }\r\n                }\r\n            }\r\n            if (this.memory.relocating && !destroyAllStructureTypes) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Create construction sites for any buildings that need to be built\r\n     */\r\n    buildMissingStructures() {\r\n        // Max buildings that can be placed each tick\r\n        let count = RoomPlanner_1.settings.maxSitesPerColony - this.colony.constructionSites.length;\r\n        // Recall the appropriate map\r\n        this.recallMap();\r\n        if (!this.map || this.map == {}) { // in case a map hasn't been generated yet\r\n            log.info(this.colony.name + ' does not have a room plan yet! Unable to build missing structures.');\r\n        }\r\n        // Build missing structures from room plan\r\n        for (const structureType of BuildPriorities) {\r\n            if (this.map[structureType]) {\r\n                for (const pos of this.map[structureType]) {\r\n                    if (count > 0 && RoomPlanner_1.canBuild(structureType, pos)) {\r\n                        const result = pos.createConstructionSite(structureType);\r\n                        if (result != OK) {\r\n                            const structures = pos.lookFor(LOOK_STRUCTURES);\r\n                            for (const structure of structures) {\r\n                                // let thisImportance = _.findIndex(BuildPriorities, type => type == structureType);\r\n                                // let existingImportance = _.findIndex(BuildPriorities,\r\n                                // \t\t\t\t\t\t\t\t\t type => type == structure.structureType);\r\n                                const safeTypes = [STRUCTURE_STORAGE, STRUCTURE_TERMINAL, STRUCTURE_SPAWN];\r\n                                // Destroy the structure if it is less important and not protected\r\n                                if (!this.structureShouldBeHere(structure.structureType, pos)\r\n                                    && !safeTypes.includes(structure.structureType)) {\r\n                                    const result = structure.destroy();\r\n                                    log.info(`${this.colony.name}: destroyed ${structure.structureType} at` +\r\n                                        ` ${structure.pos.print}`);\r\n                                    if (result == OK) {\r\n                                        this.memory.recheckStructuresAt = Game.time +\r\n                                            RoomPlanner_1.settings.recheckAfter;\r\n                                    }\r\n                                }\r\n                            }\r\n                            log.warning(`${this.colony.name}: couldn't create construction site of type ` +\r\n                                `\"${structureType}\" at ${pos.print}. Result: ${result}`);\r\n                        }\r\n                        else {\r\n                            count--;\r\n                            this.memory.recheckStructuresAt = Game.time + RoomPlanner_1.settings.recheckAfter;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Build extractor on mineral deposit if not already present\r\n        const mineral = this.colony.room.find(FIND_MINERALS)[0];\r\n        if (mineral) {\r\n            const extractor = mineral.pos.lookForStructure(STRUCTURE_EXTRACTOR);\r\n            if (!extractor) {\r\n                mineral.pos.createConstructionSite(STRUCTURE_EXTRACTOR);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Calculate where the link will be built\r\n     */\r\n    calculateLinkPos(anchor) {\r\n        if (anchor.isEqualTo(this.colony.controller.pos)) {\r\n            return this.calculateUpgradeSiteLinkPos();\r\n        }\r\n        let originPos;\r\n        if (this.colony.storage) {\r\n            originPos = this.colony.storage.pos;\r\n        }\r\n        else if (this.storagePos) {\r\n            originPos = this.storagePos;\r\n        }\r\n        if (originPos) {\r\n            const path = Pathing.findShortestPath(anchor, originPos).path;\r\n            return _.find(path, pos => anchor.getRangeTo(pos) == 2);\r\n        }\r\n    }\r\n    /**\r\n     * Calculate where the link will be built for this site\r\n     */\r\n    calculateUpgradeSiteLinkPos() {\r\n        let originPos;\r\n        if (this.colony.storage) {\r\n            originPos = this.colony.storage.pos;\r\n        }\r\n        else if (this.storagePos) {\r\n            originPos = this.storagePos;\r\n        }\r\n        if (originPos && this.colony.upgradeSite.batteryPos) {\r\n            // Build link at last location on path from origin to battery\r\n            const path = Pathing.findShortestPath(this.colony.upgradeSite.batteryPos, originPos).path;\r\n            return path[0];\r\n        }\r\n    }\r\n    nextNeededLinkAnchor() {\r\n        const linksEtAl = _.map([]\r\n            .concat(this.colony.links, _.filter(this.colony.constructionSites, site => site.structureType == STRUCTURE_LINK)), s => s.pos);\r\n        // UpgradeSite goes first\r\n        const upgradeLink = this.colony.controller.pos.findClosestByLimitedRange(linksEtAl, 3);\r\n        if (!upgradeLink)\r\n            return this.colony.controller.pos;\r\n        // MiningSites by decreasing distance\r\n        const origin = (this.colony.storage || this.colony.terminal || _.first(this.colony.spawns) || this.colony).pos;\r\n        const farthestSources = _.sortBy(this.colony.room.sources, source => -1 * Pathing.distance(origin, source.pos));\r\n        for (const source of farthestSources) {\r\n            const sourceLink = source.pos.findClosestByLimitedRange(linksEtAl, 2);\r\n            if (!sourceLink)\r\n                return source.pos;\r\n        }\r\n    }\r\n    /**\r\n     * Builds links as they become available. UpgradeSite gets link first, then miningSites by distance.\r\n     */\r\n    buildNeededLinks() {\r\n        const numLinks = this.colony.links.length +\r\n            _.filter(this.colony.constructionSites, site => site.structureType == STRUCTURE_LINK).length;\r\n        const numLinksAllowed = CONTROLLER_STRUCTURES.link[this.colony.level];\r\n        if (numLinksAllowed > numLinks &&\r\n            (this.colony.bunker || (this.colony.hatchery && this.colony.hatchery.link)) &&\r\n            this.colony.commandCenter && this.colony.commandCenter.link) {\r\n            const anchor = this.nextNeededLinkAnchor();\r\n            if (!anchor) {\r\n                return;\r\n            }\r\n            const linkPos = this.calculateLinkPos(anchor);\r\n            if (!linkPos) {\r\n                log.warning(`Could not calculate link position for anchor at ${anchor.print}!`);\r\n                return;\r\n            }\r\n            linkPos.createConstructionSite(STRUCTURE_LINK);\r\n        }\r\n    }\r\n    /**\r\n     * Quick lookup for if a road should be in this position. Roads returning false won't be maintained.\r\n     */\r\n    roadShouldBeHere(pos) {\r\n        return this.roadPlanner.roadShouldBeHere(pos);\r\n    }\r\n    init() {\r\n        if (this.active && getAutonomyLevel() == Autonomy.Automatic) {\r\n            let bunkerAnchor;\r\n            if (this.colony.spawns.length > 0) { // in case of very first spawn\r\n                const lowerRightSpawn = maxBy(this.colony.spawns, s => 50 * s.pos.y + s.pos.x);\r\n                const spawnPos = lowerRightSpawn.pos;\r\n                bunkerAnchor = new RoomPosition(spawnPos.x - 4, spawnPos.y, spawnPos.roomName);\r\n            }\r\n            else {\r\n                const expansionData = this.colony.room.memory[\"e\" /* EXPANSION_DATA */];\r\n                if (expansionData) {\r\n                    bunkerAnchor = derefCoords(expansionData.bunkerAnchor, this.colony.room.name);\r\n                }\r\n                else {\r\n                    log.error(`Cannot determine anchor! No spawns or expansionData.bunkerAnchor!`);\r\n                    return;\r\n                }\r\n            }\r\n            this.addComponent('bunker', bunkerAnchor);\r\n        }\r\n        this.barrierPlanner.init();\r\n        this.roadPlanner.init();\r\n    }\r\n    shouldRecheck(offset = 0) {\r\n        if (Game.time == (this.memory.recheckStructuresAt || Infinity) + offset) {\r\n            return true;\r\n        }\r\n        else if (this.colony.level == 8) {\r\n            return Game.time % (2 * RoomPlanner_1.settings.siteCheckFrequency) == 2 * this.colony.id + offset;\r\n        }\r\n        else {\r\n            return Game.time % RoomPlanner_1.settings.siteCheckFrequency == 2 * this.colony.id + offset;\r\n        }\r\n    }\r\n    run() {\r\n        if (this.active) {\r\n            this.make();\r\n            this.visuals();\r\n        }\r\n        else {\r\n            // Build missing structures from the layout\r\n            if (this.shouldRecheck()) {\r\n                this.demolishMisplacedStructures();\r\n            }\r\n            else if (this.shouldRecheck(1)) {\r\n                this.buildMissingStructures();\r\n            }\r\n            // Build missing links as needed\r\n            if (Game.time % RoomPlanner_1.settings.linkCheckFrequency == 3) {\r\n                this.buildNeededLinks();\r\n            }\r\n        }\r\n        // Run the barrier planner\r\n        this.barrierPlanner.run();\r\n        // Run the road planner\r\n        this.roadPlanner.run();\r\n        if (this.active && getAutonomyLevel() == Autonomy.Automatic) {\r\n            if (this.placements.bunker) {\r\n                this.finalize();\r\n            }\r\n            else {\r\n                log.warning(`No bunker placement!`);\r\n            }\r\n        }\r\n    }\r\n    visuals() {\r\n        // Draw the map\r\n        if (getAutonomyLevel() < Autonomy.Automatic) {\r\n            const expansionData = this.colony.room.memory[\"e\" /* EXPANSION_DATA */];\r\n            if (expansionData) {\r\n                const bunkerPos = derefCoords(expansionData.bunkerAnchor, this.colony.room.name);\r\n                if (bunkerPos) {\r\n                    Visualizer.drawLayout(bunkerLayout, bunkerPos, { opacity: 0.2 });\r\n                }\r\n            }\r\n        }\r\n        Visualizer.drawStructureMap(this.map);\r\n    }\r\n};\r\nRoomPlanner.settings = {\r\n    recheckAfter: 50,\r\n    siteCheckFrequency: onPublicServer() ? 300 : 100,\r\n    linkCheckFrequency: 100,\r\n    maxSitesPerColony: onPublicServer() ? 10 : 25,\r\n    maxDismantleCount: 5,\r\n};\r\nRoomPlanner = RoomPlanner_1 = tslib_1.__decorate([\r\n    profile\r\n], RoomPlanner);\r\nexport { RoomPlanner };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/directives/terminalState/terminalState_rebuild.ts","C:/git/Overmind/src/logistics/Energetics.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/priorities/priorities_structures.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/stringConstants.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/visuals/Visualizer.ts","C:/git/Overmind/src/~settings.ts","C:/git/Overmind/src/roomPlanner/BarrierPlanner.ts","C:/git/Overmind/src/roomPlanner/layouts/bunker.ts","C:/git/Overmind/src/roomPlanner/layouts/commandCenter.ts","C:/git/Overmind/src/roomPlanner/layouts/hatchery.ts","C:/git/Overmind/src/roomPlanner/RoadPlanner.ts"]}
