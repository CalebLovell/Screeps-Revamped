{"code":"/**\r\n * Code for calculating the minCut in a room, written by Saruss,\r\n * adapted for Typescript and flexible room subsets by Chobobobo,\r\n * modified and debugged by Muon.\r\n */\r\nimport { log } from '../console/log';\r\nconst UNWALKABLE = -10;\r\nconst RANGE_MODIFIER = 1; // this parameter sets the scaling of weights to prefer walls closer protection bounds\r\nconst RANGE_PADDING = 3; // max range to reduce weighting; RANGE_MODIFIER * RANGE_PADDING must be < PROTECTED\r\nconst NORMAL = 0;\r\nconst PROTECTED = 10;\r\nconst CANNOT_BUILD = 20;\r\nconst EXIT = 30;\r\nexport class Graph {\r\n    constructor(totalVertices) {\r\n        this.totalVertices = totalVertices;\r\n        this.level = Array(totalVertices);\r\n        // An array of edges for each vertex\r\n        this.edges = Array(totalVertices).fill(0).map((x) => []);\r\n    }\r\n    /**\r\n     * Create a new edge in the graph as well as a corresponding reverse edge on the residual graph\r\n     * @param from - vertex edge starts at\r\n     * @param to - vertex edge leads to\r\n     * @param capacity - max flow capacity for this edge\r\n     */\r\n    newEdge(from, to, capacity) {\r\n        // Normal forward Edge\r\n        this.edges[from].push({ to, resEdge: this.edges[to].length, capacity, flow: 0 });\r\n        // reverse Edge for Residual Graph\r\n        this.edges[to].push({ to: from, resEdge: this.edges[from].length - 1, capacity: 0, flow: 0 });\r\n    }\r\n    /**\r\n     * Uses Breadth First Search to see if a path exists to the vertex 'to' and generate the level graph\r\n     * @param from - vertex to start from\r\n     * @param to - vertex to try and reach\r\n     */\r\n    createLevelGraph(from, to) {\r\n        if (to >= this.totalVertices) {\r\n            return false;\r\n        }\r\n        this.level.fill(-1); // reset old levels\r\n        this.level[from] = 0;\r\n        const q = []; // queue with s as starting point\r\n        q.push(from);\r\n        let u = 0;\r\n        let edge = null;\r\n        while (q.length) {\r\n            u = q.shift();\r\n            for (edge of this.edges[u]) {\r\n                if (this.level[edge.to] < 0 && edge.flow < edge.capacity) {\r\n                    this.level[edge.to] = this.level[u] + 1;\r\n                    q.push(edge.to);\r\n                }\r\n            }\r\n        }\r\n        return this.level[to] >= 0; // return if theres a path, no level, no path!\r\n    }\r\n    /**\r\n     * Depth First Search-like: send flow at along path from from->to recursively while increasing the level of the\r\n     * visited vertices by one\r\n     * @param start - the vertex to start at\r\n     * @param end - the vertex to try and reach\r\n     * @param targetFlow - the amount of flow to try and achieve\r\n     * @param count - keep track of which vertices have been visited so we don't include them twice\r\n     */\r\n    calcFlow(start, end, targetFlow, count) {\r\n        if (start === end) { // Sink reached , abort recursion\r\n            return targetFlow;\r\n        }\r\n        let edge;\r\n        let flowTillHere = 0;\r\n        let flowToT = 0;\r\n        while (count[start] < this.edges[start].length) { // Visit all edges of the vertex one after the other\r\n            edge = this.edges[start][count[start]];\r\n            if (this.level[edge.to] === this.level[start] + 1 && edge.flow < edge.capacity) {\r\n                // Edge leads to Vertex with a level one higher, and has flow left\r\n                flowTillHere = Math.min(targetFlow, edge.capacity - edge.flow);\r\n                flowToT = this.calcFlow(edge.to, end, flowTillHere, count);\r\n                if (flowToT > 0) {\r\n                    edge.flow += flowToT; // Add Flow to current edge\r\n                    // subtract from reverse Edge -> Residual Graph neg. Flow to use backward direction of BFS/DFS\r\n                    this.edges[edge.to][edge.resEdge].flow -= flowToT;\r\n                    return flowToT;\r\n                }\r\n            }\r\n            count[start]++;\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Uses Breadth First Search to find the vertices in the minCut for the graph\r\n     * - Must call calcMinCut first to prepare the graph\r\n     * @param from - the vertex to start from\r\n     */\r\n    getMinCut(from) {\r\n        const eInCut = [];\r\n        this.level.fill(-1);\r\n        this.level[from] = 1;\r\n        const q = [];\r\n        q.push(from);\r\n        let u = 0;\r\n        let edge;\r\n        while (q.length) {\r\n            u = q.shift();\r\n            for (edge of this.edges[u]) {\r\n                if (edge.flow < edge.capacity) {\r\n                    if (this.level[edge.to] < 1) {\r\n                        this.level[edge.to] = 1;\r\n                        q.push(edge.to);\r\n                    }\r\n                }\r\n                if (edge.flow === edge.capacity && edge.capacity > 0) { // blocking edge -> could be in min cut\r\n                    eInCut.push({ to: edge.to, unreachable: u });\r\n                }\r\n            }\r\n        }\r\n        const minCut = [];\r\n        let cutEdge;\r\n        for (cutEdge of eInCut) {\r\n            if (this.level[cutEdge.to] === -1) {\r\n                // Only edges which are blocking and lead to the sink from unreachable vertices are in the min cut\r\n                minCut.push(cutEdge.unreachable);\r\n            }\r\n        }\r\n        return minCut;\r\n    }\r\n    /**\r\n     * Calculates min-cut graph using Dinic's Algorithm.\r\n     * use getMinCut to get the actual verticies in the minCut\r\n     * @param source - Source vertex\r\n     * @param sink - Sink vertex\r\n     */\r\n    calcMinCut(source, sink) {\r\n        if (source === sink) {\r\n            return -1;\r\n        }\r\n        let ret = 0;\r\n        let count = [];\r\n        let flow = 0;\r\n        while (this.createLevelGraph(source, sink)) {\r\n            count = Array(this.totalVertices + 1).fill(0);\r\n            do {\r\n                flow = this.calcFlow(source, sink, Number.MAX_VALUE, count);\r\n                if (flow > 0) {\r\n                    ret += flow;\r\n                }\r\n            } while (flow);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n/**\r\n * An Array with Terrain information: -1 not usable, 2 Sink (Leads to Exit)\r\n * @param room - the room to generate the terrain map from\r\n */\r\nexport function get2DArray(roomName, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {\r\n    const room2D = Array(50).fill(NORMAL).map((d) => Array(50).fill(NORMAL)); // Array for room tiles\r\n    let x;\r\n    let y;\r\n    const terrain = Game.map.getRoomTerrain(roomName);\r\n    for (x = bounds.x1; x <= bounds.x2; x++) {\r\n        for (y = bounds.y1; y <= bounds.y2; y++) {\r\n            if (terrain.get(x, y) === TERRAIN_MASK_WALL) {\r\n                room2D[x][y] = UNWALKABLE; // Mark unwalkable\r\n            }\r\n            else if (x === bounds.x1 || y === bounds.y1 || x === bounds.x2 || y === bounds.y2) {\r\n                room2D[x][y] = EXIT; // Mark exit tiles\r\n            }\r\n        }\r\n    }\r\n    // Marks tiles as unbuildable if they are proximate to exits\r\n    for (y = bounds.y1 + 1; y <= bounds.y2 - 1; y++) {\r\n        if (room2D[bounds.x1][y] === EXIT) {\r\n            for (const dy of [-1, 0, 1]) {\r\n                if (room2D[bounds.x1 + 1][y + dy] !== UNWALKABLE) {\r\n                    room2D[bounds.x1 + 1][y + dy] = CANNOT_BUILD;\r\n                }\r\n            }\r\n        }\r\n        if (room2D[bounds.x2][y] === EXIT) {\r\n            for (const dy of [-1, 0, 1]) {\r\n                if (room2D[bounds.x2 - 1][y + dy] !== UNWALKABLE) {\r\n                    room2D[bounds.x2 - 1][y + dy] = CANNOT_BUILD;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (x = bounds.x1 + 1; x <= bounds.x2 - 1; x++) {\r\n        if (room2D[x][bounds.y1] === EXIT) {\r\n            for (const dx of [-1, 0, 1]) {\r\n                if (room2D[x + dx][bounds.y1 + 1] !== UNWALKABLE) {\r\n                    room2D[x + dx][bounds.y1 + 1] = CANNOT_BUILD;\r\n                }\r\n            }\r\n        }\r\n        if (room2D[x][bounds.y2] === EXIT) {\r\n            for (const dx of [-1, 0, 1]) {\r\n                if (room2D[x + dx][bounds.y2 - 1] !== UNWALKABLE) {\r\n                    room2D[x + dx][bounds.y2 - 1] = CANNOT_BUILD;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return room2D;\r\n}\r\n/**\r\n * Function to create Source, Sink, Tiles arrays: takes a rectangle-Array as input for Tiles that are to Protect\r\n * @param room - the room to consider\r\n * @param toProtect - the coordinates to protect inside the walls\r\n * @param bounds - the area to consider for the minCut\r\n */\r\nexport function createGraph(roomName, toProtect, preferCloserBarriers = true, preferCloserBarrierLimit = Infinity, // ignore the toProtect[n] for n > this value\r\nvisualize = true, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {\r\n    const visual = new RoomVisual(roomName);\r\n    const roomArray = get2DArray(roomName, bounds);\r\n    // For all Rectangles, set edges as source (to protect area) and area as unused\r\n    let r;\r\n    let x;\r\n    let y;\r\n    for (r of toProtect) {\r\n        if (bounds.x1 >= bounds.x2 || bounds.y1 >= bounds.y2 ||\r\n            bounds.x1 < 0 || bounds.y1 < 0 || bounds.x2 > 49 || bounds.y2 > 49) {\r\n            return console.log('ERROR: Invalid bounds', JSON.stringify(bounds));\r\n        }\r\n        else if (r.x1 >= r.x2 || r.y1 >= r.y2) {\r\n            return console.log('ERROR: Rectangle', JSON.stringify(r), 'invalid.');\r\n        }\r\n        else if (r.x1 < bounds.x1 || r.x2 > bounds.x2 || r.y1 < bounds.y1 || r.y2 > bounds.y2) {\r\n            return console.log('ERROR: Rectangle', JSON.stringify(r), 'out of bounds:', JSON.stringify(bounds));\r\n        }\r\n        for (x = r.x1; x <= r.x2; x++) {\r\n            for (y = r.y1; y <= r.y2; y++) {\r\n                if (x === r.x1 || x === r.x2 || y === r.y1 || y === r.y2) {\r\n                    if (roomArray[x][y] === NORMAL) {\r\n                        roomArray[x][y] = PROTECTED;\r\n                    }\r\n                }\r\n                else {\r\n                    roomArray[x][y] = UNWALKABLE;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Preferentially weight closer tiles\r\n    if (preferCloserBarriers) {\r\n        for (r of _.take(toProtect, preferCloserBarrierLimit)) {\r\n            const [xmin, xmax] = [Math.max(r.x1 - RANGE_PADDING, 0), Math.min(r.x2 + RANGE_PADDING, 49)];\r\n            const [ymin, ymax] = [Math.max(r.y1 - RANGE_PADDING, 0), Math.min(r.y2 + RANGE_PADDING, 49)];\r\n            for (x = xmin; x <= xmax; x++) {\r\n                for (y = ymin; y <= ymax; y++) {\r\n                    if (roomArray[x][y] >= NORMAL && roomArray[x][y] < PROTECTED) {\r\n                        const x1range = Math.max(r.x1 - x, 0);\r\n                        const x2range = Math.max(x - r.x2, 0);\r\n                        const y1range = Math.max(r.y1 - y, 0);\r\n                        const y2range = Math.max(y - r.y2, 0);\r\n                        const rangeToBorder = Math.max(x1range, x2range, y1range, y2range);\r\n                        const modifiedWeight = NORMAL + RANGE_MODIFIER * (RANGE_PADDING - rangeToBorder);\r\n                        roomArray[x][y] = Math.max(roomArray[x][y], modifiedWeight);\r\n                        if (visualize) {\r\n                            visual.text(`${roomArray[x][y]}`, x, y);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // ********************** Visualization\r\n    if (visualize) {\r\n        for (x = bounds.x1; x <= bounds.x2; x++) {\r\n            for (y = bounds.y1; y <= bounds.y2; y++) {\r\n                if (roomArray[x][y] === UNWALKABLE) {\r\n                    visual.circle(x, y, { radius: 0.5, fill: '#1b1b9f', opacity: 0.3 });\r\n                }\r\n                else if (roomArray[x][y] > UNWALKABLE && roomArray[x][y] < NORMAL) {\r\n                    visual.circle(x, y, { radius: 0.5, fill: '#42cce8', opacity: 0.3 });\r\n                }\r\n                else if (roomArray[x][y] === NORMAL) {\r\n                    visual.circle(x, y, { radius: 0.5, fill: '#bdb8b8', opacity: 0.3 });\r\n                }\r\n                else if (roomArray[x][y] > NORMAL && roomArray[x][y] < PROTECTED) {\r\n                    visual.circle(x, y, { radius: 0.5, fill: '#9929e8', opacity: 0.3 });\r\n                }\r\n                else if (roomArray[x][y] === PROTECTED) {\r\n                    visual.circle(x, y, { radius: 0.5, fill: '#e800c6', opacity: 0.3 });\r\n                }\r\n                else if (roomArray[x][y] === CANNOT_BUILD) {\r\n                    visual.circle(x, y, { radius: 0.5, fill: '#e8000f', opacity: 0.3 });\r\n                }\r\n                else if (roomArray[x][y] === EXIT) {\r\n                    visual.circle(x, y, { radius: 0.5, fill: '#000000', opacity: 0.3 });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // initialise graph\r\n    // possible 2*50*50 +2 (st) Vertices (Walls etc set to unused later)\r\n    const g = new Graph(2 * 50 * 50 + 2);\r\n    const infini = Number.MAX_VALUE;\r\n    const surr = [[0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1]];\r\n    // per Tile (0 in Array) top + bot with edge of c=1 from top to bott  (use every tile once!)\r\n    // infini edge from bot to top vertices of adjacent tiles if they not protected (array =1)\r\n    // (no reverse edges in normal graph)\r\n    // per prot. Tile (1 in array) Edge from source to this tile with infini cap.\r\n    // per exit Tile (2in array) Edge to sink with infini cap.\r\n    // source is at  pos 2*50*50, sink at 2*50*50+1 as first tile is 0,0 => pos 0\r\n    // top vertices <-> x,y : v=y*50+x   and x= v % 50  y=v/50 (math.floor?)\r\n    // bot vertices <-> top + 2500\r\n    const source = 2 * 50 * 50;\r\n    const sink = 2 * 50 * 50 + 1;\r\n    let top = 0;\r\n    let bot = 0;\r\n    let dx = 0;\r\n    let dy = 0;\r\n    // max = 49;\r\n    const baseCapacity = 10;\r\n    const modifyWeight = preferCloserBarriers ? 1 : 0;\r\n    for (x = bounds.x1 + 1; x < bounds.x2; x++) {\r\n        for (y = bounds.y1 + 1; y < bounds.y2; y++) {\r\n            top = y * 50 + x;\r\n            bot = top + 2500;\r\n            if (roomArray[x][y] >= NORMAL && roomArray[x][y] <= PROTECTED) {\r\n                if (roomArray[x][y] >= NORMAL && roomArray[x][y] < PROTECTED) {\r\n                    g.newEdge(top, bot, baseCapacity - modifyWeight * roomArray[x][y]); // add surplus weighting\r\n                }\r\n                else if (roomArray[x][y] === PROTECTED) { // connect this to the source\r\n                    g.newEdge(source, top, infini);\r\n                    g.newEdge(top, bot, baseCapacity - modifyWeight * RANGE_PADDING * RANGE_MODIFIER);\r\n                }\r\n                for (let i = 0; i < 8; i++) { // attach adjacent edges\r\n                    dx = x + surr[i][0];\r\n                    dy = y + surr[i][1];\r\n                    if ((roomArray[dx][dy] >= NORMAL && roomArray[dx][dy] < PROTECTED)\r\n                        || roomArray[dx][dy] === CANNOT_BUILD) {\r\n                        g.newEdge(bot, dy * 50 + dx, infini);\r\n                    }\r\n                }\r\n            }\r\n            else if (roomArray[x][y] === CANNOT_BUILD) { // near Exit\r\n                g.newEdge(top, sink, infini);\r\n            }\r\n        }\r\n    } // graph finished\r\n    return g;\r\n}\r\n/**\r\n * Main function to be called by user: calculate min cut tiles from room using rectangles as protected areas\r\n * @param room - the room to use\r\n * @param rectangles - the areas to protect, defined as rectangles\r\n * @param bounds - the area to be considered for the minCut\r\n */\r\nexport function getCutTiles(roomName, toProtect, preferCloserBarriers = true, preferCloserBarrierLimit = Infinity, visualize = true, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {\r\n    const graph = createGraph(roomName, toProtect, preferCloserBarriers, preferCloserBarrierLimit, visualize, bounds);\r\n    if (!graph) {\r\n        return [];\r\n    }\r\n    let x;\r\n    let y;\r\n    const source = 2 * 50 * 50; // Position Source / Sink in Room-Graph\r\n    const sink = 2 * 50 * 50 + 1;\r\n    const count = graph.calcMinCut(source, sink);\r\n    // console.log('Number of Tiles in Cut:', count);\r\n    const positions = [];\r\n    if (count > 0) {\r\n        const cutVertices = graph.getMinCut(source);\r\n        let v;\r\n        for (v of cutVertices) {\r\n            // x= vertex % 50  y=v/50 (math.floor?)\r\n            x = v % 50;\r\n            y = Math.floor(v / 50);\r\n            positions.push({ x, y });\r\n        }\r\n    }\r\n    // Visualise Result\r\n    if (positions.length > 0) {\r\n        const visual = new RoomVisual(roomName);\r\n        for (let i = positions.length - 1; i >= 0; i--) {\r\n            visual.circle(positions[i].x, positions[i].y, { radius: 0.5, fill: '#ff7722', opacity: 0.9 });\r\n        }\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n    const wholeRoom = bounds.x1 === 0 && bounds.y1 === 0 && bounds.x2 === 49 && bounds.y2 === 49;\r\n    return wholeRoom ? positions : pruneDeadEnds(roomName, positions);\r\n}\r\n/**\r\n * Removes unnecessary tiles if they are blocking the path to a dead end\r\n * Useful if minCut has been run on a subset of the room\r\n * @param roomName - Room to work in\r\n * @param cutTiles - Array of tiles which are in the minCut\r\n */\r\nexport function pruneDeadEnds(roomName, cutTiles) {\r\n    // Get Terrain and set all cut-tiles as unwalkable\r\n    const roomArray = get2DArray(roomName);\r\n    let tile;\r\n    for (tile of cutTiles) {\r\n        roomArray[tile.x][tile.y] = UNWALKABLE;\r\n    }\r\n    // Floodfill from exits: save exit tiles in array and do a BFS-like search\r\n    const unvisited = [];\r\n    let y;\r\n    let x;\r\n    for (y = 0; y < 49; y++) {\r\n        if (roomArray[0][y] === EXIT) {\r\n            console.log('prune: toExit', 0, y);\r\n            unvisited.push(50 * y);\r\n        }\r\n        if (roomArray[49][y] === EXIT) {\r\n            console.log('prune: toExit', 49, y);\r\n            unvisited.push(50 * y + 49);\r\n        }\r\n    }\r\n    for (x = 0; x < 49; x++) {\r\n        if (roomArray[x][0] === EXIT) {\r\n            console.log('prune: toExit', x, 0);\r\n            unvisited.push(x);\r\n        }\r\n        if (roomArray[x][49] === EXIT) {\r\n            console.log('prune: toExit', x, 49);\r\n            unvisited.push(2450 + x); // 50*49=2450\r\n        }\r\n    }\r\n    // Iterate over all unvisited EXIT tiles and mark neigbours as EXIT tiles if walkable, add to unvisited\r\n    const surr = [[0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1]];\r\n    let currPos;\r\n    let dx;\r\n    let dy;\r\n    while (unvisited.length > 0) {\r\n        currPos = unvisited.pop();\r\n        x = currPos % 50;\r\n        y = Math.floor(currPos / 50);\r\n        for (let i = 0; i < 8; i++) {\r\n            dx = x + surr[i][0];\r\n            dy = y + surr[i][1];\r\n            if (dx < 0 || dx > 49 || dy < 0 || dy > 49) {\r\n                continue;\r\n            }\r\n            if ((roomArray[dx][dy] >= NORMAL && roomArray[dx][dy] < PROTECTED)\r\n                || roomArray[dx][dy] === CANNOT_BUILD) {\r\n                unvisited.push(50 * dy + dx);\r\n                roomArray[dx][dy] = EXIT;\r\n            }\r\n        }\r\n    }\r\n    // Remove min-Cut-Tile if there is no EXIT reachable by it\r\n    let leadsToExit;\r\n    const validCut = [];\r\n    for (tile of cutTiles) {\r\n        leadsToExit = false;\r\n        for (let j = 0; j < 8; j++) {\r\n            dx = tile.x + surr[j][0];\r\n            dy = tile.y + surr[j][1];\r\n            if (roomArray[dx][dy] === EXIT) {\r\n                leadsToExit = true;\r\n            }\r\n        }\r\n        if (leadsToExit) {\r\n            validCut.push(tile);\r\n        }\r\n    }\r\n    return validCut;\r\n}\r\n/**\r\n * Example function: demonstrates how to get a min cut with 2 rectangles, which define a \"to protect\" area\r\n * @param roomName - the name of the room to use for the test, must be visible\r\n */\r\nexport function testMinCut(colonyName, preferCloserBarriers = true) {\r\n    const colony = Overmind.colonies[colonyName];\r\n    if (!colony) {\r\n        return `No colony: ${colonyName}`;\r\n    }\r\n    let cpu = Game.cpu.getUsed();\r\n    // Rectangle Array, the Rectangles will be protected by the returned tiles\r\n    const rectArray = [];\r\n    const padding = 3;\r\n    if (colony.hatchery) {\r\n        const { x, y } = colony.hatchery.pos;\r\n        const [x1, y1] = [Math.max(x - 5 - padding, 0), Math.max(y - 4 - padding, 0)];\r\n        const [x2, y2] = [Math.min(x + 5 + padding, 49), Math.min(y + 6 + padding, 49)];\r\n        rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });\r\n    }\r\n    if (colony.commandCenter) {\r\n        const { x, y } = colony.commandCenter.pos;\r\n        const [x1, y1] = [Math.max(x - 3 - padding, 0), Math.max(y - 0 - padding, 0)];\r\n        const [x2, y2] = [Math.min(x + 0 + padding, 49), Math.min(y + 5 + padding, 49)];\r\n        rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });\r\n    }\r\n    if (colony.upgradeSite) {\r\n        const { x, y } = colony.upgradeSite.pos;\r\n        const [x1, y1] = [Math.max(x - 1, 0), Math.max(y - 1, 0)];\r\n        const [x2, y2] = [Math.min(x + 1, 49), Math.min(y + 1, 49)];\r\n        rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });\r\n    }\r\n    // Get Min cut\r\n    // Positions is an array where to build walls/ramparts\r\n    const positions = getCutTiles(colonyName, rectArray, preferCloserBarriers, 2);\r\n    // Test output\r\n    // console.log('Positions returned', positions.length);\r\n    cpu = Game.cpu.getUsed() - cpu;\r\n    // console.log('Needed', cpu, ' cpu time');\r\n    log.info(`preferCloserBarriers = ${preferCloserBarriers}; positions returned: ${positions.length};` +\r\n        ` CPU time: ${cpu}`);\r\n    return 'Finished';\r\n}\r\n/**\r\n * Example function: demonstrates how to get a min cut with 2 rectangles, which define a \"to protect\" area\r\n * while considering a subset of the larger room.\r\n * @param roomName - the name of the room to use for the test, must be visible\r\n */\r\nexport function testMinCutSubset(colonyName) {\r\n    const colony = Overmind.colonies[colonyName];\r\n    if (!colony) {\r\n        return `No colony: ${colonyName}`;\r\n    }\r\n    let cpu = Game.cpu.getUsed();\r\n    // Rectangle Array, the Rectangles will be protected by the returned tiles\r\n    const rectArray = [];\r\n    const padding = 3;\r\n    if (colony.hatchery) {\r\n        const { x, y } = colony.hatchery.pos;\r\n        rectArray.push({ x1: x - 5 - padding, y1: y - 4 - padding, x2: x + 5 + padding, y2: y + 6 + padding });\r\n    }\r\n    if (colony.commandCenter) {\r\n        const { x, y } = colony.commandCenter.pos;\r\n        rectArray.push({ x1: x - 3 - padding, y1: y - 0 - padding, x2: x + 0 + padding, y2: y + 5 + padding });\r\n    }\r\n    // Get Min cut, returns the positions where ramparts/walls need to be\r\n    const positions = getCutTiles(colonyName, rectArray, true, Infinity, true, { x1: 5, y1: 5, x2: 44, y2: 44 });\r\n    // Test output\r\n    console.log('Positions returned', positions.length);\r\n    cpu = Game.cpu.getUsed() - cpu;\r\n    console.log('Needed', cpu, ' cpu time');\r\n    return 'Finished';\r\n}\r\n","references":["C:/git/Overmind/src/console/log.ts"]}
