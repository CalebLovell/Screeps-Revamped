{"code":"import * as tslib_1 from \"tslib\";\r\nimport { $ } from '../../caching/GlobalCache';\r\nimport { log } from '../../console/log';\r\nimport { Roles, Setups } from '../../creepSetups/setups';\r\nimport { Pathing } from '../../movement/Pathing';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { getPosFromBunkerCoord, insideBunkerBounds, quadrantFillOrder } from '../../roomPlanner/layouts/bunker';\r\nimport { Tasks } from '../../tasks/Tasks';\r\nimport { hasMinerals, mergeSum, minBy } from '../../utilities/utils';\r\nimport { Overlord } from '../Overlord';\r\nfunction isSupplyStructure(structure) {\r\n    return structure.structureType == STRUCTURE_EXTENSION\r\n        || structure.structureType == STRUCTURE_LAB\r\n        || structure.structureType == STRUCTURE_TOWER\r\n        || structure.structureType == STRUCTURE_SPAWN;\r\n}\r\nfunction computeQuadrant(colony, quadrant) {\r\n    const positions = _.map(quadrant, coord => getPosFromBunkerCoord(coord, colony));\r\n    const structures = [];\r\n    for (const pos of positions) {\r\n        const structure = _.find(pos.lookFor(LOOK_STRUCTURES), s => isSupplyStructure(s));\r\n        if (structure) {\r\n            structures.push(structure);\r\n        }\r\n    }\r\n    return structures;\r\n}\r\n/**\r\n * A modified version of the queen overlord which contains a number of hard-coded optimization for bunker-type rooms.\r\n * This overlord supercedes the default queen overlord once the colony has a storage with a minimum amount of energy.\r\n */\r\nlet BunkerQueenOverlord = class BunkerQueenOverlord extends Overlord {\r\n    constructor(hatchery, priority = OverlordPriority.core.queen) {\r\n        super(hatchery, 'supply', priority);\r\n        this.queenSetup = Setups.queens.default;\r\n        this.queens = this.zerg(Roles.queen);\r\n        this.batteries = _.filter(this.room.containers, container => insideBunkerBounds(container.pos, this.colony));\r\n        this.storeStructures = _.compact([this.colony.terminal, this.colony.storage, ...this.batteries]);\r\n        this.quadrants = {\r\n            lowerRight: $.structures(this, 'LR', () => computeQuadrant(this.colony, quadrantFillOrder.lowerRight)),\r\n            upperLeft: $.structures(this, 'UL', () => computeQuadrant(this.colony, quadrantFillOrder.upperLeft)),\r\n            lowerLeft: $.structures(this, 'LL', () => computeQuadrant(this.colony, quadrantFillOrder.lowerLeft)),\r\n            upperRight: $.structures(this, 'UR', () => computeQuadrant(this.colony, quadrantFillOrder.upperRight)),\r\n        };\r\n        this.computeQueenAssignments();\r\n    }\r\n    computeQueenAssignments() {\r\n        // Assign quadrants to queens\r\n        this.assignments = _.zipObject(_.map(this.queens, queen => [queen.name, {}]));\r\n        const activeQueens = _.filter(this.queens, queen => !queen.spawning);\r\n        this.numActiveQueens = activeQueens.length;\r\n        if (this.numActiveQueens > 0) {\r\n            const quadrantAssignmentOrder = [this.quadrants.lowerRight,\r\n                this.quadrants.upperLeft,\r\n                this.quadrants.lowerLeft,\r\n                this.quadrants.upperRight];\r\n            let i = 0;\r\n            for (const quadrant of quadrantAssignmentOrder) {\r\n                const queen = activeQueens[i % activeQueens.length];\r\n                _.extend(this.assignments[queen.name], _.zipObject(_.map(quadrant, s => [s.id, true])));\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n    refresh() {\r\n        super.refresh();\r\n        $.refresh(this, 'batteries', 'storeStructures');\r\n        $.refreshObject(this, 'quadrants');\r\n        // Re-compute queen assignments if the number of queens has changed\r\n        if (_.filter(this.queens, queen => !queen.spawning).length != this.numActiveQueens) {\r\n            this.computeQueenAssignments();\r\n        }\r\n    }\r\n    init() {\r\n        for (const battery of this.batteries) {\r\n            if (hasMinerals(battery.store)) { // get rid of any minerals in the container if present\r\n                this.colony.logisticsNetwork.requestOutputMinerals(battery);\r\n            }\r\n        }\r\n        // const amount = this.colony.spawns.length > 1 ? 2 : 1;\r\n        const amount = this.colony.room.energyCapacityAvailable > 2000 ? 2 : 1;\r\n        this.wishlist(amount, this.queenSetup);\r\n    }\r\n    // Builds a series of tasks to empty unnecessary carry contents, withdraw required resources, and supply structures\r\n    buildSupplyTaskManifest(queen) {\r\n        let tasks = [];\r\n        // Step 1: empty all contents (this shouldn't be necessary since queen is normally empty at this point)\r\n        let queenPos = queen.pos;\r\n        if (_.sum(queen.carry) > 0) {\r\n            const transferTarget = this.colony.terminal || this.colony.storage || this.batteries[0];\r\n            if (transferTarget) {\r\n                tasks.push(Tasks.transferAll(transferTarget));\r\n                queenPos = transferTarget.pos;\r\n            }\r\n            else {\r\n                log.warning(`No transfer targets for ${queen.print}!`);\r\n                return null;\r\n            }\r\n        }\r\n        // Step 2: figure out what you need to supply for and calculate the needed resources\r\n        const queenCarry = {};\r\n        const allStore = mergeSum(_.map(this.storeStructures, s => s.store));\r\n        const supplyRequests = [];\r\n        for (const priority in this.colony.transportRequests.supply) {\r\n            for (const request of this.colony.transportRequests.supply[priority]) {\r\n                if (this.assignments[queen.name][request.target.id]) {\r\n                    supplyRequests.push(request);\r\n                }\r\n            }\r\n        }\r\n        const supplyTasks = [];\r\n        for (const request of supplyRequests) {\r\n            // stop when carry will be full\r\n            const remainingAmount = queen.carryCapacity - _.sum(queenCarry);\r\n            if (remainingAmount == 0)\r\n                break;\r\n            // figure out how much you can withdraw\r\n            let amount = Math.min(request.amount, remainingAmount);\r\n            amount = Math.min(amount, allStore[request.resourceType] || 0);\r\n            if (amount == 0)\r\n                continue;\r\n            // update the simulated carry\r\n            if (!queenCarry[request.resourceType]) {\r\n                queenCarry[request.resourceType] = 0;\r\n            }\r\n            queenCarry[request.resourceType] += amount;\r\n            // add a task to supply the target\r\n            supplyTasks.push(Tasks.transfer(request.target, request.resourceType, amount));\r\n        }\r\n        // Step 3: make withdraw tasks to get the needed resources\r\n        const withdrawTasks = [];\r\n        const neededResources = _.keys(queenCarry);\r\n        // TODO: a single structure doesn't need to have all resources; causes jam if labs need supply but no minerals\r\n        const targets = _.filter(this.storeStructures, s => _.all(neededResources, resource => (s.store[resource] || 0) >= (queenCarry[resource] || 0)));\r\n        const withdrawTarget = minBy(targets, target => Pathing.distance(queenPos, target.pos));\r\n        if (!withdrawTarget) {\r\n            log.warning(`Could not find adequate withdraw structure for ${queen.print}! ` +\r\n                `(neededResources: ${neededResources}, queenCarry: ${queenCarry})`);\r\n            return null;\r\n        }\r\n        for (const resourceType of neededResources) {\r\n            withdrawTasks.push(Tasks.withdraw(withdrawTarget, resourceType, queenCarry[resourceType]));\r\n        }\r\n        // Step 4: put all the tasks in the correct order, set nextPos for each, and chain them together\r\n        tasks = tasks.concat(withdrawTasks, supplyTasks);\r\n        return Tasks.chain(tasks);\r\n    }\r\n    // Builds a series of tasks to withdraw required resources from targets\r\n    buildWithdrawTaskManifest(queen) {\r\n        const tasks = [];\r\n        const transferTarget = this.colony.terminal || this.colony.storage || this.batteries[0];\r\n        // Step 1: empty all contents (this shouldn't be necessary since queen is normally empty at this point)\r\n        if (_.sum(queen.carry) > 0) {\r\n            if (transferTarget) {\r\n                tasks.push(Tasks.transferAll(transferTarget));\r\n            }\r\n            else {\r\n                log.warning(`No transfer targets for ${queen.print}!`);\r\n                return null;\r\n            }\r\n        }\r\n        // Step 2: figure out what you need to withdraw from\r\n        const queenCarry = { energy: 0 };\r\n        // let allWithdrawRequests = _.compact(_.flatten(_.map(this.assignments[queen.name],\r\n        // \t\t\t\t\t\t\t\t\t\t\t\t\tstruc => this.transportRequests.withdrawByID[struc.id])));\r\n        const withdrawRequests = [];\r\n        for (const priority in this.colony.transportRequests.withdraw) {\r\n            for (const request of this.colony.transportRequests.withdraw[priority]) {\r\n                if (this.assignments[queen.name][request.target.id]) {\r\n                    withdrawRequests.push(request);\r\n                }\r\n            }\r\n        }\r\n        for (const request of withdrawRequests) {\r\n            // stop when carry will be full\r\n            const remainingAmount = queen.carryCapacity - _.sum(queenCarry);\r\n            if (remainingAmount == 0)\r\n                break;\r\n            // figure out how much you can withdraw\r\n            const amount = Math.min(request.amount, remainingAmount);\r\n            if (amount == 0)\r\n                continue;\r\n            // update the simulated carry\r\n            if (!queenCarry[request.resourceType]) {\r\n                queenCarry[request.resourceType] = 0;\r\n            }\r\n            queenCarry[request.resourceType] += amount;\r\n            // add a task to supply the target\r\n            tasks.push(Tasks.withdraw(request.target, request.resourceType, amount));\r\n        }\r\n        // Step 3: put stuff in terminal/storage\r\n        if (transferTarget) {\r\n            tasks.push(Tasks.transferAll(transferTarget));\r\n        }\r\n        else {\r\n            log.warning(`No transfer targets for ${queen.print}!`);\r\n            return null;\r\n        }\r\n        // Step 4: return chained task manifest\r\n        return Tasks.chain(tasks);\r\n    }\r\n    // private getChargingSpot(queen: Zerg): RoomPosition {\r\n    // \tlet chargeSpots = _.map(bunkerChargingSpots, coord => getPosFromBunkerCoord(coord, this.colony));\r\n    // \tlet chargeSpot = (_.first(this.assignments[queen.name]) || queen).pos.findClosestByRange(chargeSpots);\r\n    // \tif (chargeSpot) {\r\n    // \t\treturn chargeSpot;\r\n    // \t} else {\r\n    // \t\tlog.warning(`Could not determine charging spot for queen at ${queen.pos.print}!`);\r\n    // \t\treturn queen.pos;\r\n    // \t}\r\n    // }\r\n    //\r\n    // private idleActions(queen: Zerg): void {\r\n    //\r\n    // \t// // Refill any empty batteries\r\n    // \t// for (let battery of this.batteries) {\r\n    // \t// \tif (!battery.isFull) {\r\n    // \t// \t\tlet amount = Math.min(battery.storeCapacity - _.sum(battery.store), queen.carryCapacity);\r\n    // \t// \t\tlet target = this.colony.storage || this.colony.storage;\r\n    // \t// \t\tif (target) {\r\n    // \t// \t\t\tqueen.task = Tasks.transfer(battery, RESOURCE_ENERGY, amount)\r\n    // \t// \t\t\t\t\t\t\t  .fork(Tasks.withdraw(target, RESOURCE_ENERGY, amount))\r\n    // \t// \t\t\treturn;\r\n    // \t// \t\t}\r\n    // \t// \t}\r\n    // \t// }\r\n    //\r\n    // \t// Go to recharging spot and get recharged\r\n    // \tlet chargingSpot = this.getChargingSpot(queen);\r\n    // \tqueen.goTo(chargingSpot, {range: 0});\r\n    // \t// // TODO: this will cause oscillating behavior where recharge drains some energy and queen leaves to supply it\r\n    // \t// if (queen.pos.getRangeTo(chargingSpot) == 0) {\r\n    // \t// \tlet chargingSpawn = _.first(queen.pos.findInRange(this.colony.spawns, 1));\r\n    // \t// \tif (chargingSpawn && !chargingSpawn.spawning) {\r\n    // \t// \t\tchargingSpawn.renewCreep(queen.creep);\r\n    // \t// \t}\r\n    // \t// }\r\n    // }\r\n    handleQueen(queen) {\r\n        // Does something need withdrawing?\r\n        if (this.colony.transportRequests.needsWithdrawing &&\r\n            _.any(_.keys(this.assignments[queen.name]), id => this.colony.transportRequests.withdrawByID[id])) {\r\n            queen.task = this.buildWithdrawTaskManifest(queen);\r\n        }\r\n        // Does something need supplying?\r\n        else if (this.colony.transportRequests.needsSupplying &&\r\n            _.any(_.keys(this.assignments[queen.name]), id => this.colony.transportRequests.supplyByID[id])) {\r\n            queen.task = this.buildSupplyTaskManifest(queen);\r\n        }\r\n        // Otherwise do idle actions\r\n        if (queen.isIdle) {\r\n            // this.idleActions(queen);\r\n            delete queen.memory._go;\r\n        }\r\n    }\r\n    run() {\r\n        this.autoRun(this.queens, queen => this.handleQueen(queen));\r\n    }\r\n};\r\nBunkerQueenOverlord = tslib_1.__decorate([\r\n    profile\r\n], BunkerQueenOverlord);\r\nexport { BunkerQueenOverlord };\r\n","references":["C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/creepSetups/CreepSetup.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/hiveClusters/hatchery.ts","C:/git/Overmind/src/logistics/TransportRequestGroup.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/roomPlanner/layouts/bunker.ts","C:/git/Overmind/src/tasks/Task.ts","C:/git/Overmind/src/tasks/Tasks.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/overlords/Overlord.ts"]}
