{"code":"// High-level planning for skirmishing and combats\r\nimport { log } from '../console/log';\r\nimport { DefenseDirective } from '../directives/defense/_DefenseDirective';\r\nimport { CombatIntel } from '../intel/CombatIntel';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { exponentialMovingAverage, getCacheExpiration } from '../utilities/utils';\r\nconst THREAT_EXPIRATION = 100;\r\nconst THREAT_DECAY_TIMESCALE = 100;\r\nconst SIEGE_ANALYSIS_EXPIRATION = 2500;\r\nconst defaultCombatPlannerMemory = {\r\n    threats: {},\r\n    profiles: {},\r\n    defenses: {},\r\n    sieges: {},\r\n    skirmishes: {},\r\n};\r\nexport class CombatPlanner {\r\n    constructor() {\r\n        _.defaults(this.memory, defaultCombatPlannerMemory);\r\n    }\r\n    get memory() {\r\n        return Memory.combatPlanner;\r\n    }\r\n    static computeHitsToSpawn(room) {\r\n        // TODO\r\n        return 0;\r\n    }\r\n    // private getNeededPotentials(): CombatPotentials {\r\n    // \t// TODO\r\n    // }\r\n    spawnNeededCreeps() {\r\n    }\r\n    assembleSquads() {\r\n        // Figure out the best thing for each creep to be doing\r\n        const idleCreeps = [];\r\n        for (const creep of this.creeps) {\r\n            if (!creep.overlord) {\r\n                idleCreeps.push(creep);\r\n            }\r\n            else {\r\n                const creepDirective = creep.overlord.directive;\r\n                if (creepDirective && creepDirective instanceof DefenseDirective) {\r\n                    if (this.memory.threats[creepDirective.ref]) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static getThreat(directive) {\r\n        if (directive.room) {\r\n            return {\r\n                directive: directive,\r\n                potentials: CombatIntel.getCombatPotentials(directive.room.hostiles),\r\n                roomName: directive.room.name,\r\n                closestColony: directive.colony.name,\r\n                distances: directive.overlord.spawnGroup.memory.distances,\r\n                lastSeen: {\r\n                    tick: Game.time,\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                directive: directive,\r\n                potentials: undefined,\r\n                roomName: directive.pos.roomName,\r\n                closestColony: directive.colony.name,\r\n                distances: directive.overlord.spawnGroup.memory.distances,\r\n                lastSeen: {\r\n                    tick: Game.time,\r\n                }\r\n            };\r\n        }\r\n    }\r\n    registerThreat(directive) {\r\n        const threat = CombatPlanner.getThreat(directive);\r\n        if (this.memory.threats[directive.ref]) {\r\n            // If a threat already exists, update it or allow potentials to decay\r\n            if (threat.potentials) { // you have vision\r\n                // If you have new info on threat potentials, update the log in memory\r\n                let attack, rangedAttack, heal;\r\n                const lastPotentials = this.memory.threats[directive.ref].potentials;\r\n                if (lastPotentials) {\r\n                    attack = lastPotentials.attack;\r\n                    rangedAttack = lastPotentials.rangedAttack;\r\n                    heal = lastPotentials.heal;\r\n                }\r\n                else {\r\n                    attack = 0;\r\n                    rangedAttack = 0;\r\n                    heal = 0;\r\n                }\r\n                const decayedAttack = exponentialMovingAverage(threat.potentials.attack, attack, THREAT_DECAY_TIMESCALE);\r\n                const decayedRangedAttack = exponentialMovingAverage(threat.potentials.rangedAttack, rangedAttack, THREAT_DECAY_TIMESCALE);\r\n                const decayedHeal = exponentialMovingAverage(threat.potentials.heal, heal, THREAT_DECAY_TIMESCALE);\r\n                // TODO: adjust decay for creeps known to have moved to next visible room\r\n                // Set new potential to maximum of current or decayed potential\r\n                const potentials = {\r\n                    attack: Math.max(threat.potentials.attack, decayedAttack),\r\n                    rangedAttack: Math.max(threat.potentials.rangedAttack, decayedRangedAttack),\r\n                    heal: Math.max(threat.potentials.heal, decayedHeal),\r\n                };\r\n                // Update the existing threat\r\n                this.memory.threats[directive.ref].potentials = potentials;\r\n                this.memory.threats[directive.ref].lastSeen.tick = Game.time;\r\n            }\r\n            else { // no vision\r\n            }\r\n        }\r\n        else {\r\n            // Register a new threat\r\n            this.memory.threats[directive.ref] = threat;\r\n        }\r\n    }\r\n    static getRoomLayout(room) {\r\n        let isBunker, isExposed, isInnerWall, isEdgeWall = false;\r\n        const exitPositions = Pathing.getExitPositions(room.name);\r\n        const terrain = Game.map.getRoomTerrain(room.name);\r\n        // Room is bunker if >80% of hostile structures are covered by ramparts\r\n        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);\r\n        const hostileStructuresInRampart = _.filter(hostileStructures, s => s.pos.lookForStructure(STRUCTURE_RAMPART));\r\n        isBunker = (hostileStructuresInRampart.length / hostileStructures.length >= 0.8);\r\n        // Room is edgewall if every exit tile has wall or barrier at 2 range to left/right/top/bottom\r\n        const walledOffExitTiles = _.filter(exitPositions, pos => {\r\n            let lookPos;\r\n            const x = pos.x;\r\n            const y = pos.y;\r\n            if (x == 0) {\r\n                lookPos = new RoomPosition(x + 2, y, room.name);\r\n            }\r\n            else if (x == 49) {\r\n                lookPos = new RoomPosition(x - 2, y, room.name);\r\n            }\r\n            else if (y == 0) {\r\n                lookPos = new RoomPosition(x, y + 2, room.name);\r\n            }\r\n            else if (y == 49) {\r\n                lookPos = new RoomPosition(x, y - 2, room.name);\r\n            }\r\n            else { // shouldn't ever get here\r\n                lookPos = pos;\r\n            }\r\n            if (terrain.get(lookPos.x, lookPos.y) == TERRAIN_MASK_WALL) {\r\n                return true;\r\n            }\r\n            else {\r\n                const rampart = lookPos.lookForStructure(STRUCTURE_RAMPART);\r\n                const wall = lookPos.lookForStructure(STRUCTURE_WALL);\r\n                return rampart != undefined || wall != undefined;\r\n            }\r\n        });\r\n        if (walledOffExitTiles.length == walledOffExitTiles.length) {\r\n            isEdgeWall = true;\r\n        }\r\n        // Room is inner wall if not bunker or edgewall and there is no path to spawn, otherwise exposed\r\n        if (!isBunker && !isEdgeWall) {\r\n            const entryPoints = _.compact([_.find(exitPositions, pos => pos.x == 0),\r\n                _.find(exitPositions, pos => pos.x == 49),\r\n                _.find(exitPositions, pos => pos.y == 0),\r\n                _.find(exitPositions, pos => pos.y == 49),\r\n            ]);\r\n            const target = (room.spawns[0] || room.towers[0]);\r\n            if (target) {\r\n                const obstacles = _.filter(room.structures, s => !s.isWalkable);\r\n                const isReachable = _.find(entryPoints, pos => Pathing.isReachable(pos, target.pos, obstacles));\r\n                if (isReachable) {\r\n                    isExposed = true;\r\n                }\r\n            }\r\n            if (!isExposed) {\r\n                isInnerWall = true;\r\n            }\r\n        }\r\n        if (isEdgeWall) {\r\n            return 'edgewall';\r\n        }\r\n        else if (isBunker) {\r\n            return 'bunker';\r\n        }\r\n        else if (isExposed) {\r\n            return 'exposed';\r\n        }\r\n        else if (isInnerWall) {\r\n            return 'innerwall';\r\n        }\r\n        else {\r\n            log.warning(`Inconclusive room layout for ${room.print}! Assuming inner wall.`);\r\n            return 'innerwall';\r\n        }\r\n    }\r\n    static getSiegeAnalysis(room) {\r\n        const owner = room.owner;\r\n        const level = room.controller ? room.controller.level : 0;\r\n        const towerDamageSamplePositions = _.map(_.range(20), i => new RoomPosition(_.random(1, 48), _.random(1, 48), room.name));\r\n        const maxTowerDamage = _.max(_.map(towerDamageSamplePositions, pos => CombatIntel.towerDamageAtPos(pos, true)));\r\n        const minBarrierHits = room.barriers.length > 0 ? _.min(_.map(room.barriers, b => b.hits)) : 0;\r\n        const avgBarrierHits = room.barriers.length > 0 ? _.sum(room.barriers, b => b.hits) / room.barriers.length : 0;\r\n        const numWalls = room.walls.length;\r\n        const numRamparts = room.ramparts.length;\r\n        const expiration = getCacheExpiration(SIEGE_ANALYSIS_EXPIRATION);\r\n        const roomLayout = this.getRoomLayout(room);\r\n        return {\r\n            owner,\r\n            level,\r\n            maxTowerDamage,\r\n            minBarrierHits,\r\n            avgBarrierHits,\r\n            numWalls,\r\n            numRamparts,\r\n            roomLayout,\r\n            expiration\r\n        };\r\n    }\r\n    registerSiegeAnalysis(room) {\r\n        if (!this.memory.sieges[room.name]) {\r\n            this.memory.sieges[room.name] = {};\r\n        }\r\n        if (!this.memory.sieges[room.name].analysis || Game.time > this.memory.sieges[room.name].analysis.expiration) {\r\n            this.memory.sieges[room.name].analysis = CombatPlanner.getSiegeAnalysis(room);\r\n        }\r\n    }\r\n    init() {\r\n        // Register new interactions in visible rooms\r\n        for (const roomName in Game.rooms) {\r\n            const room = Game.rooms[roomName];\r\n            // Make new siege analyses for rooms needing it\r\n            if (room.owner && !room.my) {\r\n                this.registerSiegeAnalysis(room);\r\n            }\r\n        }\r\n        for (const directive of this.directives) {\r\n            this.registerThreat(directive);\r\n        }\r\n    }\r\n    run() {\r\n    }\r\n    visuals() {\r\n    }\r\n}\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/directives/defense/_DefenseDirective.ts","C:/git/Overmind/src/intel/CombatIntel.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/overlords/CombatOverlord.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/zerg/CombatZerg.ts"]}
