{"code":"import * as tslib_1 from \"tslib\";\r\nimport { patternCost } from '../../creepSetups/CreepSetup';\r\nimport { CombatSetups, Roles } from '../../creepSetups/setups';\r\nimport { CombatIntel } from '../../intel/CombatIntel';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { CombatOverlord } from '../CombatOverlord';\r\n/**\r\n * General purpose skirmishing overlord for dealing with player combat in an outpost\r\n */\r\nlet OutpostDefenseOverlord = class OutpostDefenseOverlord extends CombatOverlord {\r\n    constructor(directive, priority = OverlordPriority.outpostDefense.outpostDefense) {\r\n        super(directive, 'outpostDefense', priority, 1);\r\n        this.spawnGroup.settings.flexibleEnergy = true;\r\n        this.broodlings = this.combatZerg(Roles.guardMelee);\r\n        this.hydralisks = this.combatZerg(Roles.ranged);\r\n        this.healers = this.combatZerg(Roles.healer);\r\n    }\r\n    handleCombat(zerg) {\r\n        if (this.room && this.room.hostiles.length == 0) {\r\n            zerg.doMedicActions(this.room.name);\r\n        }\r\n        else {\r\n            zerg.autoSkirmish(this.pos.roomName);\r\n        }\r\n    }\r\n    handleHealer(healer) {\r\n        if (CombatIntel.isHealer(healer) && healer.getActiveBodyparts(HEAL) == 0) {\r\n            if (this.colony.towers.length > 0) {\r\n                healer.goToRoom(this.colony.room.name); // go get healed\r\n            }\r\n            else {\r\n                healer.suicide(); // you're useless at this point // TODO: this isn't smart\r\n            }\r\n        }\r\n        else {\r\n            if (this.room && _.any([...this.broodlings, ...this.hydralisks], creep => creep.room == this.room)) {\r\n                this.handleCombat(healer); // go to room if there are any fighters in there\r\n            }\r\n            else {\r\n                healer.autoSkirmish(healer.room.name);\r\n            }\r\n        }\r\n    }\r\n    computeNeededHydraliskAmount(setup, enemyRangedPotential) {\r\n        const hydraliskPotential = setup.getBodyPotential(RANGED_ATTACK, this.colony);\r\n        // TODO: body potential from spawnGroup energy?\r\n        // let worstDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(this.room.hostiles);\r\n        return Math.ceil(1.5 * enemyRangedPotential / hydraliskPotential);\r\n    }\r\n    // TODO: division by 0 error!\r\n    computeNeededBroodlingAmount(setup, enemyAttackPotential) {\r\n        const broodlingPotential = setup.getBodyPotential(ATTACK, this.colony);\r\n        // let worstDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(this.room.hostiles);\r\n        return Math.ceil(1.5 * enemyAttackPotential / broodlingPotential);\r\n    }\r\n    computeNeededHealerAmount(setup, enemyHealPotential) {\r\n        const healerPotential = setup.getBodyPotential(HEAL, this.colony);\r\n        return Math.ceil(1.5 * enemyHealPotential / healerPotential);\r\n    }\r\n    getEnemyPotentials() {\r\n        if (this.room) {\r\n            return CombatIntel.getCombatPotentials(this.room.hostiles);\r\n        }\r\n        else {\r\n            return { attack: 1, rangedAttack: 0, heal: 0, };\r\n        }\r\n    }\r\n    init() {\r\n        const maxCost = Math.max(patternCost(CombatSetups.hydralisks.default), patternCost(CombatSetups.broodlings.default));\r\n        const mode = this.colony.room.energyCapacityAvailable >= maxCost ? 'NORMAL' : 'EARLY';\r\n        const { attack, rangedAttack, heal } = this.getEnemyPotentials();\r\n        const hydraliskSetup = mode == 'NORMAL' ? CombatSetups.hydralisks.default : CombatSetups.hydralisks.early;\r\n        const hydraliskAmount = this.computeNeededHydraliskAmount(hydraliskSetup, rangedAttack);\r\n        this.wishlist(hydraliskAmount, hydraliskSetup, { priority: this.priority - .2, reassignIdle: true });\r\n        const broodlingSetup = mode == 'NORMAL' ? CombatSetups.broodlings.default : CombatSetups.broodlings.early;\r\n        const broodlingAmount = this.computeNeededBroodlingAmount(broodlingSetup, attack);\r\n        this.wishlist(broodlingAmount, broodlingSetup, { priority: this.priority - .1, reassignIdle: true });\r\n        const enemyHealers = _.filter(this.room ? this.room.hostiles : [], creep => CombatIntel.isHealer(creep)).length;\r\n        let healerAmount = (enemyHealers > 0 || mode == 'EARLY') ?\r\n            this.computeNeededHealerAmount(CombatSetups.healers.default, heal) : 0;\r\n        if (mode == 'EARLY' && attack + rangedAttack > 0) {\r\n            healerAmount = Math.max(healerAmount, 1);\r\n        }\r\n        this.wishlist(healerAmount, CombatSetups.healers.default, { priority: this.priority, reassignIdle: true });\r\n    }\r\n    run() {\r\n        this.autoRun(this.broodlings, broodling => this.handleCombat(broodling));\r\n        this.autoRun(this.hydralisks, mutalisk => this.handleCombat(mutalisk));\r\n        this.autoRun(this.healers, healer => this.handleHealer(healer));\r\n    }\r\n};\r\nOutpostDefenseOverlord = tslib_1.__decorate([\r\n    profile\r\n], OutpostDefenseOverlord);\r\nexport { OutpostDefenseOverlord };\r\n","references":["C:/git/Overmind/src/creepSetups/CreepSetup.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/directives/defense/outpostDefense.ts","C:/git/Overmind/src/intel/CombatIntel.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/zerg/CombatZerg.ts","C:/git/Overmind/src/overlords/CombatOverlord.ts"]}
