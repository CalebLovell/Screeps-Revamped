{"code":"import * as tslib_1 from \"tslib\";\r\nimport { profile } from '../profiler/decorator';\r\nimport { TaskAttack } from './instances/attack';\r\nimport { TaskBuild } from './instances/build';\r\nimport { TaskClaim } from './instances/claim';\r\nimport { TaskDismantle } from './instances/dismantle';\r\nimport { TaskDrop } from './instances/drop';\r\n// import {fleeTargetType, TaskFlee} from './instances/flee';\r\nimport { TaskFortify } from './instances/fortify';\r\nimport { TaskGetBoosted } from './instances/getBoosted';\r\nimport { TaskGetRenewed } from './instances/getRenewed';\r\nimport { TaskGoToRoom } from './instances/goToRoom';\r\nimport { TaskHarvest } from './instances/harvest';\r\nimport { TaskHeal } from './instances/heal';\r\nimport { TaskMeleeAttack } from './instances/meleeAttack';\r\nimport { TaskPickup } from './instances/pickup';\r\nimport { TaskRangedAttack } from './instances/rangedAttack';\r\nimport { TaskRecharge } from './instances/recharge';\r\nimport { TaskRepair } from './instances/repair';\r\nimport { TaskReserve } from './instances/reserve';\r\nimport { TaskSignController } from './instances/signController';\r\nimport { TaskTransfer } from './instances/transfer';\r\nimport { TaskTransferAll } from './instances/transferAll';\r\nimport { TaskUpgrade } from './instances/upgrade';\r\nimport { TaskWithdraw } from './instances/withdraw';\r\nimport { TaskWithdrawAll } from './instances/withdrawAll';\r\n/**\r\n * Tasks class provides conveient wrappers for dispensing new Task instances\r\n */\r\nlet Tasks = class Tasks {\r\n    static chain(tasks, setNextPos = true) {\r\n        if (tasks.length == 0) {\r\n            // log.error(`Tasks.chain was passed an empty array of tasks!`);\r\n            return null;\r\n        }\r\n        if (setNextPos) {\r\n            for (let i = 0; i < tasks.length - 1; i++) {\r\n                tasks[i].options.nextPos = tasks[i + 1].targetPos;\r\n            }\r\n        }\r\n        // Make the accumulator task from the end and iteratively fork it\r\n        let task = _.last(tasks); // start with last task\r\n        tasks = _.dropRight(tasks); // remove it from the list\r\n        for (let i = (tasks.length - 1); i >= 0; i--) { // iterate over the remaining tasks\r\n            task = task.fork(tasks[i]);\r\n        }\r\n        return task;\r\n    }\r\n    static attack(target, options = {}) {\r\n        return new TaskAttack(target, options);\r\n    }\r\n    static build(target, options = {}) {\r\n        return new TaskBuild(target, options);\r\n    }\r\n    static claim(target, options = {}) {\r\n        return new TaskClaim(target, options);\r\n    }\r\n    static dismantle(target, options = {}) {\r\n        return new TaskDismantle(target, options);\r\n    }\r\n    static drop(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {\r\n        return new TaskDrop(target, resourceType, amount, options);\r\n    }\r\n    // static flee(target: fleeTargetType, options = {} as TaskOptions) {\r\n    // \treturn new TaskFlee(target, options);\r\n    // }\r\n    static fortify(target, options = {}) {\r\n        return new TaskFortify(target, options);\r\n    }\r\n    static getBoosted(target, boostType, amount, options = {}) {\r\n        return new TaskGetBoosted(target, boostType, amount, options);\r\n    }\r\n    static getRenewed(target, options = {}) {\r\n        return new TaskGetRenewed(target, options);\r\n    }\r\n    static goToRoom(target, options = {}) {\r\n        return new TaskGoToRoom(target, options);\r\n    }\r\n    static harvest(target, options = {}) {\r\n        return new TaskHarvest(target, options);\r\n    }\r\n    static heal(target, options = {}) {\r\n        return new TaskHeal(target, options);\r\n    }\r\n    static meleeAttack(target, options = {}) {\r\n        return new TaskMeleeAttack(target, options);\r\n    }\r\n    static pickup(target, options = {}) {\r\n        return new TaskPickup(target, options);\r\n    }\r\n    static rangedAttack(target, options = {}) {\r\n        return new TaskRangedAttack(target, options);\r\n    }\r\n    static recharge(minEnergy = 0, options = {}) {\r\n        return new TaskRecharge(null, minEnergy, options);\r\n    }\r\n    static repair(target, options = {}) {\r\n        return new TaskRepair(target, options);\r\n    }\r\n    static reserve(target, options = {}) {\r\n        return new TaskReserve(target, options);\r\n    }\r\n    static signController(target, options = {}) {\r\n        return new TaskSignController(target, options);\r\n    }\r\n    static transfer(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {\r\n        return new TaskTransfer(target, resourceType, amount, options);\r\n    }\r\n    static transferAll(target, skipEnergy = false, options = {}) {\r\n        return new TaskTransferAll(target, skipEnergy, options);\r\n    }\r\n    static upgrade(target, options = {}) {\r\n        return new TaskUpgrade(target, options);\r\n    }\r\n    static withdraw(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {\r\n        return new TaskWithdraw(target, resourceType, amount, options);\r\n    }\r\n    static withdrawAll(target, options = {}) {\r\n        return new TaskWithdrawAll(target, options);\r\n    }\r\n};\r\nTasks = tslib_1.__decorate([\r\n    profile\r\n], Tasks);\r\nexport { Tasks };\r\n","references":["C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/tasks/instances/attack.ts","C:/git/Overmind/src/tasks/instances/build.ts","C:/git/Overmind/src/tasks/instances/claim.ts","C:/git/Overmind/src/tasks/instances/dismantle.ts","C:/git/Overmind/src/tasks/instances/drop.ts","C:/git/Overmind/src/tasks/instances/fortify.ts","C:/git/Overmind/src/tasks/instances/getBoosted.ts","C:/git/Overmind/src/tasks/instances/getRenewed.ts","C:/git/Overmind/src/tasks/instances/goToRoom.ts","C:/git/Overmind/src/tasks/instances/harvest.ts","C:/git/Overmind/src/tasks/instances/heal.ts","C:/git/Overmind/src/tasks/instances/meleeAttack.ts","C:/git/Overmind/src/tasks/instances/pickup.ts","C:/git/Overmind/src/tasks/instances/rangedAttack.ts","C:/git/Overmind/src/tasks/instances/recharge.ts","C:/git/Overmind/src/tasks/instances/repair.ts","C:/git/Overmind/src/tasks/instances/reserve.ts","C:/git/Overmind/src/tasks/instances/signController.ts","C:/git/Overmind/src/tasks/instances/transfer.ts","C:/git/Overmind/src/tasks/instances/transferAll.ts","C:/git/Overmind/src/tasks/instances/upgrade.ts","C:/git/Overmind/src/tasks/instances/withdraw.ts","C:/git/Overmind/src/tasks/instances/withdrawAll.ts","C:/git/Overmind/src/tasks/Task.ts"]}
