{"code":"import * as tslib_1 from \"tslib\";\r\nvar Movement_1;\r\nimport { log } from '../console/log';\r\nimport { Roles } from '../creepSetups/setups';\r\nimport { isZerg } from '../declarations/typeGuards';\r\nimport { profile } from '../profiler/decorator';\r\nimport { insideBunkerBounds } from '../roomPlanner/layouts/bunker';\r\nimport { rightArrow } from '../utilities/stringConstants';\r\nimport { getPosFromString } from '../utilities/utils';\r\nimport { Visualizer } from '../visuals/Visualizer';\r\nimport { normalizeZerg } from '../zerg/Zerg';\r\nimport { getTerrainCosts, isExit, normalizePos, sameCoord } from './helpers';\r\nimport { Pathing } from './Pathing';\r\nexport const NO_ACTION = -20;\r\nexport const CROSSING_PORTAL = -21;\r\nexport const ERR_CANNOT_PUSH_CREEP = -30;\r\nconst REPORT_CPU_THRESHOLD = 1000; // Report when creep uses more than this amount of CPU over lifetime\r\nconst REPORT_SWARM_CPU_THRESHOLD = 1500;\r\nconst DEFAULT_STUCK_VALUE = 2; // Marked as stuck after this many ticks\r\nconst STATE_PREV_X = 0;\r\nconst STATE_PREV_Y = 1;\r\nconst STATE_STUCK = 2;\r\nconst STATE_CPU = 3;\r\nconst STATE_DEST_X = 4;\r\nconst STATE_DEST_Y = 5;\r\nconst STATE_DEST_ROOMNAME = 6;\r\nconst STATE_CURRENT_X = 7;\r\nconst STATE_CURRENT_Y = 8;\r\nexport const MovePriorities = {\r\n    [Roles.manager]: 1,\r\n    [Roles.queen]: 2,\r\n    [Roles.bunkerGuard]: 3,\r\n    [Roles.melee]: 3,\r\n    [Roles.ranged]: 4,\r\n    [Roles.guardMelee]: 5,\r\n    // [Roles.ranged]: 6,\r\n    [Roles.transport]: 8,\r\n    [Roles.worker]: 9,\r\n    default: 10,\r\n};\r\n/**\r\n * This is the movement library for Overmind. It was originally based on BonzAI's Traveler library, but it has been\r\n * extensively modified to integrate more tightly with the Overmind framework and add additional functionality.\r\n */\r\nlet Movement = Movement_1 = class Movement {\r\n    // Core creep movement functions ===================================================================================\r\n    /**\r\n     * Move a creep to a destination\r\n     */\r\n    static goTo(creep, destination, options = {}) {\r\n        if (creep.blockMovement && !options.force) {\r\n            return ERR_BUSY;\r\n        }\r\n        if (creep.spawning) {\r\n            return NO_ACTION;\r\n        }\r\n        if (creep.fatigue > 0) {\r\n            Movement_1.circle(creep.pos, 'aqua', .3);\r\n            return ERR_TIRED;\r\n        }\r\n        // Set default options\r\n        _.defaults(options, {\r\n            ignoreCreeps: true,\r\n            repathOnceVisible: !!options.waypoints || !!options.avoidSK,\r\n        });\r\n        // initialize data object\r\n        if (!creep.memory._go) {\r\n            creep.memory._go = {};\r\n        }\r\n        const moveData = creep.memory._go;\r\n        // set destination according to waypoint specifications; finalDestination is the true destination\r\n        destination = normalizePos(destination);\r\n        const finalDestination = destination;\r\n        if (options.waypoints) {\r\n            destination = this.getDestination(destination, options.waypoints, moveData);\r\n        }\r\n        Pathing.updateRoomStatus(creep.room);\r\n        // Fixes bug that causes creeps to idle on the other side of a room\r\n        if (options.range != undefined && destination.rangeToEdge <= options.range) {\r\n            options.range = Math.min(Math.abs(destination.rangeToEdge - 1), 0);\r\n        }\r\n        // manage case where creep is nearby destination\r\n        const rangeToDestination = creep.pos.getRangeTo(destination);\r\n        if (options.range != undefined && rangeToDestination <= options.range) {\r\n            if (destination.isEqualTo(finalDestination)) {\r\n                delete creep.memory._go;\r\n                return NO_ACTION;\r\n            }\r\n            else {\r\n                // debug\r\n                console.log(`Destination ${destination} not equal to final destination ${finalDestination}!`);\r\n                if (!moveData.waypointsVisited) {\r\n                    moveData.waypointsVisited = [];\r\n                }\r\n                moveData.waypointsVisited.push(destination.name);\r\n                // call goTo again to path to the final destination\r\n                return this.goTo(creep, finalDestination, options);\r\n            }\r\n        }\r\n        else if (rangeToDestination <= 1) {\r\n            // move onto destination\r\n            if (rangeToDestination == 1 && !options.range) {\r\n                const direction = creep.pos.getDirectionTo(destination);\r\n                if (destination.isWalkable(options.ignoreCreepsOnDestination)) {\r\n                    return creep.move(direction, !!options.force);\r\n                }\r\n            }\r\n            else { // at destination\r\n                if (!moveData.fleeWait) {\r\n                    delete creep.memory._go;\r\n                }\r\n                return NO_ACTION;\r\n            }\r\n        }\r\n        // traverse through a portal waypoint or check that has just been traversed\r\n        if (options.waypoints && !destination.isEqualTo(finalDestination)) {\r\n            const portalTraversed = this.traversePortalWaypoint(creep, destination);\r\n            if (portalTraversed) {\r\n                return this.goTo(creep, finalDestination, options);\r\n            }\r\n            else {\r\n                return CROSSING_PORTAL;\r\n            }\r\n        }\r\n        // handle delay\r\n        if (moveData.delay != undefined) {\r\n            if (moveData.delay <= 0) {\r\n                delete moveData.delay;\r\n            }\r\n            else {\r\n                moveData.delay--;\r\n                return OK;\r\n            }\r\n        }\r\n        const state = this.deserializeState(moveData, destination);\r\n        // // verify creep is in the location it thinks it should be in\r\n        // if (state.currentXY) {\r\n        // \tlet {x, y} = state.currentXY;\r\n        // \tif (!(creep.pos.x == x && creep.pos.y == y)) { // creep thought it would move last tick but didn't\r\n        // \t\tlog.debug(`${creep.print} has gotten off track; deleting path!`);\r\n        // \t\tdelete moveData.path;\r\n        // \t}\r\n        // }\r\n        // uncomment to visualize destination\r\n        // this.circle(destination, \"orange\");\r\n        // check if creep is stuck\r\n        if (this.isStuck(creep, state)) {\r\n            state.stuckCount++;\r\n            this.circle(creep.pos, 'magenta', state.stuckCount * .3);\r\n            // pushedCreep = this.pushCreep(creep);\r\n        }\r\n        else {\r\n            state.stuckCount = 0;\r\n        }\r\n        // handle case where creep is stuck\r\n        if (!options.stuckValue) {\r\n            options.stuckValue = DEFAULT_STUCK_VALUE;\r\n        }\r\n        if (state.stuckCount >= options.stuckValue && Math.random() > .5) {\r\n            options.ignoreCreeps = false;\r\n            delete moveData.path;\r\n        }\r\n        // delete path cache if destination is different\r\n        if (!destination.isEqualTo(state.destination)) {\r\n            if (options.movingTarget && state.destination.isNearTo(destination)) {\r\n                moveData.path += state.destination.getDirectionTo(destination);\r\n                state.destination = destination;\r\n            }\r\n            else {\r\n                delete moveData.path;\r\n            }\r\n        }\r\n        // randomly repath with specified probability\r\n        if (options.repath && Math.random() < options.repath) {\r\n            delete moveData.path;\r\n        }\r\n        // repath if there was no vision for this room when pathfinding was run\r\n        if (options.repathOnceVisible && !(moveData.roomVisibility || {})[creep.room.name]) {\r\n            delete moveData.path;\r\n        }\r\n        // TODO: repath if you are not on expected next position\r\n        // pathfinding\r\n        let newPath = false;\r\n        if (!moveData.path || moveData.path.length == 0) {\r\n            newPath = true;\r\n            if (creep.spawning) {\r\n                return ERR_BUSY;\r\n            }\r\n            state.destination = destination;\r\n            // Compute terrain costs\r\n            if (!options.direct && !options.terrainCosts) {\r\n                options.terrainCosts = getTerrainCosts(creep.creep);\r\n            }\r\n            const cpu = Game.cpu.getUsed();\r\n            // (!) Pathfinding is done here\r\n            const ret = Pathing.findPath(creep.pos, destination, options);\r\n            const cpuUsed = Game.cpu.getUsed() - cpu;\r\n            state.cpu = _.round(cpuUsed + state.cpu);\r\n            if (Game.time % 10 == 0 && state.cpu > REPORT_CPU_THRESHOLD) {\r\n                log.alert(`Movement: heavy cpu use: ${creep.name}, cpu: ${state.cpu}. ` +\r\n                    `(${creep.pos.print} ${rightArrow} ${destination.print})`);\r\n            }\r\n            let color = 'orange';\r\n            if (ret.incomplete) {\r\n                // uncommenting this is a great way to diagnose creep behavior issues\r\n                log.debug(`Movement: incomplete path for ${creep.print}! ` +\r\n                    `(${creep.pos.print} ${rightArrow} ${destination.print})`);\r\n                color = 'red';\r\n            }\r\n            this.circle(creep.pos, color);\r\n            moveData.path = Pathing.serializePath(creep.pos, ret.path, color);\r\n            const roomsVisited = _.unique(_.map(ret.path, pos => pos.roomName));\r\n            if (!moveData.roomVisibility) {\r\n                moveData.roomVisibility = {};\r\n            }\r\n            for (const roomName of roomsVisited) {\r\n                moveData.roomVisibility[roomName] = !!Game.rooms[roomName];\r\n            }\r\n            state.stuckCount = 0;\r\n        }\r\n        if (!moveData.path || moveData.path.length == 0) {\r\n            this.serializeState(creep, destination, state, moveData);\r\n            return ERR_NO_PATH;\r\n        }\r\n        // push creeps out of the way if needed\r\n        if (!options.noPush) {\r\n            const obstructingCreep = this.findBlockingCreep(creep);\r\n            if (obstructingCreep && this.shouldPush(creep, obstructingCreep)) {\r\n                const pushedCreep = this.pushCreep(creep, obstructingCreep);\r\n                if (!pushedCreep) {\r\n                    this.serializeState(creep, destination, state, moveData);\r\n                    return ERR_CANNOT_PUSH_CREEP;\r\n                }\r\n            }\r\n        }\r\n        // consume path\r\n        if (state.stuckCount == 0 && !newPath) {\r\n            moveData.path = moveData.path.substr(1);\r\n        }\r\n        const nextDirection = parseInt(moveData.path[0], 10);\r\n        // predict next coordinate (for verification)\r\n        const nextPos = creep.pos.getPositionAtDirection(nextDirection);\r\n        this.serializeState(creep, destination, state, moveData, { x: nextPos.x, y: nextPos.y });\r\n        return creep.move(nextDirection, !!options.force);\r\n    }\r\n    /**\r\n     * Gets the effective destination based on the waypoints to travel over and the creep.memory._go object.\r\n     * Finds the next waypoint which has not been marked as visited in moveData.\r\n     */\r\n    static getDestination(destination, waypoints, moveData) {\r\n        const waypointsVisited = _.compact(_.map(moveData.waypointsVisited || [], posName => getPosFromString(posName)));\r\n        const nextWaypoint = _.find(waypoints, waypoint => !_.any(waypointsVisited, visited => waypoint.isEqualTo(visited)));\r\n        if (nextWaypoint) {\r\n            return nextWaypoint;\r\n        }\r\n        else {\r\n            return destination;\r\n        }\r\n    }\r\n    /**\r\n     * Navigate a creep through a portal\r\n     */\r\n    static traversePortalWaypoint(creep, portalPos) {\r\n        if (creep.pos.roomName == portalPos.roomName && creep.pos.getRangeTo(portalPos) > 1) {\r\n            log.error(`Movement.travelPortalWaypoint() should only be called in range 1 of portal!`);\r\n        }\r\n        const moveData = creep.memory._go || {};\r\n        if (portalPos.room && !portalPos.lookForStructure(STRUCTURE_PORTAL)) {\r\n            log.error(`Portal not found at ${portalPos.print}!`);\r\n            return false;\r\n        }\r\n        moveData.portaling = true;\r\n        const crossed = this.crossPortal(creep, portalPos);\r\n        if (crossed) {\r\n            moveData.portaling = false;\r\n            if (!moveData.waypointsVisited) {\r\n                moveData.waypointsVisited = [];\r\n            }\r\n            moveData.waypointsVisited.push(portalPos.name);\r\n            return true; // done crossing portal\r\n        }\r\n        else {\r\n            return false; // still trying to cross portal\r\n        }\r\n    }\r\n    /**\r\n     * Cross a portal that is within range 1 and then step off of the exit portal. Returns true when creep is on the\r\n     * other side of the portal and no longer standing on a portal.\r\n     */\r\n    static crossPortal(creep, portalPos) {\r\n        if (Game.map.getRoomLinearDistance(creep.pos.roomName, portalPos.roomName) > 5) {\r\n            // if you're on the other side of the portal\r\n            const creepOnPortal = !!creep.pos.lookForStructure(STRUCTURE_PORTAL);\r\n            if (!creepOnPortal) {\r\n                return true;\r\n            }\r\n            else {\r\n                creep.moveOffCurrentPos();\r\n                return false;\r\n            }\r\n            // console.log(agent.name + \" waiting on other side\");\r\n        }\r\n        else {\r\n            if (creep.pos.getRangeTo(portalPos) > 1) {\r\n                log.error(`Movement.crossPortal() should only be called in range 1 of portal!`);\r\n            }\r\n            else {\r\n                const dir = creep.pos.getDirectionTo(portalPos);\r\n                creep.move(dir);\r\n            }\r\n            // console.log(agent.name + \" traveling to waypoint\");\r\n            return false;\r\n        }\r\n    }\r\n    static getPushPriority(creep) {\r\n        if (!creep.memory)\r\n            return MovePriorities.default;\r\n        if (creep.memory._go && creep.memory._go.priority) {\r\n            return creep.memory._go.priority;\r\n        }\r\n        else {\r\n            return MovePriorities[creep.memory.role] || MovePriorities.default;\r\n        }\r\n    }\r\n    static shouldPush(pusher, pushee) {\r\n        if (this.getPushPriority(pusher) < this.getPushPriority(pushee)) {\r\n            // pushee less important than pusher\r\n            return true;\r\n        }\r\n        else {\r\n            pushee = normalizeZerg(pushee);\r\n            if (isZerg(pushee)) {\r\n                // pushee is equal or more important than pusher\r\n                if (pushee.task && pushee.task.isWorking) {\r\n                    // If creep is doing a task, only push out of way if it can go somewhere else in range\r\n                    const targetPos = pushee.task.targetPos;\r\n                    const targetRange = pushee.task.settings.targetRange;\r\n                    return _.filter(pushee.pos.availableNeighbors().concat(pusher.pos), pos => pos.getRangeTo(targetPos) <= targetRange).length > 0;\r\n                }\r\n                else if (!pushee.isMoving) {\r\n                    // push creeps out of the way if they're idling\r\n                    return true;\r\n                }\r\n            }\r\n            else {\r\n                return pushee.my;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    static getPushDirection(pusher, pushee) {\r\n        const possiblePositions = pushee.pos.availableNeighbors();\r\n        pushee = normalizeZerg(pushee);\r\n        if (isZerg(pushee)) {\r\n            let preferredPositions = [];\r\n            if (pushee.task && pushee.task.isWorking) { // push creeps out of the way when they're doing task\r\n                const targetPos = pushee.task.targetPos;\r\n                const targetRange = pushee.task.settings.targetRange;\r\n                preferredPositions = _.filter(possiblePositions, pos => pos.getRangeTo(targetPos) <= targetRange);\r\n            }\r\n            if (preferredPositions[0]) {\r\n                return pushee.pos.getDirectionTo(preferredPositions[0]);\r\n            }\r\n        }\r\n        else {\r\n            log.debug(`${pushee.name}@${pushee.pos.print} is not Zerg! (Why?)`);\r\n        }\r\n        return pushee.pos.getDirectionTo(pusher);\r\n    }\r\n    static findBlockingCreep(creep) {\r\n        const nextDir = Pathing.nextDirectionInPath(creep);\r\n        if (nextDir == undefined)\r\n            return;\r\n        const nextPos = Pathing.positionAtDirection(creep.pos, nextDir);\r\n        if (!nextPos)\r\n            return;\r\n        return nextPos.lookFor(LOOK_CREEPS)[0];\r\n    }\r\n    /* Push a blocking creep out of the way */\r\n    static pushCreep(creep, otherCreep) {\r\n        if (!otherCreep.memory)\r\n            return false;\r\n        otherCreep = normalizeZerg(otherCreep);\r\n        const pushDirection = this.getPushDirection(creep, otherCreep);\r\n        const otherData = otherCreep.memory._go;\r\n        // Push the creep and update the state\r\n        const outcome = otherCreep.move(pushDirection);\r\n        const otherNextPos = otherCreep.pos.getPositionAtDirection(pushDirection);\r\n        if (isZerg(otherCreep)) {\r\n            if (outcome == OK) {\r\n                if (otherData && otherData.path && !otherCreep.blockMovement) { // don't add to path unless you moved\r\n                    otherData.path = Pathing.oppositeDirection(pushDirection) + otherData.path;\r\n                    this.updateStateNextCoord(otherData, otherNextPos);\r\n                }\r\n                otherCreep.blockMovement = true;\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            // Shouldn't reach here ideally\r\n            log.debug(`${otherCreep.name}@${otherCreep.pos.print} is not Zerg! (Why?)`);\r\n            if (outcome == OK) {\r\n                if (otherData && otherData.path) {\r\n                    otherData.path = Pathing.oppositeDirection(pushDirection) + otherData.path;\r\n                    this.updateStateNextCoord(otherData, otherNextPos);\r\n                }\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    // TODO: this is bugged somewhere\r\n    /**\r\n     * Recursively moves creeps out of the way of a position to make room for something, such as a spawning creep.\r\n     * If suicide is specified and there is no series of move commands that can move a block of creeps out of the way,\r\n     * the lead blocking creep will suicide. Returns whether the position has been vacated.\r\n     */\r\n    static vacatePos(pos, suicide = false) {\r\n        // prevent creeps from moving onto pos\r\n        const nearbyCreeps = _.compact(_.map(pos.findInRange(FIND_MY_CREEPS, 2), creep => Overmind.zerg[creep.name]));\r\n        _.forEach(nearbyCreeps, creep => creep.blockMovement = true);\r\n        // recurively move creeps off of the position\r\n        const creep = pos.lookFor(LOOK_CREEPS)[0];\r\n        if (!creep)\r\n            return true;\r\n        const blockingCreep = Overmind.zerg[creep.name];\r\n        if (!blockingCreep)\r\n            return true;\r\n        const moved = !!this.recursivePush(blockingCreep);\r\n        if (moved) {\r\n            log.debug(`Moved creep ${blockingCreep.name} off of ${blockingCreep.pos.print}.`);\r\n            return true;\r\n        }\r\n        else {\r\n            if (suicide) {\r\n                log.debug(`Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}! ` +\r\n                    `Suiciding creep! (RIP)`);\r\n                blockingCreep.suicide();\r\n                return true;\r\n            }\r\n            else {\r\n                log.debug(`Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}!`);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Recursively pushes creeps out of the way of a root position.\r\n     */\r\n    static recursivePush(creep, excludePos = []) {\r\n        const creepPos = creep.pos;\r\n        let movePos = _.find(creepPos.availableNeighbors(), neighbor => !_.any(excludePos, pos => pos.isEqualTo(neighbor)));\r\n        if (movePos) {\r\n            log.debug(`Moving ${creep.name} to ${JSON.stringify(movePos)}`);\r\n            this.goTo(creep, movePos, { force: true });\r\n            creep.blockMovement = true;\r\n            return creepPos;\r\n        }\r\n        else { // Every position is occupied by a creep\r\n            const availablePositions = _.filter(creepPos.availableNeighbors(true), neighbor => !_.any(excludePos, pos => pos.isEqualTo(neighbor)));\r\n            for (const otherPos of availablePositions) {\r\n                const otherCreep = otherPos.lookFor(LOOK_CREEPS)[0];\r\n                if (!otherCreep)\r\n                    continue;\r\n                const otherZerg = Overmind.zerg[otherCreep.name];\r\n                if (!otherZerg)\r\n                    continue;\r\n                movePos = this.recursivePush(otherZerg, excludePos.concat(creepPos));\r\n                if (movePos) {\r\n                    this.goTo(creep, movePos, { range: 0, force: true });\r\n                    creep.blockMovement = true;\r\n                    return creepPos;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Travel to a room\r\n     */\r\n    static goToRoom(creep, roomName, options = {}) {\r\n        options.range = 23;\r\n        return this.goTo(creep, new RoomPosition(25, 25, roomName), options);\r\n    }\r\n    /**\r\n     * Travel to a room\r\n     */\r\n    static goToRoom_swarm(swarm, roomName, options = {}) {\r\n        options.range = 24 - Math.max(swarm.width, swarm.height);\r\n        return this.swarmMove(swarm, new RoomPosition(25, 25, roomName), options);\r\n    }\r\n    /**\r\n     * Park a creep off-roads\r\n     */\r\n    static park(creep, pos = creep.pos, maintainDistance = false) {\r\n        const road = creep.pos.lookForStructure(STRUCTURE_ROAD);\r\n        if (!road)\r\n            return OK;\r\n        // Move out of the bunker if you're in it\r\n        if (!maintainDistance && creep.colony && creep.colony.bunker && insideBunkerBounds(creep.pos, creep.colony)) {\r\n            return this.goTo(creep, creep.colony.controller.pos);\r\n        }\r\n        let positions = _.sortBy(creep.pos.availableNeighbors(), p => p.getRangeTo(pos));\r\n        if (maintainDistance) {\r\n            const currentRange = creep.pos.getRangeTo(pos);\r\n            positions = _.filter(positions, p => p.getRangeTo(pos) <= currentRange);\r\n        }\r\n        let swampPosition;\r\n        for (const position of positions) {\r\n            if (position.lookForStructure(STRUCTURE_ROAD))\r\n                continue;\r\n            const terrain = position.lookFor(LOOK_TERRAIN)[0];\r\n            if (terrain === 'swamp') {\r\n                swampPosition = position;\r\n            }\r\n            else {\r\n                return creep.move(creep.pos.getDirectionTo(position));\r\n            }\r\n        }\r\n        if (swampPosition) {\r\n            return creep.move(creep.pos.getDirectionTo(swampPosition));\r\n        }\r\n        return this.goTo(creep, pos);\r\n    }\r\n    /**\r\n     * Moves a creep off of the current tile to the first available neighbor\r\n     */\r\n    static moveOffCurrentPos(creep) {\r\n        const destinationPos = _.first(creep.pos.availableNeighbors());\r\n        if (destinationPos) {\r\n            const direction = creep.pos.getDirectionTo(destinationPos);\r\n            return creep.move(direction);\r\n        }\r\n        else {\r\n            log.debug(`${creep.print} can't move off current pos!`);\r\n        }\r\n    }\r\n    /**\r\n     * Moves onto an exit tile\r\n     */\r\n    static moveOnExit(creep) {\r\n        if (creep.pos.rangeToEdge > 0 && creep.fatigue == 0) {\r\n            const directions = [1, 3, 5, 7, 2, 4, 6, 8];\r\n            for (const direction of directions) {\r\n                const position = creep.pos.getPositionAtDirection(direction);\r\n                const terrain = position.lookFor(LOOK_TERRAIN)[0];\r\n                if (terrain != 'wall' && position.rangeToEdge == 0) {\r\n                    const outcome = creep.move(direction);\r\n                    return outcome;\r\n                }\r\n            }\r\n            log.warning(`moveOnExit() assumes nearby exit tile, position: ${creep.pos}`);\r\n            return ERR_NO_PATH;\r\n        }\r\n    }\r\n    /**\r\n     * Moves off of an exit tile\r\n     */\r\n    static moveOffExit(creep, avoidSwamp = true) {\r\n        let swampDirection;\r\n        const directions = [1, 3, 5, 7, 2, 4, 6, 8];\r\n        for (const direction of directions) {\r\n            const position = creep.pos.getPositionAtDirection(direction);\r\n            if (position.rangeToEdge > 0 && position.isWalkable()) {\r\n                const terrain = position.lookFor(LOOK_TERRAIN)[0];\r\n                if (avoidSwamp && terrain == 'swamp') {\r\n                    swampDirection = direction;\r\n                    continue;\r\n                }\r\n                return creep.move(direction);\r\n            }\r\n        }\r\n        if (swampDirection) {\r\n            return creep.move(swampDirection);\r\n        }\r\n        return ERR_NO_PATH;\r\n    }\r\n    /**\r\n     * Moves off of an exit tile toward a given direction\r\n     */\r\n    static moveOffExitToward(creep, pos, detour = true) {\r\n        for (const position of creep.pos.availableNeighbors()) {\r\n            if (position.getRangeTo(pos) == 1) {\r\n                return this.goTo(creep, position);\r\n            }\r\n        }\r\n        if (detour) {\r\n            return this.goTo(creep, pos, { ignoreCreeps: false });\r\n        }\r\n    }\r\n    /**\r\n     * Moves a pair of creeps; the follower will always attempt to be in the last position of the leader\r\n     */\r\n    static pairwiseMove(leader, follower, target, opts = {}, allowedRange = 1) {\r\n        let outcome;\r\n        if (leader.room != follower.room) {\r\n            if (leader.pos.rangeToEdge == 0) {\r\n                // Leader should move off of exit tiles while waiting for follower\r\n                outcome = leader.goTo(target, opts);\r\n            }\r\n            follower.goTo(leader);\r\n            return outcome;\r\n        }\r\n        const range = leader.pos.getRangeTo(follower);\r\n        if (range > allowedRange) {\r\n            // If leader is farther than max allowed range, allow follower to catch up\r\n            if (follower.pos.rangeToEdge == 0 && follower.room == leader.room) {\r\n                follower.moveOffExitToward(leader.pos);\r\n            }\r\n            else {\r\n                follower.goTo(leader, { stuckValue: 1 });\r\n            }\r\n        }\r\n        else if (follower.fatigue == 0) {\r\n            // Leader should move if follower can also move this tick\r\n            outcome = leader.goTo(target, opts);\r\n            if (range == 1) {\r\n                follower.move(follower.pos.getDirectionTo(leader));\r\n            }\r\n            else {\r\n                follower.goTo(leader, { stuckValue: 1 });\r\n            }\r\n        }\r\n        return outcome;\r\n    }\r\n    /**\r\n     * Moves a swarm to a destination, accounting for group pathfinding\r\n     */\r\n    static swarmMove(swarm, destination, options = {}) {\r\n        if (swarm.fatigue > 0) {\r\n            Movement_1.circle(swarm.anchor, 'aqua', .3);\r\n            console.log('tired');\r\n            return ERR_TIRED;\r\n        }\r\n        // Set default options\r\n        _.defaults(options, {\r\n            range: 1,\r\n            ignoreCreeps: true,\r\n            exitCost: 10,\r\n        });\r\n        // if (options.range! < Math.max(swarm.width, swarm.height)) {\r\n        // \tlog.warning(`Range specified is ${options.range}; not allowable for ${swarm.width}x${swarm.height} swarm!`);\r\n        // }\r\n        destination = normalizePos(destination);\r\n        // initialize data object\r\n        if (!swarm.memory._go) {\r\n            swarm.memory._go = {};\r\n        }\r\n        const moveData = swarm.memory._go;\r\n        // manage case where creep is nearby destination\r\n        if (options.range != undefined && swarm.minRangeTo(destination) <= options.range &&\r\n            swarm.maxRangeTo(destination) <= options.range + Math.max(swarm.width, swarm.height)) {\r\n            delete swarm.memory._go;\r\n            console.log('no action');\r\n            return NO_ACTION;\r\n        }\r\n        const state = this.deserializeState(moveData, destination);\r\n        // check if swarm is stuck\r\n        let stuck = false;\r\n        if (state.lastCoord !== undefined) {\r\n            if (sameCoord(swarm.anchor, state.lastCoord)) { // didn't move\r\n                stuck = true;\r\n            }\r\n            else if (isExit(swarm.anchor) && isExit(state.lastCoord)) { // moved against exit\r\n                stuck = true;\r\n            }\r\n        }\r\n        if (stuck) {\r\n            state.stuckCount++;\r\n            this.circle(swarm.anchor, 'magenta', state.stuckCount * .3);\r\n        }\r\n        else {\r\n            state.stuckCount = 0;\r\n        }\r\n        // handle case where creep is stuck\r\n        if (!options.stuckValue) {\r\n            options.stuckValue = DEFAULT_STUCK_VALUE;\r\n        }\r\n        if (state.stuckCount >= options.stuckValue && Math.random() > .5) {\r\n            options.ignoreCreeps = false;\r\n            delete moveData.path;\r\n        }\r\n        // delete path cache if destination is different\r\n        if (!destination.isEqualTo(state.destination)) {\r\n            delete moveData.path;\r\n        }\r\n        if (options.repath && Math.random() < options.repath) { // randomly repath with specified probability\r\n            delete moveData.path;\r\n        }\r\n        // pathfinding\r\n        let newPath = false;\r\n        if (!moveData.path) {\r\n            newPath = true;\r\n            state.destination = destination;\r\n            const cpu = Game.cpu.getUsed();\r\n            // (!) Pathfinding is done here\r\n            const ret = Pathing.findSwarmPath(swarm.anchor, destination, swarm.width, swarm.height, options);\r\n            const cpuUsed = Game.cpu.getUsed() - cpu;\r\n            state.cpu = _.round(cpuUsed + state.cpu);\r\n            if (Game.time % 10 == 0 && state.cpu > REPORT_SWARM_CPU_THRESHOLD) {\r\n                log.alert(`Movement: heavy cpu use for swarm with ${_.first(swarm.creeps).print}, cpu: ${state.cpu}. ` +\r\n                    `(${swarm.anchor.print} ${rightArrow} ${destination.print})`);\r\n            }\r\n            let color = 'orange';\r\n            if (ret.incomplete) {\r\n                log.debug(`Movement: incomplete path for swarm with ${_.first(swarm.creeps).print}! ` +\r\n                    `(${swarm.anchor.print} ${rightArrow} ${destination.print})`);\r\n                color = 'red';\r\n            }\r\n            this.circle(swarm.anchor, color);\r\n            moveData.path = Pathing.serializePath(swarm.anchor, ret.path, color);\r\n            state.stuckCount = 0;\r\n        }\r\n        // uncomment to visualize destination\r\n        this.circle(destination, 'orange');\r\n        // Serialize state for swarm\r\n        moveData.state = [swarm.anchor.x, swarm.anchor.y, state.stuckCount, state.cpu, destination.x, destination.y,\r\n            destination.roomName];\r\n        if (!moveData.path || moveData.path.length == 0) {\r\n            console.log(`No path from ${swarm.anchor.print} to ${destination.print}!`);\r\n            return ERR_NO_PATH;\r\n        }\r\n        // consume path\r\n        if (state.stuckCount == 0 && !newPath) {\r\n            moveData.path = moveData.path.substr(1);\r\n        }\r\n        const nextDirection = parseInt(moveData.path[0], 10);\r\n        return swarm.move(nextDirection);\r\n    }\r\n    static combatMoveCallbackModifier(room, matrix, approach, avoid, options) {\r\n        // This is only applied once creep is in the target room\r\n        if (!options.allowExit) {\r\n            Pathing.blockExits(matrix);\r\n        }\r\n        // Add penalties for things you want to avoid\r\n        _.forEach(avoid, avoidThis => {\r\n            let x, y;\r\n            for (let dx = -avoidThis.range; dx <= avoidThis.range; dx++) {\r\n                for (let dy = -avoidThis.range; dy <= avoidThis.range; dy++) {\r\n                    x = avoidThis.pos.x + dx;\r\n                    y = avoidThis.pos.y + dy;\r\n                    matrix.set(x, y, matrix.get(x, y) + options.avoidPenalty);\r\n                }\r\n            }\r\n        });\r\n        // Add bonuses for things you want to approach\r\n        _.forEach(approach, approachThis => {\r\n            let cost;\r\n            let x, y;\r\n            for (let dx = -approachThis.range; dx <= approachThis.range; dx++) {\r\n                for (let dy = -approachThis.range; dy <= approachThis.range; dy++) {\r\n                    x = approachThis.pos.x + dx;\r\n                    y = approachThis.pos.y + dy;\r\n                    cost = matrix.get(x, y);\r\n                    if (cost < 0xff) { // is walkable\r\n                        cost = Math.max(cost - options.approachBonus, 1);\r\n                    }\r\n                    matrix.set(x, y, cost);\r\n                }\r\n            }\r\n        });\r\n        // Prefer to path into open ramparts\r\n        if (options.preferRamparts) {\r\n            Pathing.preferRamparts(matrix, room);\r\n        }\r\n        return matrix;\r\n    }\r\n    static swarmCombatMove(swarm, approach, avoid, options = {}) {\r\n        _.defaults(options, {\r\n            allowExit: false,\r\n            avoidPenalty: 10,\r\n            approachBonus: 5,\r\n            preferRamparts: true,\r\n        });\r\n        const debug = false;\r\n        const callback = (roomName) => {\r\n            let matrix;\r\n            const room = swarm.roomsByName[roomName];\r\n            if (room) {\r\n                matrix = Pathing.getSwarmDefaultMatrix(room, swarm.width, swarm.height); // already cloned\r\n                // Block positions from other swarms in the room\r\n                const otherCreeps = _.filter(room.creeps, creep => !_.any(swarm.creeps, c => c.name == creep.name));\r\n                Pathing.blockMyCreeps(matrix, room, otherCreeps);\r\n                // Pathing.blockHostileCreeps(matrix, creep.room);\r\n                Movement_1.combatMoveCallbackModifier(room, matrix, approach, avoid, options);\r\n            }\r\n            else {\r\n                matrix = Pathing.getSwarmTerrainMatrix(roomName, swarm.width, swarm.height);\r\n            }\r\n            if (options.displayCostMatrix) {\r\n                Visualizer.displayCostMatrix(matrix, roomName);\r\n            }\r\n            return matrix;\r\n        };\r\n        let outcome = NO_ACTION;\r\n        // Flee from bad things that that you're too close to\r\n        if (avoid.length > 0) {\r\n            const size = Math.max(swarm.width, swarm.height);\r\n            if (_.any(avoid, goal => swarm.minRangeTo(goal) <= goal.range)) {\r\n                const allAvoid = _.flatten(_.map(avoid, goal => _.map(Pathing.getPosWindow(goal.pos, -swarm.width, -swarm.height), pos => ({\r\n                    pos: pos,\r\n                    range: goal.range\r\n                }))));\r\n                if (options.displayAvoid) {\r\n                    const room = swarm.rooms[0];\r\n                    for (const avoid of allAvoid) {\r\n                        const { x, y } = avoid.pos;\r\n                        room.visual.text(avoid.range.toString(), x, y, { color: 'ff0099' });\r\n                    }\r\n                }\r\n                const avoidRet = PathFinder.search(swarm.anchor, allAvoid, {\r\n                    roomCallback: callback,\r\n                    flee: true,\r\n                    maxRooms: options.allowExit ? 5 : 1,\r\n                    plainCost: 2,\r\n                    swampCost: 10,\r\n                });\r\n                if (avoidRet.path.length > 0) {\r\n                    if (debug)\r\n                        Pathing.serializePath(swarm.anchor, avoidRet.path, 'magenta');\r\n                    outcome = swarm.move(swarm.anchor.getDirectionTo(avoidRet.path[0]));\r\n                    if (outcome == OK) {\r\n                        return outcome;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Approach things you want to go to if you're out of range of all the baddies\r\n        if (approach.length > 0) {\r\n            if (!_.any(approach, goal => swarm.minRangeTo(goal) <= goal.range)) {\r\n                const allApproach = _.flatten(_.map(approach, goal => _.map(Pathing.getPosWindow(goal.pos, -swarm.width, -swarm.height), pos => ({\r\n                    pos: pos,\r\n                    range: goal.range\r\n                }))));\r\n                const approachRet = PathFinder.search(swarm.anchor, allApproach, {\r\n                    roomCallback: callback,\r\n                    maxRooms: 1,\r\n                    plainCost: 2,\r\n                    swampCost: 10,\r\n                });\r\n                if (approachRet.path.length > 0) {\r\n                    if (debug)\r\n                        Pathing.serializePath(swarm.anchor, approachRet.path, 'cyan');\r\n                    outcome = swarm.move(swarm.anchor.getDirectionTo(approachRet.path[0]));\r\n                    if (outcome == OK) {\r\n                        return outcome;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return outcome;\r\n    }\r\n    static combatMove(creep, approach, avoid, options = {}) {\r\n        _.defaults(options, {\r\n            allowExit: false,\r\n            avoidPenalty: 10,\r\n            approachBonus: 5,\r\n            preferRamparts: true,\r\n            requireRamparts: false,\r\n        });\r\n        const debug = false;\r\n        const callback = (roomName) => {\r\n            if (roomName == creep.room.name) {\r\n                const matrix = Pathing.getDefaultMatrix(creep.room).clone();\r\n                Pathing.blockMyCreeps(matrix, creep.room);\r\n                Pathing.blockHostileCreeps(matrix, creep.room);\r\n                if (options.requireRamparts) {\r\n                    Pathing.blockNonRamparts(matrix, creep.room);\r\n                }\r\n                Movement_1.combatMoveCallbackModifier(creep.room, matrix, approach, avoid, options);\r\n                if (options.displayCostMatrix) {\r\n                    Visualizer.displayCostMatrix(matrix, roomName);\r\n                }\r\n                return matrix;\r\n            }\r\n            else {\r\n                return !(Memory.rooms[roomName] && Memory.rooms[roomName][\"a\" /* AVOID */]);\r\n            }\r\n        };\r\n        let outcome = NO_ACTION;\r\n        // Flee from bad things that that you're too close to\r\n        if (avoid.length > 0) {\r\n            if (_.any(avoid, goal => creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range))\r\n                && !creep.inRampart) {\r\n                const avoidRet = PathFinder.search(creep.pos, avoid, {\r\n                    roomCallback: callback,\r\n                    flee: true,\r\n                    maxRooms: options.allowExit ? 5 : 1,\r\n                    plainCost: 2,\r\n                    swampCost: 10,\r\n                });\r\n                if (avoidRet.path.length > 0) {\r\n                    if (debug)\r\n                        Pathing.serializePath(creep.pos, avoidRet.path, 'magenta');\r\n                    outcome = creep.move(creep.pos.getDirectionTo(avoidRet.path[0]));\r\n                    if (outcome == OK) {\r\n                        return outcome;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Approach things you want to go to if you're out of range of all the baddies\r\n        if (approach.length > 0) {\r\n            if (!_.any(approach, goal => creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range))) {\r\n                const approachRet = PathFinder.search(creep.pos, approach, {\r\n                    roomCallback: callback,\r\n                    maxRooms: 1,\r\n                    plainCost: 2,\r\n                    swampCost: 10,\r\n                });\r\n                if (approachRet.path.length > 0) {\r\n                    if (debug)\r\n                        Pathing.serializePath(creep.pos, approachRet.path, 'cyan');\r\n                    outcome = creep.move(creep.pos.getDirectionTo(approachRet.path[0]));\r\n                    if (outcome == OK) {\r\n                        return outcome;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Try to maneuver under ramparts if possible\r\n        if ((options.preferRamparts || options.requireRamparts) && !creep.inRampart && approach.length > 0) {\r\n            const openRamparts = _.filter(creep.room.walkableRamparts, rampart => _.any(approach, g => rampart.pos.inRangeToXY(g.pos.x, g.pos.y, g.range))\r\n                && rampart.pos.isWalkable());\r\n            if (openRamparts.length > 0) {\r\n                const ret = PathFinder.search(creep.pos, _.map(openRamparts, r => ({ pos: r.pos, range: 0 })), {\r\n                    roomCallback: callback,\r\n                    maxRooms: 1,\r\n                    plainCost: 2,\r\n                    swampCost: 10,\r\n                });\r\n                if (ret.path.length > 0) {\r\n                    if (debug)\r\n                        Pathing.serializePath(creep.pos, ret.path, 'green');\r\n                    outcome = creep.move(creep.pos.getDirectionTo(ret.path[0]));\r\n                    if (outcome == OK) {\r\n                        return outcome;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return outcome;\r\n    }\r\n    static invasionMoveCallbackModifier(room, matrix) {\r\n        // This is only applied once creep is in the target room\r\n        Pathing.blockExits(matrix);\r\n        for (const hostile of room.invaders) {\r\n            if (hostile.getActiveBodyparts(RANGED_ATTACK) > 1) {\r\n                Pathing.setCostsInRange(matrix, hostile, 3, 1, true);\r\n            }\r\n            else if (hostile.getActiveBodyparts(ATTACK) > 1) {\r\n                Pathing.setCostsInRange(matrix, hostile, 1, 1, true);\r\n            }\r\n        }\r\n        for (const keeper of room.sourceKeepers) {\r\n            Pathing.setCostsInRange(matrix, keeper, 3, 10, true);\r\n        }\r\n        for (const lair of room.keeperLairs) {\r\n            if ((lair.ticksToSpawn || Infinity) < 25) {\r\n                Pathing.setCostsInRange(matrix, lair, 5, 5, true);\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Moving routine for guards or sourceReapers in a room with NPC invaders\r\n     */\r\n    static invasionMove(creep, destination, options = {}) {\r\n        _.defaults(options, {\r\n            ignoreRoads: true\r\n        });\r\n        const dest = normalizePos(destination);\r\n        if (creep.pos.getRangeTo(dest) > 8) {\r\n            options.repath = .1;\r\n            options.movingTarget = true;\r\n        }\r\n        if (creep.room.name == dest.roomName) {\r\n            options.maxRooms = 1;\r\n            options.modifyRoomCallback = this.invasionMoveCallbackModifier;\r\n        }\r\n        return creep.goTo(dest, options);\r\n    }\r\n    /**\r\n     * Kite around enemies in a single room, repathing every tick. More expensive than flee().\r\n     */\r\n    static kite(creep, avoidGoals, options = {}) {\r\n        _.defaults(options, {\r\n            fleeRange: 5,\r\n            terrainCosts: getTerrainCosts(creep.creep),\r\n        });\r\n        const nextPos = _.first(Pathing.findKitingPath(creep.pos, avoidGoals, options).path);\r\n        if (nextPos) {\r\n            return creep.move(creep.pos.getDirectionTo(nextPos));\r\n        }\r\n    }\r\n    /**\r\n     * Flee from avoid goals in the room while not re-pathing every tick like kite() does.\r\n     */\r\n    static flee(creep, avoidGoals, dropEnergy = false, options = {}) {\r\n        if (avoidGoals.length == 0) {\r\n            return; // nothing to flee from\r\n        }\r\n        _.defaults(options, {\r\n            terrainCosts: getTerrainCosts(creep.creep),\r\n        });\r\n        if (options.fleeRange == undefined)\r\n            options.fleeRange = options.terrainCosts.plainCost > 1 ? 8 : 16;\r\n        const closest = creep.pos.findClosestByRange(avoidGoals);\r\n        const rangeToClosest = closest ? creep.pos.getRangeTo(closest) : 50;\r\n        if (rangeToClosest > options.fleeRange) { // Out of range of baddies\r\n            if (!creep.memory._go) {\r\n                return;\r\n            }\r\n            if (creep.pos.isEdge) {\r\n                return creep.moveOffExit();\r\n            }\r\n            // wait until safe\r\n            const moveData = creep.memory._go;\r\n            if (moveData.fleeWait != undefined) {\r\n                if (moveData.fleeWait <= 0) {\r\n                    // you're safe now\r\n                    delete creep.memory._go;\r\n                    return;\r\n                }\r\n                else {\r\n                    moveData.fleeWait--;\r\n                    return NO_ACTION;\r\n                }\r\n            }\r\n            else {\r\n                // you're safe\r\n                return;\r\n            }\r\n        }\r\n        else { // Still need to run away\r\n            // initialize data object\r\n            if (!creep.memory._go) {\r\n                creep.memory._go = {};\r\n            }\r\n            const moveData = creep.memory._go;\r\n            moveData.fleeWait = 2;\r\n            // Invalidate path if needed\r\n            if (moveData.path) {\r\n                if (moveData.path.length > 0) {\r\n                    const nextDirection = parseInt(moveData.path[0], 10);\r\n                    const pos = creep.pos.getPositionAtDirection(nextDirection);\r\n                    if (!pos.isEdge) {\r\n                        const newClosest = pos.findClosestByRange(avoidGoals);\r\n                        if (newClosest && normalizePos(newClosest).getRangeTo(pos) < rangeToClosest) {\r\n                            delete moveData.path;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    delete moveData.path;\r\n                }\r\n            }\r\n            // Re-calculate path if needed\r\n            if (!moveData.path || !moveData.destination) {\r\n                const ret = Pathing.findFleePath(creep.pos, avoidGoals, options);\r\n                if (ret.path.length == 0) {\r\n                    return NO_ACTION;\r\n                }\r\n                moveData.destination = _.last(ret.path);\r\n                moveData.path = Pathing.serializePath(creep.pos, ret.path, 'purple');\r\n            }\r\n            // Call goTo to the final position in path\r\n            return Movement_1.goTo(creep, derefRoomPosition(moveData.destination), options);\r\n        }\r\n    }\r\n    static deserializeState(moveData, destination) {\r\n        const state = {};\r\n        if (moveData.state) {\r\n            state.lastCoord = { x: moveData.state[STATE_PREV_X], y: moveData.state[STATE_PREV_Y] };\r\n            state.cpu = moveData.state[STATE_CPU];\r\n            state.stuckCount = moveData.state[STATE_STUCK];\r\n            state.destination = new RoomPosition(moveData.state[STATE_DEST_X], moveData.state[STATE_DEST_Y], moveData.state[STATE_DEST_ROOMNAME]);\r\n            if (moveData.state[STATE_CURRENT_X] && moveData.state[STATE_CURRENT_Y]) {\r\n                state.currentXY = { x: moveData.state[STATE_CURRENT_X], y: moveData.state[STATE_CURRENT_Y] };\r\n            }\r\n        }\r\n        else {\r\n            state.cpu = 0;\r\n            state.destination = destination;\r\n        }\r\n        return state;\r\n    }\r\n    static serializeState(creep, destination, state, moveData, nextCoord) {\r\n        if (nextCoord) {\r\n            moveData.state = [creep.pos.x, creep.pos.y, state.stuckCount, state.cpu, destination.x, destination.y,\r\n                destination.roomName, nextCoord.x, nextCoord.y];\r\n        }\r\n        else {\r\n            moveData.state = [creep.pos.x, creep.pos.y, state.stuckCount, state.cpu, destination.x, destination.y,\r\n                destination.roomName];\r\n        }\r\n    }\r\n    /**\r\n     * Update the currentXY property for a move state\r\n     */\r\n    static updateStateNextCoord(moveData, nextCoord) {\r\n        if (moveData.state) {\r\n            if (moveData.state[STATE_CURRENT_X] != undefined && moveData.state[STATE_CURRENT_Y] != undefined) {\r\n                moveData.state[STATE_CURRENT_X] = nextCoord.x;\r\n                moveData.state[STATE_CURRENT_Y] = nextCoord.y;\r\n            }\r\n            else if (moveData.state.length == STATE_CURRENT_X) {\r\n                moveData.state.push(nextCoord.x);\r\n                moveData.state.push(nextCoord.y);\r\n            }\r\n            else {\r\n                // Shouldn't ever reach here\r\n                log.warning(`Invalid moveData.state length!`);\r\n            }\r\n        }\r\n    }\r\n    static isStuck(creep, state) {\r\n        let stuck = false;\r\n        if (state.lastCoord !== undefined) {\r\n            if (sameCoord(creep.pos, state.lastCoord)) { // didn't move\r\n                stuck = true;\r\n            }\r\n            else if (isExit(creep.pos) && isExit(state.lastCoord)) { // moved against exit\r\n                stuck = true;\r\n            }\r\n        }\r\n        return stuck;\r\n    }\r\n    /**\r\n     * Draw a circle\r\n     */\r\n    static circle(pos, color, opacity) {\r\n        return new RoomVisual(pos.roomName).circle(pos, {\r\n            radius: .45, fill: 'transparent', stroke: color, strokeWidth: .15, opacity: opacity\r\n        });\r\n    }\r\n};\r\nMovement = Movement_1 = tslib_1.__decorate([\r\n    profile\r\n], Movement);\r\nexport { Movement };\r\n// Creep.prototype.goTo = function (destination: RoomPosition | HasPos, options?: MoveOptions) {\r\n// \treturn Movement.goTo(this, destination, options);\r\n// };\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/roomPlanner/layouts/bunker.ts","C:/git/Overmind/src/utilities/stringConstants.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/visuals/Visualizer.ts","C:/git/Overmind/src/zerg/Swarm.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/movement/helpers.ts","C:/git/Overmind/src/movement/Pathing.ts"]}
