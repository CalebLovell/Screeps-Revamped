{"code":"import * as tslib_1 from \"tslib\";\r\nvar WorkerOverlord_1;\r\nimport { $ } from '../../caching/GlobalCache';\r\nimport { ColonyStage, DEFCON } from '../../Colony';\r\nimport { Roles, Setups } from '../../creepSetups/setups';\r\nimport { TERMINAL_STATE_REBUILD } from '../../directives/terminalState/terminalState_rebuild';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { BuildPriorities, FortifyPriorities } from '../../priorities/priorities_structures';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { boostResources } from '../../resources/map_resources';\r\nimport { Tasks } from '../../tasks/Tasks';\r\nimport { Cartographer, ROOMTYPE_CONTROLLER } from '../../utilities/Cartographer';\r\nimport { minBy } from '../../utilities/utils';\r\nimport { Overlord } from '../Overlord';\r\n/**\r\n * Spawns general-purpose workers, which maintain a colony, performing actions such as building, repairing, fortifying,\r\n * paving, and upgrading, when needed\r\n */\r\nlet WorkerOverlord = WorkerOverlord_1 = class WorkerOverlord extends Overlord {\r\n    constructor(colony, priority = OverlordPriority.ownedRoom.work) {\r\n        super(colony, 'worker', priority);\r\n        // Compute barriers needing fortification or critical attention\r\n        this.fortifyBarriers = $.structures(this, 'fortifyBarriers', () => _.sortBy(_.filter(this.room.barriers, s => s.hits < WorkerOverlord_1.settings.barrierHits[this.colony.level]\r\n            && this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(s.pos)), s => s.hits), 25);\r\n        this.criticalBarriers = $.structures(this, 'criticalBarriers', () => _.filter(this.fortifyBarriers, barrier => barrier.hits < WorkerOverlord_1.settings.barrierHits.critical), 10);\r\n        // Generate a list of structures needing repairing (different from fortifying except in critical case)\r\n        this.repairStructures = $.structures(this, 'repairStructures', () => _.filter(this.colony.repairables, structure => {\r\n            if (structure.structureType == STRUCTURE_CONTAINER) {\r\n                // only repair containers in owned room\r\n                if (structure.pos.roomName == this.colony.name) {\r\n                    return structure.hits < 0.5 * structure.hitsMax;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                return structure.hits < structure.hitsMax;\r\n            }\r\n        }));\r\n        this.dismantleStructures = [];\r\n        const homeRoomName = this.colony.room.name;\r\n        const defcon = this.colony.defcon;\r\n        // Filter constructionSites to only build valid ones\r\n        const room = this.colony.room;\r\n        const level = this.colony.controller.level;\r\n        this.constructionSites = _.filter(this.colony.constructionSites, function (site) {\r\n            // If site will be more than max amount of a structure at current level, ignore (happens after downgrade)\r\n            const structureAmount = room[site.structureType + 's'] ? room[site.structureType + 's'].length :\r\n                (room[site.structureType] ? 1 : 0);\r\n            if (structureAmount >= CONTROLLER_STRUCTURES[site.structureType][level]) {\r\n                return false;\r\n            }\r\n            if (defcon > DEFCON.safe) {\r\n                // Only build non-road, non-container sites in the home room if defcon is unsafe\r\n                return site.pos.roomName == homeRoomName &&\r\n                    site.structureType != STRUCTURE_CONTAINER &&\r\n                    site.structureType != STRUCTURE_ROAD;\r\n            }\r\n            else {\r\n                // Build all non-container sites in outpost and all sites in room if defcon is safe\r\n                if (site.pos.roomName != homeRoomName\r\n                    && Cartographer.roomType(site.pos.roomName) == ROOMTYPE_CONTROLLER) {\r\n                    return site.structureType != STRUCTURE_CONTAINER &&\r\n                        !(site.room && site.room.dangerousHostiles.length > 0);\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }\r\n        });\r\n        // Nuke defense ramparts needing fortification\r\n        this.nukeDefenseRamparts = [];\r\n        this.nukeDefenseHitsRemaining = {};\r\n        if (this.room.find(FIND_NUKES).length > 0) {\r\n            for (const rampart of this.colony.room.ramparts) {\r\n                const neededHits = this.neededRampartHits(rampart);\r\n                if (rampart.hits < neededHits) {\r\n                    this.nukeDefenseRamparts.push(rampart);\r\n                    this.nukeDefenseHitsRemaining[rampart.id] = neededHits - rampart.hits;\r\n                }\r\n            }\r\n        }\r\n        // Spawn boosted workers if there is significant fortifying which needs to be done\r\n        const opts = {};\r\n        const totalNukeDefenseHitsRemaining = _.sum(_.values(this.nukeDefenseHitsRemaining));\r\n        const approximateRepairPowerPerLifetime = REPAIR_POWER * 50 / 3 * CREEP_LIFE_TIME;\r\n        if (totalNukeDefenseHitsRemaining > 3 * approximateRepairPowerPerLifetime) {\r\n            opts.boostWishlist = [boostResources.construct[3]];\r\n        }\r\n        // Register workers\r\n        this.workers = this.zerg(Roles.worker, opts);\r\n    }\r\n    neededRampartHits(rampart) {\r\n        let neededHits = WorkerOverlord_1.settings.barrierHits[this.colony.level];\r\n        for (const nuke of rampart.pos.lookFor(LOOK_NUKES)) {\r\n            neededHits += 10e6;\r\n        }\r\n        for (const nuke of rampart.pos.findInRange(FIND_NUKES, 3)) {\r\n            if (nuke.pos != rampart.pos) {\r\n                neededHits += 5e6;\r\n            }\r\n        }\r\n        return neededHits;\r\n    }\r\n    refresh() {\r\n        super.refresh();\r\n        $.refresh(this, 'repairStructures', 'dismantleStructures', 'fortifyBarriers', 'criticalBarriers', 'constructionSites', 'nukeDefenseRamparts');\r\n    }\r\n    init() {\r\n        const setup = this.colony.level == 1 ? Setups.workers.early : Setups.workers.default;\r\n        const workPartsPerWorker = setup.getBodyPotential(WORK, this.colony);\r\n        let numWorkers;\r\n        if (this.colony.stage == ColonyStage.Larva) {\r\n            numWorkers = $.number(this, 'numWorkers', () => {\r\n                // At lower levels, try to saturate the energy throughput of the colony\r\n                const MAX_WORKERS = 10; // Maximum number of workers to spawn\r\n                const energyMinedPerTick = _.sum(_.map(this.colony.miningSites, function (site) {\r\n                    const overlord = site.overlords.mine;\r\n                    const miningPowerAssigned = _.sum(overlord.miners, miner => miner.getActiveBodyparts(WORK));\r\n                    const saturation = Math.min(miningPowerAssigned / overlord.miningPowerNeeded, 1);\r\n                    return overlord.energyPerTick * saturation;\r\n                }));\r\n                const energyPerTickPerWorker = 1.1 * workPartsPerWorker; // Average energy per tick when working\r\n                const workerUptime = 0.8;\r\n                const numWorkers = Math.ceil(energyMinedPerTick / (energyPerTickPerWorker * workerUptime));\r\n                return Math.min(numWorkers, MAX_WORKERS);\r\n            });\r\n        }\r\n        else {\r\n            if (this.colony.roomPlanner.memory.relocating) {\r\n                // If relocating, maintain a maximum of workers\r\n                numWorkers = 5;\r\n            }\r\n            else {\r\n                numWorkers = $.number(this, 'numWorkers', () => {\r\n                    // At higher levels, spawn workers based on construction and repair that needs to be done\r\n                    const MAX_WORKERS = 5; // Maximum number of workers to spawn\r\n                    if (this.nukeDefenseRamparts.length > 0) {\r\n                        return MAX_WORKERS;\r\n                    }\r\n                    const buildTicks = _.sum(this.constructionSites, site => Math.max(site.progressTotal - site.progress, 0)) / BUILD_POWER;\r\n                    const repairTicks = _.sum(this.repairStructures, structure => structure.hitsMax - structure.hits) / REPAIR_POWER;\r\n                    const paveTicks = _.sum(this.colony.rooms, room => this.colony.roadLogistics.energyToRepave(room)) / 1; // repairCost=1\r\n                    let fortifyTicks = 0;\r\n                    if (this.colony.assets.energy > WorkerOverlord_1.settings.fortifyDutyThreshold) {\r\n                        fortifyTicks = 0.25 * _.sum(this.fortifyBarriers, barrier => Math.max(0, WorkerOverlord_1.settings.barrierHits[this.colony.level]\r\n                            - barrier.hits)) / REPAIR_POWER;\r\n                    }\r\n                    // max constructionTicks for private server manually setting progress\r\n                    let numWorkers = Math.ceil(2 * (5 * buildTicks + repairTicks + paveTicks + fortifyTicks) /\r\n                        (workPartsPerWorker * CREEP_LIFE_TIME));\r\n                    numWorkers = Math.min(numWorkers, MAX_WORKERS);\r\n                    if (this.colony.controller.ticksToDowngrade <= (this.colony.level >= 4 ? 10000 : 2000)) {\r\n                        numWorkers = Math.max(numWorkers, 1);\r\n                    }\r\n                    return numWorkers;\r\n                });\r\n            }\r\n        }\r\n        this.wishlist(numWorkers, setup);\r\n    }\r\n    repairActions(worker) {\r\n        const target = worker.pos.findClosestByMultiRoomRange(this.repairStructures);\r\n        if (target) {\r\n            worker.task = Tasks.repair(target);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    buildActions(worker) {\r\n        const groupedSites = _.groupBy(this.constructionSites, site => site.structureType);\r\n        for (const structureType of BuildPriorities) {\r\n            if (groupedSites[structureType]) {\r\n                const target = worker.pos.findClosestByMultiRoomRange(groupedSites[structureType]);\r\n                if (target) {\r\n                    worker.task = Tasks.build(target);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    dismantleActions(worker) {\r\n        const targets = _.filter(this.dismantleStructures, s => (s.targetedBy || []).length < 3);\r\n        const target = worker.pos.findClosestByMultiRoomRange(targets);\r\n        if (target) {\r\n            _.remove(this.dismantleStructures, s => s == target);\r\n            worker.task = Tasks.dismantle(target);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    // Find a suitable repair ordering of roads with a depth first search\r\n    buildPavingManifest(worker, room) {\r\n        let energy = worker.carry.energy;\r\n        const targetRefs = {};\r\n        const tasks = [];\r\n        let target;\r\n        let previousPos;\r\n        while (true) {\r\n            if (energy <= 0)\r\n                break;\r\n            if (previousPos) {\r\n                target = _.find(this.colony.roadLogistics.repairableRoads(room), road => road.hits < road.hitsMax && !targetRefs[road.id]\r\n                    && road.pos.getRangeTo(previousPos) <= 1);\r\n            }\r\n            else {\r\n                target = _.find(this.colony.roadLogistics.repairableRoads(room), road => road.hits < road.hitsMax && !targetRefs[road.id]);\r\n            }\r\n            if (target) {\r\n                previousPos = target.pos;\r\n                targetRefs[target.id] = true;\r\n                energy -= (target.hitsMax - target.hits) / REPAIR_POWER;\r\n                tasks.push(Tasks.repair(target));\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return Tasks.chain(tasks);\r\n    }\r\n    pavingActions(worker) {\r\n        const roomToRepave = this.colony.roadLogistics.workerShouldRepave(worker);\r\n        this.colony.roadLogistics.registerWorkerAssignment(worker, roomToRepave);\r\n        // Build a paving manifest\r\n        const task = this.buildPavingManifest(worker, roomToRepave);\r\n        if (task) {\r\n            worker.task = task;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    fortifyActions(worker, fortifyStructures = this.fortifyBarriers) {\r\n        let lowBarriers;\r\n        const highestBarrierHits = _.max(_.map(fortifyStructures, structure => structure.hits));\r\n        if (highestBarrierHits > WorkerOverlord_1.settings.hitTolerance) {\r\n            // At high barrier HP, fortify only structures that are within a threshold of the lowest\r\n            const lowestBarrierHits = _.min(_.map(fortifyStructures, structure => structure.hits));\r\n            lowBarriers = _.filter(fortifyStructures, structure => structure.hits <= lowestBarrierHits +\r\n                WorkerOverlord_1.settings.hitTolerance);\r\n        }\r\n        else {\r\n            // Otherwise fortify the lowest N structures\r\n            const numBarriersToConsider = 5; // Choose the closest barrier of the N barriers with lowest hits\r\n            lowBarriers = _.take(fortifyStructures, numBarriersToConsider);\r\n        }\r\n        const target = worker.pos.findClosestByMultiRoomRange(lowBarriers);\r\n        if (target) {\r\n            worker.task = Tasks.fortify(target);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    nukeFortifyActions(worker, fortifyStructures = this.nukeDefenseRamparts) {\r\n        const target = minBy(fortifyStructures, rampart => {\r\n            const structuresUnderRampart = rampart.pos.lookFor(LOOK_STRUCTURES);\r\n            return _.min(_.map(structuresUnderRampart, structure => {\r\n                const priority = _.findIndex(FortifyPriorities, sType => sType == structure.structureType);\r\n                if (priority >= 0) { // if found\r\n                    return priority;\r\n                }\r\n                else { // not found\r\n                    return 999;\r\n                }\r\n            }));\r\n        });\r\n        if (target) {\r\n            worker.task = Tasks.fortify(target);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    upgradeActions(worker) {\r\n        // Sign controller if needed\r\n        if ((!this.colony.controller.signedByMe && !this.colony.controller.signedByScreeps)) {\r\n            worker.task = Tasks.signController(this.colony.controller);\r\n            return true;\r\n        }\r\n        worker.task = Tasks.upgrade(this.room.controller);\r\n        return true;\r\n    }\r\n    handleWorker(worker) {\r\n        if (worker.carry.energy > 0) {\r\n            // Upgrade controller if close to downgrade\r\n            if (this.colony.controller.ticksToDowngrade <= (this.colony.level >= 4 ? 10000 : 2000)) {\r\n                if (this.upgradeActions(worker))\r\n                    return;\r\n            }\r\n            // Repair damaged non-road non-barrier structures\r\n            if (this.repairStructures.length > 0 && this.colony.defcon == DEFCON.safe) {\r\n                if (this.repairActions(worker))\r\n                    return;\r\n            }\r\n            // Fortify critical barriers\r\n            if (this.criticalBarriers.length > 0) {\r\n                if (this.fortifyActions(worker, this.criticalBarriers))\r\n                    return;\r\n            }\r\n            // Build new structures\r\n            if (this.constructionSites.length > 0) {\r\n                if (this.buildActions(worker))\r\n                    return;\r\n            }\r\n            // Build ramparts to block incoming nuke\r\n            if (this.nukeDefenseRamparts.length > 0 && this.colony.terminalState != TERMINAL_STATE_REBUILD) {\r\n                if (this.nukeFortifyActions(worker, this.nukeDefenseRamparts))\r\n                    return;\r\n            }\r\n            // Build and maintain roads\r\n            if (this.colony.roadLogistics.workerShouldRepave(worker) && this.colony.defcon == DEFCON.safe) {\r\n                if (this.pavingActions(worker))\r\n                    return;\r\n            }\r\n            // Dismantle marked structures\r\n            if (this.dismantleStructures.length > 0 && this.colony.defcon == DEFCON.safe) {\r\n                if (this.dismantleActions(worker))\r\n                    return;\r\n            }\r\n            // Fortify walls and ramparts\r\n            if (this.fortifyBarriers.length > 0) {\r\n                if (this.fortifyActions(worker, this.fortifyBarriers))\r\n                    return;\r\n            }\r\n            // Upgrade controller if less than RCL8 or no upgraders\r\n            if ((this.colony.level < 8 || this.colony.upgradeSite.overlord.upgraders.length == 0)\r\n                && this.colony.defcon == DEFCON.safe) {\r\n                if (this.upgradeActions(worker))\r\n                    return;\r\n            }\r\n        }\r\n        else {\r\n            // Acquire more energy\r\n            const workerWithdrawLimit = this.colony.stage == ColonyStage.Larva ? 750 : 100;\r\n            worker.task = Tasks.recharge(workerWithdrawLimit);\r\n        }\r\n    }\r\n    run() {\r\n        this.autoRun(this.workers, worker => this.handleWorker(worker), worker => worker.flee(worker.room.fleeDefaults, { invalidateTask: true }));\r\n    }\r\n};\r\nWorkerOverlord.settings = {\r\n    barrierHits: {\r\n        critical: 2500,\r\n        1: 3e+3,\r\n        2: 3e+3,\r\n        3: 1e+4,\r\n        4: 5e+4,\r\n        5: 1e+5,\r\n        6: 5e+5,\r\n        7: 1e+6,\r\n        8: 2e+7,\r\n    },\r\n    hitTolerance: 100000,\r\n    fortifyDutyThreshold: 500000,\r\n};\r\nWorkerOverlord = WorkerOverlord_1 = tslib_1.__decorate([\r\n    profile\r\n], WorkerOverlord);\r\nexport { WorkerOverlord };\r\n","references":["C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/directives/terminalState/terminalState_rebuild.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/priorities/priorities_structures.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/resources/map_resources.ts","C:/git/Overmind/src/tasks/Task.ts","C:/git/Overmind/src/tasks/Tasks.ts","C:/git/Overmind/src/utilities/Cartographer.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/overlords/Overlord.ts"]}
