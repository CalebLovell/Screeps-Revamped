{"code":"import * as tslib_1 from \"tslib\";\r\nimport { log } from '../../console/log';\r\nimport { Roles, Setups } from '../../creepSetups/setups';\r\nimport { isResource, isStoreStructure, isTombstone } from '../../declarations/typeGuards';\r\nimport { ALL_RESOURCE_TYPE_ERROR } from '../../logistics/LogisticsNetwork';\r\nimport { Pathing } from '../../movement/Pathing';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { Tasks } from '../../tasks/Tasks';\r\nimport { Overlord } from '../Overlord';\r\n/**\r\n * The transport overlord handles energy transport throughout a colony\r\n */\r\nlet TransportOverlord = class TransportOverlord extends Overlord {\r\n    constructor(colony, priority = OverlordPriority.ownedRoom.transport) {\r\n        super(colony, 'logistics', priority);\r\n        this.transporters = this.zerg(Roles.transport);\r\n    }\r\n    neededTransportPower() {\r\n        if (!this.colony.storage\r\n            && !(this.colony.hatchery && this.colony.hatchery.battery)\r\n            && !this.colony.upgradeSite.battery) {\r\n            return 0;\r\n        }\r\n        let transportPower = 0;\r\n        const scaling = 2; // this.colony.stage == ColonyStage.Larva ? 1.5 : 2.0; // aggregate round-trip multiplier\r\n        // Add contributions to transport power from hauling energy from mining sites\r\n        for (const flagName in this.colony.miningSites) {\r\n            const o = this.colony.miningSites[flagName].overlords.mine;\r\n            if (!o.isSuspended && o.miners.length > 0) {\r\n                // Only count sites which have a container output and which have at least one miner present\r\n                // (this helps in difficult \"rebooting\" situations)\r\n                if ((o.container && !o.link) || o.allowDropMining) {\r\n                    transportPower += o.energyPerTick * scaling * o.distance;\r\n                }\r\n            }\r\n        }\r\n        // Add transport power needed to move to upgradeSite\r\n        if (this.colony.upgradeSite.battery) {\r\n            transportPower += UPGRADE_CONTROLLER_POWER * this.colony.upgradeSite.upgradePowerNeeded * scaling *\r\n                Pathing.distance(this.colony.pos, this.colony.upgradeSite.battery.pos);\r\n        }\r\n        if (this.colony.lowPowerMode) {\r\n            // Reduce needed transporters when colony is in low power mode\r\n            transportPower *= 0.5;\r\n        }\r\n        return transportPower / CARRY_CAPACITY;\r\n    }\r\n    init() {\r\n        const ROAD_COVERAGE_THRESHOLD = 0.75; // switch from 1:1 to 2:1 transporters above this coverage threshold\r\n        const setup = this.colony.roomPlanner.roadPlanner.roadCoverage < ROAD_COVERAGE_THRESHOLD\r\n            ? Setups.transporters.early : Setups.transporters.default;\r\n        const transportPowerEach = setup.getBodyPotential(CARRY, this.colony);\r\n        const neededTransportPower = this.neededTransportPower();\r\n        const numTransporters = Math.ceil(neededTransportPower / transportPowerEach);\r\n        if (this.transporters.length == 0) {\r\n            this.wishlist(numTransporters, setup, { priority: OverlordPriority.ownedRoom.firstTransport });\r\n        }\r\n        else {\r\n            this.wishlist(numTransporters, setup);\r\n        }\r\n    }\r\n    handleTransporter(transporter, request) {\r\n        if (request) {\r\n            const choices = this.colony.logisticsNetwork.bufferChoices(transporter, request);\r\n            const bestChoice = _.last(_.sortBy(choices, choice => request.multiplier * choice.dQ\r\n                / Math.max(choice.dt, 0.1)));\r\n            let task = null;\r\n            const amount = this.colony.logisticsNetwork.predictedRequestAmount(transporter, request);\r\n            // Target is requesting input\r\n            if (amount > 0) {\r\n                if (isResource(request.target) || isTombstone(request.target)) {\r\n                    log.warning(`Improper logistics request: should not request input for resource or tombstone!`);\r\n                    return;\r\n                }\r\n                else if (request.resourceType == 'all') {\r\n                    log.error(`${this.print}: cannot request 'all' as input!`);\r\n                    return;\r\n                }\r\n                else {\r\n                    task = Tasks.transfer(request.target, request.resourceType);\r\n                }\r\n                if (bestChoice.targetRef != request.target.ref) {\r\n                    // If we need to go to a buffer first to get more stuff\r\n                    const buffer = deref(bestChoice.targetRef);\r\n                    const withdrawAmount = Math.min(buffer.store[request.resourceType] || 0, transporter.carryCapacity - _.sum(transporter.carry), amount);\r\n                    task = task.fork(Tasks.withdraw(buffer, request.resourceType, withdrawAmount));\r\n                    if (transporter.hasMineralsInCarry && request.resourceType == RESOURCE_ENERGY) {\r\n                        task = task.fork(Tasks.transferAll(buffer));\r\n                    }\r\n                }\r\n            }\r\n            // Target is requesting output\r\n            else if (amount < 0) {\r\n                if (isResource(request.target)) {\r\n                    task = Tasks.pickup(request.target);\r\n                }\r\n                else {\r\n                    if (request.resourceType == 'all') {\r\n                        if (!isStoreStructure(request.target) && !isTombstone(request.target)) {\r\n                            log.error(`TransportOverlord: ` + ALL_RESOURCE_TYPE_ERROR);\r\n                            return;\r\n                        }\r\n                        task = Tasks.withdrawAll(request.target);\r\n                    }\r\n                    else {\r\n                        task = Tasks.withdraw(request.target, request.resourceType);\r\n                    }\r\n                }\r\n                if (task && bestChoice.targetRef != request.target.ref) {\r\n                    // If we need to go to a buffer first to deposit stuff\r\n                    const buffer = deref(bestChoice.targetRef);\r\n                    task = task.fork(Tasks.transferAll(buffer));\r\n                }\r\n            }\r\n            else {\r\n                // console.log(`${transporter.name} chooses a store with 0 amount!`);\r\n                transporter.park();\r\n            }\r\n            // Assign the task to the transporter\r\n            transporter.task = task;\r\n            this.colony.logisticsNetwork.invalidateCache(transporter, request);\r\n        }\r\n        else {\r\n            // If nothing to do, put everything in a store structure\r\n            if (_.sum(transporter.carry) > 0) {\r\n                if (transporter.hasMineralsInCarry) {\r\n                    const target = this.colony.terminal || this.colony.storage;\r\n                    if (target) {\r\n                        transporter.task = Tasks.transferAll(target);\r\n                    }\r\n                }\r\n                else {\r\n                    const dropoffPoints = _.compact([this.colony.storage]);\r\n                    // , ...this.colony.dropoffLinks]);\r\n                    // let bestDropoffPoint = minBy(dropoffPoints, function(dropoff: StructureLink | StructureStorage) {\r\n                    // \tlet range = transporter.pos.getMultiRoomRangeTo(dropoff.pos);\r\n                    // \tif (dropoff instanceof StructureLink) {\r\n                    // \t\treturn Math.max(range, this.colony.linkNetwork.getDropoffAvailability(dropoff));\r\n                    // \t} else {\r\n                    // \t\treturn range;\r\n                    // \t}\r\n                    // });\r\n                    const bestDropoffPoint = transporter.pos.findClosestByMultiRoomRange(dropoffPoints);\r\n                    if (bestDropoffPoint)\r\n                        transporter.task = Tasks.transfer(bestDropoffPoint);\r\n                }\r\n            }\r\n            else {\r\n                let parkingSpot = transporter.pos;\r\n                if (this.colony.storage) {\r\n                    parkingSpot = this.colony.storage.pos;\r\n                }\r\n                else if (this.colony.roomPlanner.storagePos) {\r\n                    parkingSpot = this.colony.roomPlanner.storagePos;\r\n                }\r\n                transporter.park(parkingSpot);\r\n            }\r\n        }\r\n        // console.log(JSON.stringify(transporter.memory.task));\r\n    }\r\n    handleBigTransporter(bigTransporter) {\r\n        const bestRequestViaStableMatching = this.colony.logisticsNetwork.matching[bigTransporter.name];\r\n        this.handleTransporter(bigTransporter, bestRequestViaStableMatching);\r\n    }\r\n    /* Handles small transporters, which don't do well with the logisticsNetwork's stable matching system */\r\n    handleSmolTransporter(smolTransporter) {\r\n        // Just perform a single-sided greedy selection of all requests\r\n        const bestRequestViaGreedy = _.first(this.colony.logisticsNetwork.transporterPreferences(smolTransporter));\r\n        this.handleTransporter(smolTransporter, bestRequestViaGreedy);\r\n    }\r\n    pickupDroppedResources(transporter) {\r\n        const droppedResource = transporter.pos.lookFor(LOOK_RESOURCES)[0];\r\n        if (droppedResource) {\r\n            transporter.pickup(droppedResource);\r\n            return;\r\n        }\r\n        const tombstone = transporter.pos.lookFor(LOOK_TOMBSTONES)[0];\r\n        if (tombstone) {\r\n            const resourceType = _.last(_.sortBy(_.keys(tombstone.store), resourceType => (tombstone.store[resourceType] || 0)));\r\n            transporter.withdraw(tombstone, resourceType);\r\n        }\r\n    }\r\n    run() {\r\n        this.autoRun(this.transporters, transporter => this.handleSmolTransporter(transporter));\r\n    }\r\n};\r\nTransportOverlord = tslib_1.__decorate([\r\n    profile\r\n], TransportOverlord);\r\nexport { TransportOverlord };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/logistics/LogisticsNetwork.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/tasks/Tasks.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/overlords/Overlord.ts"]}
