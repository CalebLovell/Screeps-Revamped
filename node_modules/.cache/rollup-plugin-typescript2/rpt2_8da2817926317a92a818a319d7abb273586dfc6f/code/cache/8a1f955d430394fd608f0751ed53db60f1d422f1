{"code":"import { Cartographer } from '../utilities/Cartographer';\r\nimport { minBy, mod } from '../utilities/utils';\r\nObject.defineProperty(RoomPosition.prototype, 'print', {\r\n    get() {\r\n        return '<a href=\"#!/room/' + Game.shard.name + '/' + this.roomName + '\">[' + this.roomName + ', ' + this.x +\r\n            ', ' + this.y + ']</a>';\r\n    },\r\n    configurable: true,\r\n});\r\nObject.defineProperty(RoomPosition.prototype, 'printPlain', {\r\n    get() {\r\n        return `[${this.roomName}, ${this.x}, ${this.y}]`;\r\n    },\r\n    configurable: true,\r\n});\r\nObject.defineProperty(RoomPosition.prototype, 'room', {\r\n    get: function () {\r\n        return Game.rooms[this.roomName];\r\n    },\r\n    configurable: true,\r\n});\r\nObject.defineProperty(RoomPosition.prototype, 'name', {\r\n    get: function () {\r\n        return this.roomName + ':' + this.x + ':' + this.y;\r\n    },\r\n    configurable: true,\r\n});\r\nObject.defineProperty(RoomPosition.prototype, 'coordName', {\r\n    get: function () {\r\n        return this.x + ':' + this.y;\r\n    },\r\n    configurable: true,\r\n});\r\nRoomPosition.prototype.lookForStructure = function (structureType) {\r\n    return _.find(this.lookFor(LOOK_STRUCTURES), s => s.structureType === structureType);\r\n};\r\nRoomPosition.prototype.getOffsetPos = function (dx, dy) {\r\n    let roomName = this.roomName;\r\n    let x = this.x + dx;\r\n    if (x < 0 || x > 49) {\r\n        const dxRoom = Math.floor(x / 50);\r\n        x = mod(x, 50);\r\n        roomName = Cartographer.findRelativeRoomName(roomName, dxRoom, 0);\r\n    }\r\n    let y = this.y + dy;\r\n    if (y < 0 || y > 49) {\r\n        const dyRoom = Math.floor(y / 50);\r\n        y = mod(y, 50);\r\n        roomName = Cartographer.findRelativeRoomName(roomName, 0, dyRoom);\r\n    }\r\n    return new RoomPosition(x, y, roomName);\r\n};\r\n// RoomPosition.prototype.findInRange_fast = function<T extends HasPos>(objects: T[], range: number): T[] {\r\n// \treturn _.filter(objects, o => this.inRangeToXY(o.pos.x, o.pos.y, range));\r\n// }\r\nObject.defineProperty(RoomPosition.prototype, 'isEdge', {\r\n    get: function () {\r\n        return this.x === 0 || this.x === 49 || this.y === 0 || this.y === 49;\r\n    },\r\n    configurable: true,\r\n});\r\nObject.defineProperty(RoomPosition.prototype, 'isVisible', {\r\n    get: function () {\r\n        return Game.rooms[this.roomName] != undefined;\r\n    },\r\n    configurable: true,\r\n});\r\nObject.defineProperty(RoomPosition.prototype, 'rangeToEdge', {\r\n    get: function () {\r\n        return _.min([this.x, 49 - this.x, this.y, 49 - this.y]);\r\n    },\r\n    configurable: true,\r\n});\r\nObject.defineProperty(RoomPosition.prototype, 'roomCoords', {\r\n    get: function () {\r\n        const parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(this.roomName);\r\n        let x = parseInt(parsed[1], 10);\r\n        let y = parseInt(parsed[2], 10);\r\n        if (this.roomName.includes('W'))\r\n            x = -x;\r\n        if (this.roomName.includes('N'))\r\n            y = -y;\r\n        return { x: x, y: y };\r\n    },\r\n    configurable: true,\r\n});\r\nObject.defineProperty(RoomPosition.prototype, 'neighbors', {\r\n    get: function () {\r\n        const adjPos = [];\r\n        for (const dx of [-1, 0, 1]) {\r\n            for (const dy of [-1, 0, 1]) {\r\n                if (!(dx == 0 && dy == 0)) {\r\n                    const x = this.x + dx;\r\n                    const y = this.y + dy;\r\n                    if (0 < x && x < 49 && 0 < y && y < 49) {\r\n                        adjPos.push(new RoomPosition(x, y, this.roomName));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return adjPos;\r\n    },\r\n    configurable: true,\r\n});\r\nRoomPosition.prototype.inRangeToPos = function (pos, range) {\r\n    return this.roomName === pos.roomName &&\r\n        ((pos.x - this.x) < 0 ? (this.x - pos.x) : (pos.x - this.x)) <= range &&\r\n        ((pos.y - this.y) < 0 ? (this.y - pos.y) : (pos.y - this.y)) <= range;\r\n};\r\nRoomPosition.prototype.inRangeToXY = function (x, y, range) {\r\n    return ((x - this.x) < 0 ? (this.x - x) : (x - this.x)) <= range\r\n        && ((y - this.y) < 0 ? (this.y - y) : (y - this.y)) <= range;\r\n};\r\nRoomPosition.prototype.getRangeToXY = function (x, y) {\r\n    return Math.max((x - this.x) < 0 ? (this.x - x) : (x - this.x), ((y - this.y) < 0 ? (this.y - y) : (y - this.y)));\r\n};\r\nRoomPosition.prototype.getPositionsInRange = function (range, includeWalls = false, includeEdges = false) {\r\n    const terrain = Game.map.getRoomTerrain(this.roomName);\r\n    const adjPos = [];\r\n    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];\r\n    const [ymin, ymax] = includeEdges ? [0, 49] : [1, 48];\r\n    for (let dx = -1 * range; dx <= range; dx++) {\r\n        for (let dy = -1 * range; dy <= range; dy++) {\r\n            const x = this.x + dx;\r\n            const y = this.y + dy;\r\n            if (xmin <= x && x <= xmax && xmin <= y && y <= xmax) {\r\n                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {\r\n                    adjPos.push(new RoomPosition(x, y, this.roomName));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return adjPos;\r\n};\r\nRoomPosition.prototype.getPositionsAtRange = function (range, includeWalls = false, includeEdges = false) {\r\n    const terrain = Game.map.getRoomTerrain(this.roomName);\r\n    const adjPos = [];\r\n    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];\r\n    const [ymin, ymax] = includeEdges ? [0, 49] : [1, 48];\r\n    for (let dx = -1 * range; dx <= range; dx++) {\r\n        for (let dy = -1 * range; dy <= range; dy++) {\r\n            if (Math.max(Math.abs(dx), Math.abs(dy)) < range) {\r\n                continue;\r\n            }\r\n            const x = this.x + dx;\r\n            const y = this.y + dy;\r\n            if (xmin <= x && x <= xmax && xmin <= y && y <= xmax) {\r\n                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {\r\n                    adjPos.push(new RoomPosition(x, y, this.roomName));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return adjPos;\r\n};\r\nRoomPosition.prototype.isWalkable = function (ignoreCreeps = false) {\r\n    // Is terrain passable?\r\n    if (Game.map.getRoomTerrain(this.roomName).get(this.x, this.y) == TERRAIN_MASK_WALL)\r\n        return false;\r\n    if (this.isVisible) {\r\n        // Are there creeps?\r\n        if (ignoreCreeps == false && this.lookFor(LOOK_CREEPS).length > 0)\r\n            return false;\r\n        // Are there structures?\r\n        if (_.filter(this.lookFor(LOOK_STRUCTURES), (s) => !s.isWalkable).length > 0)\r\n            return false;\r\n    }\r\n    return true;\r\n};\r\nRoomPosition.prototype.availableNeighbors = function (ignoreCreeps = false) {\r\n    return _.filter(this.neighbors, pos => pos.isWalkable(ignoreCreeps));\r\n};\r\nRoomPosition.prototype.getPositionAtDirection = function (direction, range = 1) {\r\n    let dx = 0;\r\n    let dy = 0;\r\n    switch (direction) {\r\n        case 1:\r\n            dy = -range;\r\n            break;\r\n        case 2:\r\n            dy = -range;\r\n            dx = range;\r\n            break;\r\n        case 3:\r\n            dx = range;\r\n            break;\r\n        case 4:\r\n            dx = range;\r\n            dy = range;\r\n            break;\r\n        case 5:\r\n            dy = range;\r\n            break;\r\n        case 6:\r\n            dy = range;\r\n            dx = -range;\r\n            break;\r\n        case 7:\r\n            dx = -range;\r\n            break;\r\n        case 8:\r\n            dx = -range;\r\n            dy = -range;\r\n            break;\r\n    }\r\n    return this.getOffsetPos(dx, dy);\r\n};\r\n// Object.defineProperty(RoomPosition.prototype, 'availableAdjacentSpots', {\r\n// \tget: function () {\r\n// \t\tif (this.isVisible) {\r\n// \t\t\tlet spots: RoomPosition[] = [];\r\n// \t\t\tfor (let spot of this.adjacentSpots) {\r\n// \t\t\t\tlet structures = this.look;\r\n// \t\t\t\tif (Game.map.getTerrainAt(neighbor) != 'wall') {\r\n// \t\t\t\t\t// Doesn't include constructed walls\r\n// \t\t\t\t\tspots.push(neighbor);\r\n// \t\t\t\t}\r\n// \t\t\t}\r\n// \t\t\treturn spots;\r\n// \t\t} else {\r\n// \t\t\treturn this.adjacentSpots; // Assume there's nothing there\r\n// \t\t}\r\n// \t}\r\n// });\r\n// Get an estimate for the distance to another room position in a possibly different room\r\nRoomPosition.prototype.getMultiRoomRangeTo = function (pos) {\r\n    if (this.roomName == pos.roomName) {\r\n        return this.getRangeTo(pos);\r\n    }\r\n    else {\r\n        const from = this.roomCoords;\r\n        const to = pos.roomCoords;\r\n        const dx = Math.abs(50 * (to.x - from.x) + pos.x - this.x);\r\n        const dy = Math.abs(50 * (to.y - from.y) + pos.y - this.y);\r\n        return _.max([dx, dy]);\r\n    }\r\n};\r\nRoomPosition.prototype.findClosestByLimitedRange = function (objects, rangeLimit, opts) {\r\n    const objectsInRange = this.findInRange(objects, rangeLimit, opts);\r\n    return this.findClosestByRange(objectsInRange, opts);\r\n};\r\nRoomPosition.prototype.findClosestByMultiRoomRange = function (objects) {\r\n    return minBy(objects, (obj) => this.getMultiRoomRangeTo(obj.pos));\r\n};\r\n// This should only be used within a single room\r\nRoomPosition.prototype.findClosestByRangeThenPath = function (objects) {\r\n    const distances = _.map(objects, obj => this.getRangeTo(obj));\r\n    const minDistance = _.min(distances);\r\n    if (minDistance > 4) {\r\n        return this.findClosestByRange(objects);\r\n    }\r\n    else {\r\n        const closestObjects = _.filter(objects, obj => this.getRangeTo(obj) == minDistance);\r\n        return this.findClosestByPath(closestObjects); // don't clutter up pathing.distance cached values\r\n    }\r\n};\r\n","references":["C:/git/Overmind/src/utilities/Cartographer.ts","C:/git/Overmind/src/utilities/utils.ts"]}
