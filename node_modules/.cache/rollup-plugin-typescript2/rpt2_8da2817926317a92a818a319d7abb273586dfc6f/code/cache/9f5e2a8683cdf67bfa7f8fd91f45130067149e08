{"code":"import * as tslib_1 from \"tslib\";\r\nimport { profile } from '../profiler/decorator';\r\n/* Return the cost of an entire array of body parts */\r\nexport function bodyCost(bodyparts) {\r\n    return _.sum(bodyparts, part => BODYPART_COST[part]);\r\n}\r\nexport function patternCost(setup) {\r\n    return bodyCost(setup.bodySetup.pattern);\r\n}\r\n/**\r\n * The CreepSetup class contains methods for flexibly generating creep body arrays when needed for spawning\r\n */\r\nlet CreepSetup = class CreepSetup {\r\n    constructor(roleName, bodySetup = {}) {\r\n        this.role = roleName;\r\n        // Defaults for a creep setup\r\n        _.defaults(bodySetup, {\r\n            pattern: [],\r\n            sizeLimit: Infinity,\r\n            prefix: [],\r\n            suffix: [],\r\n            proportionalPrefixSuffix: false,\r\n            ordered: true,\r\n        });\r\n        this.bodySetup = bodySetup;\r\n    }\r\n    /* Generate the largest body of a given pattern that is producable from a room,\r\n     * subject to limitations from maxRepeats */\r\n    generateBody(availableEnergy) {\r\n        let patternCost, patternLength, numRepeats;\r\n        const prefix = this.bodySetup.prefix;\r\n        const suffix = this.bodySetup.suffix;\r\n        let body = [];\r\n        // calculate repetitions\r\n        if (this.bodySetup.proportionalPrefixSuffix) { // if prefix and suffix are to be kept proportional to body size\r\n            patternCost = bodyCost(prefix) + bodyCost(this.bodySetup.pattern) + bodyCost(suffix);\r\n            patternLength = prefix.length + this.bodySetup.pattern.length + suffix.length;\r\n            const energyLimit = Math.floor(availableEnergy / patternCost); // max number of repeats room can produce\r\n            const maxPartLimit = Math.floor(MAX_CREEP_SIZE / patternLength); // max repetitions resulting in <50 parts\r\n            numRepeats = Math.min(energyLimit, maxPartLimit, this.bodySetup.sizeLimit);\r\n        }\r\n        else { // if prefix and suffix don't scale\r\n            const extraCost = bodyCost(prefix) + bodyCost(suffix);\r\n            patternCost = bodyCost(this.bodySetup.pattern);\r\n            patternLength = this.bodySetup.pattern.length;\r\n            const energyLimit = Math.floor((availableEnergy - extraCost) / patternCost);\r\n            const maxPartLimit = Math.floor((MAX_CREEP_SIZE - prefix.length - suffix.length) / patternLength);\r\n            numRepeats = Math.min(energyLimit, maxPartLimit, this.bodySetup.sizeLimit);\r\n        }\r\n        // build the body\r\n        if (this.bodySetup.proportionalPrefixSuffix) { // add the prefix\r\n            for (let i = 0; i < numRepeats; i++) {\r\n                body = body.concat(prefix);\r\n            }\r\n        }\r\n        else {\r\n            body = body.concat(prefix);\r\n        }\r\n        if (this.bodySetup.ordered) { // repeated body pattern\r\n            for (const part of this.bodySetup.pattern) {\r\n                for (let i = 0; i < numRepeats; i++) {\r\n                    body.push(part);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < numRepeats; i++) {\r\n                body = body.concat(this.bodySetup.pattern);\r\n            }\r\n        }\r\n        if (this.bodySetup.proportionalPrefixSuffix) { // add the suffix\r\n            for (let i = 0; i < numRepeats; i++) {\r\n                body = body.concat(suffix);\r\n            }\r\n        }\r\n        else {\r\n            body = body.concat(suffix);\r\n        }\r\n        // return it\r\n        return body;\r\n    }\r\n    getBodyPotential(partType, colony) {\r\n        // let energyCapacity = Math.max(colony.room.energyCapacityAvailable,\r\n        // \t\t\t\t\t\t\t  colony.incubator ? colony.incubator.room.energyCapacityAvailable : 0);\r\n        let energyCapacity = colony.room.energyCapacityAvailable;\r\n        if (colony.spawnGroup) {\r\n            const colonies = _.compact(_.map(colony.spawnGroup.memory.colonies, name => Overmind.colonies[name]));\r\n            energyCapacity = _.max(_.map(colonies, colony => colony.room.energyCapacityAvailable));\r\n        }\r\n        const body = this.generateBody(energyCapacity);\r\n        return _.filter(body, (part) => part == partType).length;\r\n    }\r\n};\r\nCreepSetup = tslib_1.__decorate([\r\n    profile\r\n], CreepSetup);\r\nexport { CreepSetup };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/profiler/decorator.ts"]}
