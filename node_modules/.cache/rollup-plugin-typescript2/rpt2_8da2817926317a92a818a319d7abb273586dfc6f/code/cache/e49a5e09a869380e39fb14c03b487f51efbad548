{"code":"import * as tslib_1 from \"tslib\";\r\nimport { log } from '../console/log';\r\nimport { isCombatZerg } from '../declarations/typeGuards';\r\nimport { CombatIntel } from '../intel/CombatIntel';\r\nimport { RoomIntel } from '../intel/RoomIntel';\r\nimport { profile } from '../profiler/decorator';\r\nimport { maxBy, minBy } from '../utilities/utils';\r\nimport { Swarm } from '../zerg/Swarm';\r\nconst DEBUG = false;\r\nlet GoalFinder = class GoalFinder {\r\n    // Standard set of goals for fighting small groups of hostiles (not optimal for larger fights)\r\n    static skirmishGoals(creep) {\r\n        const approach = [];\r\n        const avoid = [];\r\n        const room = creep.room;\r\n        const analysis = {};\r\n        const myAttack = CombatIntel.getAttackDamage(creep);\r\n        const myRangedAttack = CombatIntel.getRangedAttackDamage(creep);\r\n        const myHealing = CombatIntel.getHealAmount(creep);\r\n        // If you're purely a healer, ignore combat goals\r\n        if (myHealing > 0 && myAttack == 0 && myRangedAttack == 0) {\r\n            return this.healingGoals(creep);\r\n        }\r\n        const preferCloseCombat = myAttack > 0;\r\n        const myRating = CombatIntel.rating(creep);\r\n        const nearbyRating = _.sum(creep.pos.findInRange(room.creeps, 6), c => CombatIntel.rating(c));\r\n        const braveMode = creep.hits * (nearbyRating / myRating) * .5 > creep.hitsMax;\r\n        const hostileHealers = [];\r\n        // Analyze capabilities of hostile creeps in the room\r\n        for (const hostile of room.hostiles) {\r\n            if (hostile.owner.username == 'Source Keeper')\r\n                continue;\r\n            const attack = CombatIntel.getAttackDamage(hostile);\r\n            const rangedAttack = CombatIntel.getRangedAttackDamage(hostile);\r\n            const healing = CombatIntel.getHealAmount(hostile);\r\n            if (healing > 0 && attack == 0 && rangedAttack == 0) {\r\n                hostileHealers.push(hostile);\r\n            }\r\n            analysis[hostile.id] = {\r\n                attack: attack,\r\n                rangedAttack: rangedAttack,\r\n                heal: healing,\r\n                advantage: healing == 0 || attack + rangedAttack == 0 ||\r\n                    myAttack + myRangedAttack + myHealing / CombatIntel.minimumDamageTakenMultiplier(creep.creep)\r\n                        > attack + rangedAttack + healing / CombatIntel.minimumDamageTakenMultiplier(hostile),\r\n                isRetreating: CombatIntel.isRetreating(hostile, RoomIntel.getPreviousPos(creep)),\r\n                isApproaching: CombatIntel.isApproaching(hostile, RoomIntel.getPreviousPos(creep)),\r\n            };\r\n        }\r\n        // Generate list of targets to approach and respective ranges to keep them at\r\n        const approachTargets = hostileHealers.length > 0 ? hostileHealers : room.hostiles;\r\n        for (const target of approachTargets) {\r\n            const data = analysis[target.id];\r\n            if (data && (data.advantage || braveMode)) {\r\n                let range = 1;\r\n                if (!preferCloseCombat && (data.attack > 0 || data.rangedAttack > myRangedAttack)) {\r\n                    range = creep.pos.getRangeTo(target) == 3 && data.isRetreating ? 2 : 3;\r\n                    avoid.push({ pos: target.pos, range: range });\r\n                }\r\n                approach.push({ pos: target.pos, range: range });\r\n            }\r\n        }\r\n        // If there's nothing left to approach, group up with other creeps\r\n        if (approach.length == 0) {\r\n            for (const friendly of room.creeps) {\r\n                approach.push({ pos: friendly.pos, range: 0 });\r\n            }\r\n        }\r\n        // Avoid hostiles that are significantly better than you\r\n        for (const target of room.hostiles) {\r\n            const data = analysis[target.id];\r\n            if (data && (!data.advantage && !braveMode)) {\r\n                let range = data.isApproaching ? 3 : 2;\r\n                if (data.rangedAttack > 0) {\r\n                    range = 8;\r\n                }\r\n                avoid.push({ pos: target.pos, range: range });\r\n            }\r\n        }\r\n        if (DEBUG) {\r\n            log.debug(`Report for ${creep.name}:`, JSON.stringify(analysis));\r\n            log.debug(`Approach for ${creep.name}:`, JSON.stringify(approach));\r\n            log.debug(`Avoid for ${creep.name}:`, JSON.stringify(avoid));\r\n        }\r\n        return { approach, avoid };\r\n    }\r\n    static swarmCombatGoals(swarm, includeStructures = true) {\r\n        const approach = [];\r\n        const avoid = [];\r\n        if (swarm.rooms.length > 1) {\r\n            log.warning(`Swarm in more than 1 room!`);\r\n        }\r\n        // If in more than 1 room, pick the room with more hostile stuff in it\r\n        const room = maxBy(swarm.rooms, room => room.hostiles.length + room.hostileStructures.length);\r\n        const myAttack = _.sum(swarm.creeps, creep => CombatIntel.getAttackDamage(creep));\r\n        const myRangedAttack = _.sum(swarm.creeps, creep => CombatIntel.getRangedAttackDamage(creep));\r\n        const myHealing = _.sum(swarm.creeps, creep => CombatIntel.getHealAmount(creep));\r\n        const myDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(_.map(swarm.creeps, c => c.creep));\r\n        const preferCloseCombat = myAttack > myRangedAttack;\r\n        const myRating = _.sum(swarm.creeps, creep => CombatIntel.rating(creep));\r\n        const hostileSwarms = Swarm.findEnemySwarms(room, { pos: swarm.anchor });\r\n        // Analyze capabilities of hostile creeps in the room\r\n        for (const i in hostileSwarms) {\r\n            const hostiles = hostileSwarms[i].creeps;\r\n            const attack = _.sum(hostiles, creep => CombatIntel.getAttackDamage(creep));\r\n            const rangedAttack = _.sum(hostiles, creep => CombatIntel.getRangedAttackDamage(creep));\r\n            const healing = _.sum(hostiles, creep => CombatIntel.getHealAmount(creep));\r\n            const damageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(hostiles);\r\n            const canPopShield = (attack + rangedAttack + CombatIntel.towerDamageAtPos(swarm.anchor)) * myDamageMultiplier\r\n                > _.min(_.map(swarm.creeps, creep => 100 * creep.getActiveBodyparts(TOUGH)));\r\n            const isRetreating = _.sum(hostiles, creep => +CombatIntel.isRetreating(creep, swarm.anchor))\r\n                / hostiles.length >= 0.5;\r\n            const isApproaching = _.sum(hostiles, creep => +CombatIntel.isApproaching(creep, swarm.anchor))\r\n                / hostiles.length >= 0.5;\r\n            const advantage = healing == 0 || attack + rangedAttack == 0 ||\r\n                myAttack + myRangedAttack + myHealing / myDamageMultiplier\r\n                    > attack + rangedAttack + healing / damageMultiplier;\r\n            for (const hostile of hostiles) {\r\n                if (canPopShield && hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {\r\n                    let range = (rangedAttack > attack || !preferCloseCombat ? 3 : 1) + 1;\r\n                    if (CombatIntel.isApproaching(hostile, swarm.anchor)) {\r\n                        range += 1;\r\n                    }\r\n                    avoid.push({ pos: hostile.pos, range: range });\r\n                }\r\n                else {\r\n                    if (advantage) {\r\n                        let range = preferCloseCombat ? 3 : 1;\r\n                        if (!preferCloseCombat && (attack > 0 || rangedAttack > myAttack)) {\r\n                            range = swarm.minRangeTo(hostile) == 3 && isRetreating ? 2 : 3;\r\n                            avoid.push({ pos: hostile.pos, range: range });\r\n                        }\r\n                        approach.push({ pos: hostile.pos, range: range });\r\n                    }\r\n                    else {\r\n                        let range = isApproaching ? 3 : 2;\r\n                        if (rangedAttack > attack) {\r\n                            range = 5;\r\n                        }\r\n                        avoid.push({ pos: hostile.pos, range: range });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (includeStructures) {\r\n            const approachStructures = [];\r\n            for (const structure of room.hostileStructures) {\r\n                approachStructures.push(structure);\r\n            }\r\n            for (const wall of room.walls) {\r\n                approachStructures.push(wall);\r\n            }\r\n            for (const approachStructure of approachStructures) {\r\n                approach.push({ pos: approachStructure.pos, range: 1 });\r\n            }\r\n        }\r\n        if (DEBUG) {\r\n            log.debug(`Approach for ${swarm.print}:`, JSON.stringify(approach));\r\n            log.debug(`Avoid for ${swarm.print}:`, JSON.stringify(avoid));\r\n        }\r\n        return { approach, avoid };\r\n    }\r\n    static retreatGoals(creep) {\r\n        const approach = [];\r\n        const avoid = [];\r\n        const isHealer = CombatIntel.isHealer(creep);\r\n        for (const friendly of creep.room.creeps) {\r\n            if (CombatIntel.getHealPotential(friendly) > 0 || (isHealer && isCombatZerg(creep))) {\r\n                approach.push({ pos: friendly.pos, range: 1 });\r\n            }\r\n        }\r\n        for (const hostile of creep.room.hostiles) {\r\n            if (CombatIntel.getAttackPotential(hostile) > 0 || CombatIntel.getRangedAttackPotential(hostile) > 0) {\r\n                avoid.push({ pos: hostile.pos, range: 8 });\r\n            }\r\n        }\r\n        if (creep.room.owner && !creep.room.my) {\r\n            for (const tower of creep.room.towers) {\r\n                avoid.push({ pos: tower.pos, range: 50 });\r\n            }\r\n        }\r\n        return { approach, avoid };\r\n    }\r\n    static retreatGoalsForRoom(room) {\r\n        const avoid = [];\r\n        for (const hostile of room.hostiles) {\r\n            if (CombatIntel.getAttackPotential(hostile) > 0 || CombatIntel.getRangedAttackPotential(hostile) > 0) {\r\n                avoid.push({ pos: hostile.pos, range: 8 });\r\n            }\r\n        }\r\n        if (room.owner && !room.my) {\r\n            for (const tower of room.towers) {\r\n                avoid.push({ pos: tower.pos, range: 50 });\r\n            }\r\n        }\r\n        return { approach: [], avoid: avoid };\r\n    }\r\n    static healingGoals(healer) {\r\n        const approach = [];\r\n        const avoid = [];\r\n        const healAmount = CombatIntel.getHealAmount(healer);\r\n        let target = minBy(_.filter(healer.room.creeps, c => c.hits < c.hitsMax), c => c.hits + healer.pos.getRangeTo(c));\r\n        if (!target) {\r\n            target = minBy(healer.room.creeps, creep => {\r\n                const range = healer.pos.getRangeTo(creep);\r\n                return range > 0 ? CombatIntel.maxFriendlyHealingTo(creep) / healAmount + range : false;\r\n            });\r\n        }\r\n        if (target) {\r\n            approach.push({ pos: target.pos, range: 0 });\r\n        }\r\n        for (const hostile of healer.room.hostiles) {\r\n            const meleeDamage = CombatIntel.getAttackDamage(hostile);\r\n            const rangedDamage = CombatIntel.getRangedAttackDamage(hostile);\r\n            if (meleeDamage + rangedDamage > 0) {\r\n                const range = rangedDamage > healAmount ? 4 : 3;\r\n                avoid.push({ pos: hostile.pos, range: range });\r\n            }\r\n        }\r\n        return { approach, avoid };\r\n    }\r\n    static structureGoals(creep) {\r\n        const approach = [];\r\n        // // TODO: finish this\r\n        // let range = CombatIntel.getAttackDamage(creep) > 0 || CombatIntel.getDismantleDamage(creep) > 0 ? 1 : 3;\r\n        // let structureTarget = CombatTargeting.findBestStructureTarget(creep);\r\n        // if (structureTarget) {\r\n        // \tapproach.push({pos: structureTarget.pos, range: range});\r\n        // }\r\n        log.error(`NOT IMPLEMENTED`);\r\n        return { approach: approach, avoid: [] };\r\n    }\r\n};\r\nGoalFinder = tslib_1.__decorate([\r\n    profile\r\n], GoalFinder);\r\nexport { GoalFinder };\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/intel/CombatIntel.ts","C:/git/Overmind/src/intel/RoomIntel.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/zerg/CombatZerg.ts","C:/git/Overmind/src/zerg/Swarm.ts"]}
