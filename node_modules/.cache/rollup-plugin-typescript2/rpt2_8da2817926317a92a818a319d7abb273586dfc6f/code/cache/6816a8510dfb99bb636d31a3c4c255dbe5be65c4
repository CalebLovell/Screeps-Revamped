{"code":"import * as tslib_1 from \"tslib\";\r\nvar BootstrappingOverlord_1;\r\nimport { ColonyStage } from '../../Colony';\r\nimport { Roles, Setups } from '../../creepSetups/setups';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { Tasks } from '../../tasks/Tasks';\r\nimport { Overlord } from '../Overlord';\r\n/**\r\n * Bootstrapping overlord: spawns small miners and suppliers to recover from a catastrohpic colony crash\r\n */\r\nlet BootstrappingOverlord = BootstrappingOverlord_1 = class BootstrappingOverlord extends Overlord {\r\n    constructor(directive, priority = OverlordPriority.emergency.bootstrap) {\r\n        super(directive, 'bootstrap', priority);\r\n        this.fillers = this.zerg(Roles.filler);\r\n        // Calculate structures fillers can supply / withdraw from\r\n        this.supplyStructures = _.filter([...this.colony.spawns, ...this.colony.extensions], structure => structure.energy < structure.energyCapacity);\r\n        this.withdrawStructures = _.filter(_.compact([this.colony.storage,\r\n            this.colony.terminal,\r\n            this.colony.powerSpawn,\r\n            ...this.room.containers,\r\n            ...this.room.links,\r\n            ...this.room.towers,\r\n            ...this.room.labs]), structure => structure.energy > 0);\r\n    }\r\n    spawnBootstrapMiners() {\r\n        // Isolate mining site overlords in the room\r\n        let miningSites = _.filter(_.values(this.colony.miningSites), (site) => site.room == this.colony.room);\r\n        if (this.colony.spawns[0]) {\r\n            miningSites = _.sortBy(miningSites, site => site.pos.getRangeTo(this.colony.spawns[0]));\r\n        }\r\n        const miningOverlords = _.map(miningSites, site => site.overlords.mine);\r\n        // Create a bootstrapMiners and donate them to the miningSite overlords as needed\r\n        for (const overlord of miningOverlords) {\r\n            const filteredMiners = this.lifetimeFilter(overlord.miners);\r\n            const miningPowerAssigned = _.sum(_.map(this.lifetimeFilter(overlord.miners), creep => creep.getActiveBodyparts(WORK)));\r\n            if (miningPowerAssigned < overlord.miningPowerNeeded &&\r\n                filteredMiners.length < overlord.pos.availableNeighbors().length) {\r\n                if (this.colony.hatchery) {\r\n                    const request = {\r\n                        setup: Setups.drones.miners.emergency,\r\n                        overlord: overlord,\r\n                        priority: this.priority + 1,\r\n                    };\r\n                    this.colony.hatchery.enqueue(request);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    init() {\r\n        // At early levels, spawn one miner, then a filler, then the rest of the miners\r\n        if (this.colony.stage == ColonyStage.Larva) {\r\n            if (this.colony.getCreepsByRole(Roles.drone).length == 0) {\r\n                this.spawnBootstrapMiners();\r\n                return;\r\n            }\r\n        }\r\n        // Spawn fillers\r\n        if (this.colony.getCreepsByRole(Roles.queen).length == 0 && this.colony.hatchery) { // no queen\r\n            const transporter = _.first(this.colony.getZergByRole(Roles.transport));\r\n            if (transporter) {\r\n                // reassign transporter to be queen\r\n                transporter.reassign(this.colony.hatchery.overlord, Roles.queen);\r\n            }\r\n            else {\r\n                // wish for a filler\r\n                this.wishlist(1, Setups.filler);\r\n            }\r\n        }\r\n        // Then spawn the rest of the needed miners\r\n        const energyInStructures = _.sum(_.map(this.withdrawStructures, structure => structure.energy));\r\n        const droppedEnergy = _.sum(this.room.droppedEnergy, drop => drop.amount);\r\n        if (energyInStructures + droppedEnergy < BootstrappingOverlord_1.settings.spawnBootstrapMinerThreshold) {\r\n            this.spawnBootstrapMiners();\r\n        }\r\n    }\r\n    supplyActions(filler) {\r\n        const target = filler.pos.findClosestByRange(this.supplyStructures);\r\n        if (target) {\r\n            filler.task = Tasks.transfer(target);\r\n        }\r\n        else {\r\n            this.rechargeActions(filler);\r\n        }\r\n    }\r\n    rechargeActions(filler) {\r\n        const target = filler.pos.findClosestByRange(this.withdrawStructures);\r\n        if (target) {\r\n            filler.task = Tasks.withdraw(target);\r\n        }\r\n        else {\r\n            filler.task = Tasks.recharge();\r\n        }\r\n    }\r\n    handleFiller(filler) {\r\n        if (filler.carry.energy > 0) {\r\n            this.supplyActions(filler);\r\n        }\r\n        else {\r\n            this.rechargeActions(filler);\r\n        }\r\n    }\r\n    run() {\r\n        for (const filler of this.fillers) {\r\n            if (filler.isIdle) {\r\n                this.handleFiller(filler);\r\n            }\r\n            filler.run();\r\n        }\r\n    }\r\n};\r\nBootstrappingOverlord.settings = {\r\n    spawnBootstrapMinerThreshold: 2500\r\n};\r\nBootstrappingOverlord = BootstrappingOverlord_1 = tslib_1.__decorate([\r\n    profile\r\n], BootstrappingOverlord);\r\nexport { BootstrappingOverlord };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/directives/resource/harvest.ts","C:/git/Overmind/src/directives/situational/bootstrap.ts","C:/git/Overmind/src/hiveClusters/hatchery.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/tasks/Tasks.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/overlords/Overlord.ts"]}
