{"code":"import * as tslib_1 from \"tslib\";\r\nimport { CombatIntel } from '../intel/CombatIntel';\r\nimport { Movement, NO_ACTION } from '../movement/Movement';\r\nimport { profile } from '../profiler/decorator';\r\nimport { insideBunkerBounds } from '../roomPlanner/layouts/bunker';\r\nimport { CombatTargeting } from '../targeting/CombatTargeting';\r\nimport { GoalFinder } from '../targeting/GoalFinder';\r\nimport { randomHex } from '../utilities/utils';\r\nimport { Zerg } from './Zerg';\r\nexport const DEFAULT_PARTNER_TICK_DIFFERENCE = 650;\r\nexport const DEFAULT_SWARM_TICK_DIFFERENCE = 500;\r\n/**\r\n * CombatZerg is an extension of the Zerg class which contains additional combat-related methods\r\n */\r\nlet CombatZerg = class CombatZerg extends Zerg {\r\n    constructor(creep, notifyWhenAttacked = true) {\r\n        super(creep, notifyWhenAttacked);\r\n        this.isCombatZerg = true;\r\n        _.defaults(this.memory, {\r\n            recovering: false,\r\n            lastInDanger: 0,\r\n            targets: {}\r\n        });\r\n    }\r\n    findPartner(partners, tickDifference = DEFAULT_PARTNER_TICK_DIFFERENCE) {\r\n        if (this.memory.partner) {\r\n            const partner = _.find(partners, partner => partner.name == this.memory.partner);\r\n            if (partner) {\r\n                return partner;\r\n            }\r\n            else {\r\n                delete this.memory.partner;\r\n                this.findPartner(partners, tickDifference);\r\n            }\r\n        }\r\n        else {\r\n            let partner = _.find(partners, partner => partner.memory.partner == this.name);\r\n            if (!partner) {\r\n                partner = _(partners)\r\n                    .filter(partner => !partner.memory.partner &&\r\n                    Math.abs((this.ticksToLive || CREEP_LIFE_TIME)\r\n                        - (partner.ticksToLive || CREEP_LIFE_TIME)) <= tickDifference)\r\n                    .min(partner => Math.abs((this.ticksToLive || CREEP_LIFE_TIME)\r\n                    - (partner.ticksToLive || CREEP_LIFE_TIME)));\r\n            }\r\n            if (_.isObject(partner)) {\r\n                this.memory.partner = partner.name;\r\n                partner.memory.partner = this.name;\r\n                return partner;\r\n            }\r\n        }\r\n    }\r\n    findSwarm(partners, maxByRole, tickDifference = DEFAULT_SWARM_TICK_DIFFERENCE) {\r\n        if (this.memory.swarm) {\r\n            return this.memory.swarm;\r\n        }\r\n        else {\r\n            // Find a swarm that isn't too old and that has space for the creep's role\r\n            const partnersBySwarm = _.groupBy(partners, partner => partner.memory.swarm);\r\n            for (const swarmRef in partnersBySwarm) {\r\n                if (swarmRef == undefined || swarmRef == 'undefined')\r\n                    continue;\r\n                if (_.all(partnersBySwarm[swarmRef], c => Math.abs((this.ticksToLive || CREEP_LIFE_TIME)\r\n                    - (c.ticksToLive || CREEP_LIFE_TIME)) <= tickDifference)) {\r\n                    const swarmCreepsByRole = _.groupBy(partnersBySwarm[swarmRef], c => c.memory.role);\r\n                    if ((swarmCreepsByRole[this.memory.role] || []).length + 1 <= maxByRole[this.memory.role]) {\r\n                        this.memory.swarm = swarmRef;\r\n                        return swarmRef;\r\n                    }\r\n                }\r\n            }\r\n            // Otherwise just make a new swarm ref\r\n            const newSwarmRef = randomHex(6);\r\n            this.memory.swarm = newSwarmRef;\r\n            return newSwarmRef;\r\n        }\r\n    }\r\n    doMedicActions(roomName) {\r\n        // Travel to the target room\r\n        if (!this.safelyInRoom(roomName)) {\r\n            this.goToRoom(roomName, { ensurePath: true });\r\n            return;\r\n        }\r\n        // Heal friendlies\r\n        const target = CombatTargeting.findClosestHurtFriendly(this);\r\n        if (target) {\r\n            // Approach the target\r\n            const range = this.pos.getRangeTo(target);\r\n            if (range > 1) {\r\n                this.goTo(target, { movingTarget: true });\r\n            }\r\n            // Heal or ranged-heal the target\r\n            if (range <= 1) {\r\n                this.heal(target);\r\n            }\r\n            else if (range <= 3) {\r\n                this.rangedHeal(target);\r\n            }\r\n        }\r\n        else {\r\n            this.park();\r\n        }\r\n    }\r\n    healSelfIfPossible() {\r\n        // Heal yourself if it won't interfere with attacking\r\n        if (this.canExecute('heal')\r\n            && (this.hits < this.hitsMax || this.pos.findInRange(this.room.hostiles, 3).length > 0)) {\r\n            return this.heal(this);\r\n        }\r\n    }\r\n    /**\r\n     * Attack and chase the specified target\r\n     */\r\n    attackAndChase(target) {\r\n        let ret;\r\n        // Attack the target if you can, else move to get in range\r\n        if (this.pos.isNearTo(target)) {\r\n            ret = this.attack(target);\r\n            // Move in the direction of the creep to prevent it from running away\r\n            this.move(this.pos.getDirectionTo(target));\r\n            return ret;\r\n        }\r\n        else {\r\n            if (this.pos.getRangeTo(target.pos) > 10 && target instanceof Creep) {\r\n                this.goTo(target, { movingTarget: true });\r\n            }\r\n            else {\r\n                this.goTo(target);\r\n            }\r\n            return ERR_NOT_IN_RANGE;\r\n        }\r\n    }\r\n    // Standard action sequences for engaging small numbers of enemies in a neutral room ===============================\r\n    /**\r\n     * Automatically melee-attack the best creep in range\r\n     */\r\n    autoMelee(possibleTargets = this.room.hostiles) {\r\n        const target = CombatTargeting.findBestCreepTargetInRange(this, 1, possibleTargets)\r\n            || CombatTargeting.findBestStructureTargetInRange(this, 1);\r\n        this.debug(`Melee target: ${target}`);\r\n        if (target) {\r\n            return this.attack(target);\r\n        }\r\n    }\r\n    /**\r\n     * Automatically ranged-attack the best creep in range\r\n     */\r\n    autoRanged(possibleTargets = this.room.hostiles, allowMassAttack = true) {\r\n        const target = CombatTargeting.findBestCreepTargetInRange(this, 3, possibleTargets)\r\n            || CombatTargeting.findBestStructureTargetInRange(this, 3);\r\n        this.debug(`Ranged target: ${target}`);\r\n        if (target) {\r\n            if (allowMassAttack\r\n                && CombatIntel.getMassAttackDamage(this, possibleTargets) > CombatIntel.getRangedAttackDamage(this)) {\r\n                return this.rangedMassAttack();\r\n            }\r\n            else {\r\n                return this.rangedAttack(target);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Automatically heal the best creep in range\r\n     */\r\n    autoHeal(allowRangedHeal = true, friendlies = this.room.creeps) {\r\n        const target = CombatTargeting.findBestHealingTargetInRange(this, allowRangedHeal ? 3 : 1, friendlies);\r\n        this.debug(`Heal taget: ${target}`);\r\n        if (target) {\r\n            if (this.pos.getRangeTo(target) <= 1) {\r\n                return this.heal(target);\r\n            }\r\n            else if (allowRangedHeal && this.pos.getRangeTo(target) <= 3) {\r\n                return this.rangedHeal(target);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Navigate to a room, then engage hostile creeps there, perform medic actions, etc.\r\n     */\r\n    autoSkirmish(roomName, verbose = false) {\r\n        // Do standard melee, ranged, and heal actions\r\n        if (this.getActiveBodyparts(ATTACK) > 0) {\r\n            this.autoMelee(); // Melee should be performed first\r\n        }\r\n        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {\r\n            this.autoRanged();\r\n        }\r\n        if (this.canExecute('heal')) {\r\n            this.autoHeal(this.canExecute('rangedHeal'));\r\n        }\r\n        // Handle recovery if low on HP\r\n        if (this.needsToRecover()) {\r\n            this.debug(`Recovering!`);\r\n            return this.recover();\r\n        }\r\n        // Travel to the target room\r\n        if (!this.safelyInRoom(roomName)) {\r\n            this.debug(`Going to room!`);\r\n            return this.goToRoom(roomName, { ensurePath: true });\r\n        }\r\n        // Skirmish within the room\r\n        const goals = GoalFinder.skirmishGoals(this);\r\n        this.debug(JSON.stringify(goals));\r\n        return Movement.combatMove(this, goals.approach, goals.avoid);\r\n    }\r\n    /**\r\n     * Navigate to a room, then engage hostile creeps there, perform medic actions, etc.\r\n     */\r\n    autoCombat(roomName, verbose = false) {\r\n        // Do standard melee, ranged, and heal actions\r\n        if (this.getActiveBodyparts(ATTACK) > 0) {\r\n            this.autoMelee(); // Melee should be performed first\r\n        }\r\n        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {\r\n            this.autoRanged();\r\n        }\r\n        if (this.canExecute('heal')) {\r\n            this.autoHeal(this.canExecute('rangedHeal'));\r\n        }\r\n        // Handle recovery if low on HP\r\n        if (this.needsToRecover()) {\r\n            this.debug(`Recovering!`);\r\n            return this.recover();\r\n        }\r\n        // Travel to the target room\r\n        if (!this.safelyInRoom(roomName)) {\r\n            this.debug(`Going to room!`);\r\n            return this.goToRoom(roomName, { ensurePath: true });\r\n        }\r\n        // Fight within the room\r\n        const target = CombatTargeting.findTarget(this);\r\n        const preferRanged = this.getActiveBodyparts(RANGED_ATTACK) > this.getActiveBodyparts(ATTACK);\r\n        const targetRange = preferRanged ? 3 : 1;\r\n        this.debug(`${target}, ${targetRange}`);\r\n        if (target) {\r\n            const avoid = [];\r\n            // Avoid melee hostiles if you are a ranged creep\r\n            if (preferRanged) {\r\n                const meleeHostiles = _.filter(this.room.hostiles, h => CombatIntel.getAttackDamage(h) > 0);\r\n                for (const hostile of meleeHostiles) {\r\n                    avoid.push({ pos: hostile.pos, range: 2 });\r\n                }\r\n            }\r\n            return Movement.combatMove(this, [{ pos: target.pos, range: targetRange }], []);\r\n        }\r\n    }\r\n    autoBunkerCombat(roomName, verbose = false) {\r\n        if (this.getActiveBodyparts(ATTACK) > 0) {\r\n            this.autoMelee(); // Melee should be performed first\r\n        }\r\n        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {\r\n            this.autoRanged();\r\n        }\r\n        // Travel to the target room\r\n        if (!this.safelyInRoom(roomName)) {\r\n            this.debug(`Going to room!`);\r\n            return this.goToRoom(roomName, { ensurePath: true });\r\n        }\r\n        // TODO check if right colony, also yes colony check is in there to stop red squigglies\r\n        const siegingCreeps = this.room.hostiles.filter(creep => _.any(creep.pos.neighbors, pos => this.colony && insideBunkerBounds(pos, this.colony)));\r\n        const target = CombatTargeting.findTarget(this, siegingCreeps);\r\n        if (target) {\r\n            return Movement.combatMove(this, [{ pos: target.pos, range: 1 }], [], { preferRamparts: true, requireRamparts: true });\r\n        }\r\n    }\r\n    needsToRecover(recoverThreshold = CombatIntel.minimumDamageTakenMultiplier(this.creep) < 1 ? 0.85 : 0.75, reengageThreshold = 1.0) {\r\n        let recovering;\r\n        if (this.memory.recovering) {\r\n            recovering = this.hits < this.hitsMax * reengageThreshold;\r\n        }\r\n        else {\r\n            recovering = this.hits < this.hitsMax * recoverThreshold;\r\n        }\r\n        this.memory.recovering = recovering;\r\n        return recovering;\r\n    }\r\n    /**\r\n     * Retreat and get healed\r\n     */\r\n    recover() {\r\n        if (this.pos.findInRange(this.room.hostiles, 5).length > 0 || this.room.towers.length > 0) {\r\n            this.memory.lastInDanger = Game.time;\r\n        }\r\n        const goals = GoalFinder.retreatGoals(this);\r\n        const result = Movement.combatMove(this, goals.approach, goals.avoid, { allowExit: true });\r\n        if (result == NO_ACTION && this.pos.isEdge) {\r\n            if (Game.time < this.memory.lastInDanger + 3) {\r\n                return this.moveOffExit();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\nCombatZerg = tslib_1.__decorate([\r\n    profile\r\n], CombatZerg);\r\nexport { CombatZerg };\r\n","references":["C:/git/Overmind/src/intel/CombatIntel.ts","C:/git/Overmind/src/movement/Movement.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/roomPlanner/layouts/bunker.ts","C:/git/Overmind/src/targeting/CombatTargeting.ts","C:/git/Overmind/src/targeting/GoalFinder.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/zerg/Zerg.ts"]}
