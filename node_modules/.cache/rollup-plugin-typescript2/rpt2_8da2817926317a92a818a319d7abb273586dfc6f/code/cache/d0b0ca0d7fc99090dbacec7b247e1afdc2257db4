{"code":"// A stripped-down version of the logistics network intended for local deliveries\r\nimport * as tslib_1 from \"tslib\";\r\nimport { log } from '../console/log';\r\nimport { isEnergyStructure, isStoreStructure } from '../declarations/typeGuards';\r\nimport { blankPriorityQueue, Priority } from '../priorities/priorities';\r\nimport { profile } from '../profiler/decorator';\r\n/**\r\n * Transport request groups handle close-range prioritized resource requests, in contrast to the logistics network,\r\n * which handles longer-ranged requests\r\n */\r\nlet TransportRequestGroup = class TransportRequestGroup {\r\n    constructor() {\r\n        this.refresh();\r\n    }\r\n    refresh() {\r\n        this.supply = blankPriorityQueue();\r\n        this.withdraw = blankPriorityQueue();\r\n        this.supplyByID = {};\r\n        this.withdrawByID = {};\r\n    }\r\n    get needsSupplying() {\r\n        for (const priority in this.supply) {\r\n            if (this.supply[priority].length > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    get needsWithdrawing() {\r\n        for (const priority in this.withdraw) {\r\n            if (this.withdraw[priority].length > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getPrioritizedClosestRequest(pos, type, filter) {\r\n        const requests = type == 'withdraw' ? this.withdraw : this.supply;\r\n        for (const priority in requests) {\r\n            const targets = _.map(requests[priority], request => request.target);\r\n            const target = pos.findClosestByRangeThenPath(targets);\r\n            if (target) {\r\n                let searchRequests;\r\n                if (filter) {\r\n                    searchRequests = _.filter(requests[priority], req => filter(req));\r\n                }\r\n                else {\r\n                    searchRequests = requests[priority];\r\n                }\r\n                return _.find(searchRequests, request => request.target.ref == target.ref);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Request for resources to be deposited into this target\r\n     */\r\n    requestInput(target, priority = Priority.Normal, opts = {}) {\r\n        _.defaults(opts, {\r\n            resourceType: RESOURCE_ENERGY,\r\n        });\r\n        if (opts.amount == undefined) {\r\n            opts.amount = this.getInputAmount(target, opts.resourceType);\r\n        }\r\n        // Register the request\r\n        const req = {\r\n            target: target,\r\n            resourceType: opts.resourceType,\r\n            amount: opts.amount,\r\n        };\r\n        if (opts.amount > 0) {\r\n            this.supply[priority].push(req);\r\n            if (!this.supplyByID[target.id])\r\n                this.supplyByID[target.id] = [];\r\n            this.supplyByID[target.id].push(req);\r\n        }\r\n    }\r\n    /**\r\n     * Request for resources to be withdrawn from this target\r\n     */\r\n    requestOutput(target, priority = Priority.Normal, opts = {}) {\r\n        _.defaults(opts, {\r\n            resourceType: RESOURCE_ENERGY,\r\n        });\r\n        if (opts.amount == undefined) {\r\n            opts.amount = this.getOutputAmount(target, opts.resourceType);\r\n        }\r\n        // Register the request\r\n        const req = {\r\n            target: target,\r\n            resourceType: opts.resourceType,\r\n            amount: opts.amount,\r\n        };\r\n        if (opts.amount > 0) {\r\n            this.withdraw[priority].push(req);\r\n            if (!this.withdrawByID[target.id])\r\n                this.withdrawByID[target.id] = [];\r\n            this.withdrawByID[target.id].push(req);\r\n        }\r\n    }\r\n    // /* Makes a provide for every resourceType in a requestor object */\r\n    // requestOutputAll(target: StoreStructure, priority = Priority.Normal, opts = {} as TransportRequestOptions): void {\r\n    // \tfor (let resourceType in target.store) {\r\n    // \t\tlet amount = target.store[<ResourceConstant>resourceType] || 0;\r\n    // \t\tif (amount > 0) {\r\n    // \t\t\topts.resourceType = <ResourceConstant>resourceType;\r\n    // \t\t\tthis.requestOutput(target, priority, opts);\r\n    // \t\t}\r\n    // \t}\r\n    // }\r\n    getInputAmount(target, resourceType) {\r\n        if (isStoreStructure(target)) {\r\n            return target.storeCapacity - _.sum(target.store);\r\n        }\r\n        else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {\r\n            return target.energyCapacity - target.energy;\r\n        }\r\n        else {\r\n            if (target instanceof StructureLab) {\r\n                if (resourceType == target.mineralType) {\r\n                    return target.mineralCapacity - target.mineralAmount;\r\n                }\r\n                else if (resourceType == RESOURCE_ENERGY) {\r\n                    return target.energyCapacity - target.energy;\r\n                }\r\n            }\r\n            else if (target instanceof StructureNuker) {\r\n                if (resourceType == RESOURCE_GHODIUM) {\r\n                    return target.ghodiumCapacity - target.ghodium;\r\n                }\r\n                else if (resourceType == RESOURCE_ENERGY) {\r\n                    return target.energyCapacity - target.energy;\r\n                }\r\n            }\r\n            else if (target instanceof StructurePowerSpawn) {\r\n                if (resourceType == RESOURCE_POWER) {\r\n                    return target.powerCapacity - target.power;\r\n                }\r\n                else if (resourceType == RESOURCE_ENERGY) {\r\n                    return target.energyCapacity - target.energy;\r\n                }\r\n            }\r\n        }\r\n        log.warning('Could not determine requestor amount!');\r\n        return 0;\r\n    }\r\n    getOutputAmount(target, resourceType) {\r\n        if (isStoreStructure(target)) {\r\n            return target.store[resourceType];\r\n        }\r\n        else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {\r\n            return target.energy;\r\n        }\r\n        else {\r\n            if (target instanceof StructureLab) {\r\n                if (resourceType == target.mineralType) {\r\n                    return target.mineralAmount;\r\n                }\r\n                else if (resourceType == RESOURCE_ENERGY) {\r\n                    return target.energy;\r\n                }\r\n            }\r\n            else if (target instanceof StructureNuker) {\r\n                if (resourceType == RESOURCE_GHODIUM) {\r\n                    return target.ghodium;\r\n                }\r\n                else if (resourceType == RESOURCE_ENERGY) {\r\n                    return target.energy;\r\n                }\r\n            }\r\n            else if (target instanceof StructurePowerSpawn) {\r\n                if (resourceType == RESOURCE_POWER) {\r\n                    return target.power;\r\n                }\r\n                else if (resourceType == RESOURCE_ENERGY) {\r\n                    return target.energy;\r\n                }\r\n            }\r\n        }\r\n        log.warning('Could not determine provider amount!');\r\n        return 0;\r\n    }\r\n    /**\r\n     * Summarize the state of the transport request group to the console; useful for debugging.\r\n     */\r\n    summarize(ignoreEnergy = false) {\r\n        console.log(`Supply requests ==========================`);\r\n        for (const priority in this.supply) {\r\n            if (this.supply[priority].length > 0) {\r\n                console.log(`Priority: ${priority}`);\r\n            }\r\n            for (const request of this.supply[priority]) {\r\n                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY)\r\n                    continue;\r\n                console.log(`    targetID: ${request.target.ref}  amount: ${request.amount}  ` +\r\n                    `resourceType: ${request.resourceType}`);\r\n            }\r\n        }\r\n        console.log(`Withdraw requests ========================`);\r\n        for (const priority in this.withdraw) {\r\n            if (this.withdraw[priority].length > 0) {\r\n                console.log(`Priority: ${priority}`);\r\n            }\r\n            for (const request of this.withdraw[priority]) {\r\n                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY)\r\n                    continue;\r\n                console.log(`    targetID: ${request.target.ref}  amount: ${request.amount}  ` +\r\n                    `resourceType: ${request.resourceType}`);\r\n            }\r\n        }\r\n    }\r\n};\r\nTransportRequestGroup = tslib_1.__decorate([\r\n    profile\r\n], TransportRequestGroup);\r\nexport { TransportRequestGroup };\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/priorities/priorities.ts","C:/git/Overmind/src/profiler/decorator.ts"]}
