{"code":"// Combat Intel - provides information related to making combat-related decisions\r\nimport * as tslib_1 from \"tslib\";\r\nvar CombatIntel_1;\r\nimport { log } from '../console/log';\r\nimport { isOwnedStructure, isStructure, isZerg } from '../declarations/typeGuards';\r\nimport { Mem } from '../memory/Memory';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { profile } from '../profiler/decorator';\r\nimport { boostResources } from '../resources/map_resources';\r\nimport { Cartographer } from '../utilities/Cartographer';\r\nimport { toCreep } from '../zerg/Zerg';\r\nimport { RoomIntel } from './RoomIntel';\r\nlet CombatIntel = CombatIntel_1 = class CombatIntel {\r\n    constructor(directive) {\r\n        this.directive = directive;\r\n    }\r\n    get memory() {\r\n        return Mem.wrap(this.directive.memory, 'combatIntel', {});\r\n    }\r\n    get room() {\r\n        return this.directive.room;\r\n    }\r\n    get colony() {\r\n        return this.directive.colony;\r\n    }\r\n    // Tower damage ====================================================================================================\r\n    /**\r\n     * Get the tower damage at a given range\r\n     */\r\n    static singleTowerDamage(range) {\r\n        if (range <= TOWER_OPTIMAL_RANGE) {\r\n            return TOWER_POWER_ATTACK;\r\n        }\r\n        range = Math.min(range, TOWER_FALLOFF_RANGE);\r\n        const falloff = (range - TOWER_OPTIMAL_RANGE) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);\r\n        return TOWER_POWER_ATTACK * (1 - TOWER_FALLOFF * falloff);\r\n    }\r\n    /**\r\n     * Total tower tamage from all towers in room at a given position\r\n     */\r\n    static towerDamageAtPos(pos, ignoreEnergy = false) {\r\n        if (pos.room) {\r\n            let expectedDamage = 0;\r\n            for (const tower of pos.room.towers) {\r\n                if (tower.energy > 0 || ignoreEnergy) {\r\n                    expectedDamage += this.singleTowerDamage(pos.getRangeTo(tower));\r\n                }\r\n            }\r\n            return expectedDamage;\r\n        }\r\n        else {\r\n            log.warning(`CombatIntel.towerDamageAtPos: room visibility at ${pos.print}!`);\r\n            return 0;\r\n        }\r\n    }\r\n    // Cost matrix calculations\r\n    computeCostMatrix() {\r\n        if (this.room) {\r\n            const matrix = new PathFinder.CostMatrix();\r\n            const barriers = this.room.barriers;\r\n            if (barriers.length > 0) {\r\n                const highestHits = _.last(_.sortBy(barriers, barrier => barrier.hits)).hits;\r\n                for (const barrier of barriers) {\r\n                    matrix.set(barrier.pos.x, barrier.pos.y, Math.ceil(barrier.hits * 10 / highestHits) * 10);\r\n                }\r\n            }\r\n            return matrix;\r\n        }\r\n    }\r\n    // Fallback and exit calculations ==================================================================================\r\n    findBestExit(matrix, towers, spawns) {\r\n        if (!this.room) {\r\n            return;\r\n        }\r\n        let bestExit;\r\n        const destination = this.room.spawns[0] || this.room.storage; // enemy structure you are trying to get to\r\n        if (!destination) {\r\n            return;\r\n        }\r\n        const ret = Pathing.findPath(this.colony.pos, destination.pos, { range: 1 });\r\n        if (!ret.incomplete) {\r\n            bestExit = _.find(ret.path, p => p.roomName == this.room.name);\r\n        }\r\n        // Figure out possible exits to go from enemy room back to colony in a reasonable amount of time\r\n        const maxRoomDistance = 8;\r\n        const allowedExits = {};\r\n        if (!bestExit) {\r\n            const exitData = Game.map.describeExits(this.room.name);\r\n            for (const direction in exitData) {\r\n                const roomName = exitData[direction];\r\n                const allowedRooms = Pathing.findRoute(this.colony.name, roomName);\r\n                if (allowedRooms && Object.keys(allowedRooms).length <= maxRoomDistance) {\r\n                    allowedExits[direction] = true;\r\n                }\r\n            }\r\n            if (_.keys(allowedExits).length == 0) {\r\n                return;\r\n            }\r\n        }\r\n        // TODO\r\n        const exitPositions = [];\r\n        const terrain = Game.map.getRoomTerrain(this.room.name);\r\n        for (let x = 0; x < 50; x += 49) {\r\n            for (let y = 0; y < 50; y++) {\r\n                if (x !== 0 && y !== 0 && x !== 49 && y !== 49) {\r\n                    continue;\r\n                }\r\n                if (terrain.get(x, y) === TERRAIN_MASK_WALL) {\r\n                    continue;\r\n                }\r\n                matrix.set(x, y, 0xff);\r\n                if (bestExit) {\r\n                    continue;\r\n                }\r\n                if (allowedExits['1'] && y === 0) {\r\n                    exitPositions.push(new RoomPosition(x, y, this.room.name));\r\n                }\r\n                else if (allowedExits['3'] && x === 49) {\r\n                    exitPositions.push(new RoomPosition(x, y, this.room.name));\r\n                }\r\n                else if (allowedExits['5'] && y === 49) {\r\n                    exitPositions.push(new RoomPosition(x, y, this.room.name));\r\n                }\r\n                else if (allowedExits['7'] && x === 0) {\r\n                    exitPositions.push(new RoomPosition(x, y, this.room.name));\r\n                }\r\n            }\r\n        }\r\n        if (!bestExit) {\r\n            bestExit = _(exitPositions)\r\n                .sortBy((p) => -_.sum(towers, (t) => p.getRangeTo(t)))\r\n                .head();\r\n        }\r\n        matrix.set(bestExit.x, bestExit.y, 1);\r\n        return bestExit;\r\n    }\r\n    // static findBestSiegeExit(roomName: string, matrix?: CostMatrix): RoomPosition | undefined  {\r\n    // \tlet edgeCoords: [number, number][] = [];\r\n    // \tfor (let x = 0; x < 50; x += 49) {\r\n    // \t\tfor (let y = 0; y < 50; y++) {\r\n    // \t\t\tedgeCoords.push([x,y])\r\n    // \t\t}\r\n    // \t}\r\n    // \tfor (let x = 0; x < 50; x++) {\r\n    // \t\tfor (let y = 0; y < 50; y += 49) {\r\n    // \t\t\tedgeCoords.push([x,y])\r\n    // \t\t}\r\n    // \t}\r\n    //\r\n    // \tconst room = Game.rooms[roomName];\r\n    // \tlet siegeTarget = CombatTargeting.findBestStructureTarget()\r\n    // }\r\n    /**\r\n     * Simple routine to find an assembly point outside of the target room\r\n     */\r\n    findSimpleSiegeFallback() {\r\n        const ret = Pathing.findPath(this.colony.pos, this.directive.pos, { range: 23 });\r\n        if (ret.incomplete) {\r\n            log.warning(`Incomplete path while finding fallback! Destination: ${this.directive.pos.print}`);\r\n        }\r\n        const firstPosInRoom = _.find(ret.path, pos => pos.roomName == this.directive.pos.roomName);\r\n        if (firstPosInRoom) {\r\n            return CombatIntel_1.getFallbackFrom(firstPosInRoom);\r\n        }\r\n        else {\r\n            return CombatIntel_1.getFallbackFrom(this.directive.pos);\r\n        }\r\n    }\r\n    /**\r\n     * Finds a location for a swarm to assemble outside of the target room\r\n     */\r\n    findSwarmAssemblyPoint(clearance, swarmIndex = 0) {\r\n        const simpleFallback = this.findSimpleSiegeFallback();\r\n        const startPos = Pathing.findPathablePosition(simpleFallback.roomName, clearance);\r\n        let ret = Pathing.findSwarmPath(startPos, this.directive.pos, clearance.width, clearance.height, { ignoreCreeps: true });\r\n        if (ret.incomplete) {\r\n            log.debug(`Incomplete swarm path to find assembly point. Retrying with startpos = fallback.`);\r\n            ret = Pathing.findSwarmPath(simpleFallback, this.directive.pos, clearance.width, clearance.height, { ignoreCreeps: true });\r\n            if (ret.incomplete) {\r\n                log.warning(`No pathable assembly point!`);\r\n            }\r\n        }\r\n        const path = ret.path.reverse();\r\n        const acceptablePositions = _.filter(path, pos => pos.roomName == simpleFallback.roomName &&\r\n            pos.rangeToEdge > 1);\r\n        const swarmSize = Math.max(clearance.width, clearance.height);\r\n        const posIndex = (swarmSize + 1) * swarmIndex;\r\n        return acceptablePositions[posIndex] || acceptablePositions[0] || simpleFallback;\r\n    }\r\n    /**\r\n     * Finds a location for a swarm to assemble within an owned room\r\n     */\r\n    findSwarmAssemblyPointInColony(clearance, swarmIndex = 0) {\r\n        // let ret = Pathing.findSwarmPath(this.colony.pos, this.directive.pos, clearance.width, clearance.height,\r\n        // \t\t\t\t\t\t\t\t{ignoreCreeps: true});\r\n        const ret = Pathing.findPath(this.colony.pos, this.directive.pos, { ignoreCreeps: true });\r\n        const path = ret.path.reverse();\r\n        const acceptablePositions = _.filter(path, pos => pos.roomName == this.colony.name && pos.rangeToEdge > 1);\r\n        const swarmSize = Math.max(clearance.width, clearance.height);\r\n        const posIndex = (swarmSize + 1) * swarmIndex;\r\n        return acceptablePositions[posIndex] || acceptablePositions[0];\r\n    }\r\n    /**\r\n     * Fallback is a location on the other side of the nearest exit the directive is placed at\r\n     */\r\n    static getFallbackFrom(pos, fallbackDistance = 2) {\r\n        let { x, y, roomName } = pos;\r\n        const rangesToExit = [[x, 'left'], [49 - x, 'right'], [y, 'top'], [49 - y, 'bottom']];\r\n        const [range, direction] = _.first(_.sortBy(rangesToExit, pair => pair[0]));\r\n        switch (direction) {\r\n            case 'left':\r\n                x = 49 - fallbackDistance;\r\n                roomName = Cartographer.findRelativeRoomName(roomName, -1, 0);\r\n                break;\r\n            case 'right':\r\n                x = fallbackDistance;\r\n                roomName = Cartographer.findRelativeRoomName(roomName, 1, 0);\r\n                break;\r\n            case 'top':\r\n                y = 49 - fallbackDistance;\r\n                roomName = Cartographer.findRelativeRoomName(roomName, 0, -1);\r\n                break;\r\n            case 'bottom':\r\n                y = fallbackDistance;\r\n                roomName = Cartographer.findRelativeRoomName(roomName, 0, 1);\r\n                break;\r\n            default:\r\n                log.error('Error getting fallback position!');\r\n                break;\r\n        }\r\n        return new RoomPosition(x, y, roomName);\r\n    }\r\n    // Creep potentials ================================================================================================\r\n    /**\r\n     * Cache the result of a computation for a tick\r\n     */\r\n    static cache(creep, key, callback) {\r\n        if (!creep.intel)\r\n            creep.intel = {};\r\n        if (creep.intel[key] == undefined) {\r\n            creep.intel[key] = callback();\r\n        }\r\n        return creep.intel[key];\r\n    }\r\n    /**\r\n     * Heal potential of a single creep in units of effective number of parts\r\n     */\r\n    static getHealPotential(creep) {\r\n        return this.cache(creep, 'healPotential', () => _.sum(creep.body, function (part) {\r\n            if (part.hits == 0) {\r\n                return 0;\r\n            }\r\n            if (part.type == HEAL) {\r\n                if (!part.boost) {\r\n                    return 1;\r\n                }\r\n                else if (part.boost == boostResources.heal[1]) {\r\n                    return BOOSTS.heal.LO.heal;\r\n                }\r\n                else if (part.boost == boostResources.heal[2]) {\r\n                    return BOOSTS.heal.LHO2.heal;\r\n                }\r\n                else if (part.boost == boostResources.heal[3]) {\r\n                    return BOOSTS.heal.XLHO2.heal;\r\n                }\r\n            }\r\n            return 0;\r\n        }));\r\n    }\r\n    static getHealAmount(creep) {\r\n        return HEAL_POWER * this.getHealPotential(toCreep(creep));\r\n    }\r\n    static getRangedHealAmount(creep) {\r\n        return RANGED_HEAL_POWER * this.getHealPotential(toCreep(creep));\r\n    }\r\n    /**\r\n     * If a creep appears to primarily be a healer\r\n     */\r\n    static isHealer(zerg) {\r\n        const creep = toCreep(zerg);\r\n        const healParts = _.filter(zerg.body, part => part.type == HEAL).length;\r\n        const attackParts = _.filter(zerg.body, part => part.type == ATTACK).length;\r\n        const rangedAttackParts = _.filter(zerg.body, part => part.type == RANGED_ATTACK).length;\r\n        return healParts > attackParts + rangedAttackParts;\r\n    }\r\n    /**\r\n     * Attack potential of a single creep in units of effective number of parts\r\n     */\r\n    static getAttackPotential(creep) {\r\n        return this.cache(creep, 'attackPotential', () => _.sum(creep.body, function (part) {\r\n            if (part.hits == 0) {\r\n                return 0;\r\n            }\r\n            if (part.type == ATTACK) {\r\n                if (!part.boost) {\r\n                    return 1;\r\n                }\r\n                else if (part.boost == boostResources.attack[1]) {\r\n                    return BOOSTS.attack.UH.attack;\r\n                }\r\n                else if (part.boost == boostResources.attack[2]) {\r\n                    return BOOSTS.attack.UH2O.attack;\r\n                }\r\n                else if (part.boost == boostResources.attack[3]) {\r\n                    return BOOSTS.attack.XUH2O.attack;\r\n                }\r\n            }\r\n            return 0;\r\n        }));\r\n    }\r\n    static getAttackDamage(creep) {\r\n        return ATTACK_POWER * this.getAttackPotential(toCreep(creep));\r\n    }\r\n    /**\r\n     * Ranged attack potential of a single creep in units of effective number of parts\r\n     */\r\n    static getRangedAttackPotential(creep) {\r\n        return this.cache(creep, 'rangedAttackPotential', () => _.sum(creep.body, function (part) {\r\n            if (part.hits == 0) {\r\n                return 0;\r\n            }\r\n            if (part.type == RANGED_ATTACK) {\r\n                if (!part.boost) {\r\n                    return 1;\r\n                }\r\n                else if (part.boost == boostResources.ranged_attack[1]) {\r\n                    return BOOSTS.ranged_attack.KO.rangedAttack;\r\n                }\r\n                else if (part.boost == boostResources.ranged_attack[2]) {\r\n                    return BOOSTS.ranged_attack.KHO2.rangedAttack;\r\n                }\r\n                else if (part.boost == boostResources.ranged_attack[3]) {\r\n                    return BOOSTS.ranged_attack.XKHO2.rangedAttack;\r\n                }\r\n            }\r\n            return 0;\r\n        }));\r\n    }\r\n    static getRangedAttackDamage(creep) {\r\n        return RANGED_ATTACK_POWER * this.getRangedAttackPotential(toCreep(creep));\r\n    }\r\n    /**\r\n     * Attack potential of a single creep in units of effective number of parts\r\n     */\r\n    static getDismantlePotential(creep) {\r\n        return this.cache(creep, 'dismantlePotential', () => _.sum(creep.body, function (part) {\r\n            if (part.hits == 0) {\r\n                return 0;\r\n            }\r\n            if (part.type == WORK) {\r\n                if (!part.boost) {\r\n                    return 1;\r\n                }\r\n                else if (part.boost == boostResources.dismantle[1]) {\r\n                    return BOOSTS.work.ZH.dismantle;\r\n                }\r\n                else if (part.boost == boostResources.dismantle[2]) {\r\n                    return BOOSTS.work.ZH2O.dismantle;\r\n                }\r\n                else if (part.boost == boostResources.dismantle[3]) {\r\n                    return BOOSTS.work.XZH2O.dismantle;\r\n                }\r\n            }\r\n            return 0;\r\n        }));\r\n    }\r\n    static getDismantleDamage(creep) {\r\n        return DISMANTLE_POWER * this.getDismantlePotential(toCreep(creep));\r\n    }\r\n    /**\r\n     * Minimum damage multiplier a creep has\r\n     */\r\n    static minimumDamageTakenMultiplier(creep) {\r\n        return this.cache(creep, 'minDamageMultiplier', () => _.min(_.map(creep.body, function (part) {\r\n            if (part.type == TOUGH && part.hits > 0) {\r\n                if (part.boost == boostResources.tough[1]) {\r\n                    return BOOSTS.tough.GO.damage;\r\n                }\r\n                else if (part.boost == boostResources.tough[2]) {\r\n                    return BOOSTS.tough.GHO2.damage;\r\n                }\r\n                else if (part.boost == boostResources.tough[3]) {\r\n                    return BOOSTS.tough.XGHO2.damage;\r\n                }\r\n            }\r\n            return 1;\r\n        })));\r\n    }\r\n    static minimumDamageMultiplierForGroup(creeps) {\r\n        return _.min(_.map(creeps, creep => this.minimumDamageTakenMultiplier(creep)));\r\n    }\r\n    static getMassAttackDamageTo(attacker, target) {\r\n        if (isStructure(target) && (!isOwnedStructure(target) || target.my)) {\r\n            return 0;\r\n        }\r\n        const range = attacker.pos.getRangeTo(target.pos);\r\n        let rangedMassAttackPower = 0;\r\n        if (range <= 1) {\r\n            rangedMassAttackPower = 10;\r\n        }\r\n        else if (range == 2) {\r\n            rangedMassAttackPower = 4;\r\n        }\r\n        else if (range == 3) {\r\n            rangedMassAttackPower = 1;\r\n        }\r\n        return rangedMassAttackPower * this.getRangedAttackPotential(isZerg(attacker) ? attacker.creep : attacker);\r\n    }\r\n    /**\r\n     * Total damage to enemy creeps done by attacker.rangedMassAttack()\r\n     */\r\n    static getMassAttackDamage(attacker, targets = attacker.room.hostiles, checkRampart = true) {\r\n        const hostiles = attacker.pos.findInRange(targets, 3);\r\n        return _.sum(hostiles, function (hostile) {\r\n            if (checkRampart && hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {\r\n                return 0; // Creep inside rampart\r\n            }\r\n            else {\r\n                return CombatIntel_1.getMassAttackDamageTo(attacker, hostile);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * A heuristic for scoring the effectiveness of creeps\r\n     */\r\n    static rating(creep) {\r\n        const c = toCreep(creep);\r\n        return this.cache(c, 'rating', () => {\r\n            let rating = this.getRangedAttackPotential(c) + this.getAttackPotential(c) / 2;\r\n            const healMultiplier = 1 / this.minimumDamageTakenMultiplier(c);\r\n            rating += healMultiplier * this.getHealPotential(c);\r\n            return rating;\r\n        });\r\n    }\r\n    // Group creep calculations ========================================================================================\r\n    /**\r\n     * Maximum damage that a group of creeps can dish out (doesn't count for simultaneity restrictions)\r\n     */\r\n    static maxDamageByCreeps(creeps) {\r\n        return _.sum(creeps, creep => ATTACK_POWER * this.getAttackPotential(creep) +\r\n            RANGED_ATTACK_POWER * this.getRangedAttackPotential(creep));\r\n    }\r\n    /**\r\n     * Maximum healing that a group of creeps can provide (doesn't count for simultaneity restrictions)\r\n     */\r\n    static maxHealingByCreeps(creeps) {\r\n        return _.sum(creeps, creep => this.getHealAmount(creep));\r\n    }\r\n    /**\r\n     * Total attack/rangedAttack/heal potentials for a group of creeps\r\n     */\r\n    static getCombatPotentials(creeps) {\r\n        const attack = _.sum(creeps, creep => this.getAttackPotential(creep));\r\n        const rangedAttack = _.sum(creeps, creep => this.getRangedAttackPotential(creep));\r\n        const heal = _.sum(creeps, creep => this.getHealPotential(creep));\r\n        return { attack, rangedAttack, heal };\r\n    }\r\n    /**\r\n     * Maximum damage that is dealable at a given position by enemy forces\r\n     */\r\n    static maxDamageAtPos(pos) {\r\n        if (!pos.room) {\r\n            return 0;\r\n        }\r\n        const hostilesInMeleeRange = _.filter(pos.room.dangerousHostiles, creep => pos.getRangeTo(creep) <= 1);\r\n        const meleeDamage = _.sum(hostilesInMeleeRange, hostile => this.getAttackDamage(hostile));\r\n        const hostilesInRange = _.filter(pos.room.dangerousHostiles, creep => pos.getRangeTo(creep) <= 3);\r\n        const rangedDamage = _.sum(hostilesInRange, hostile => this.getRangedAttackDamage(hostile));\r\n        let totalDamage = meleeDamage + rangedDamage;\r\n        if (!pos.room.my) {\r\n            totalDamage += this.towerDamageAtPos(pos) || 0;\r\n        }\r\n        return totalDamage;\r\n    }\r\n    /**\r\n     * Heal potential of self and possible healer neighbors\r\n     */\r\n    static maxHostileHealingTo(creep) {\r\n        return this.cache(creep, 'maxHostileHealing', () => {\r\n            const selfHealing = this.getHealAmount(creep);\r\n            const neighbors = _.filter(creep.room.hostiles, hostile => hostile.pos.isNearTo(creep));\r\n            const neighborHealing = _.sum(neighbors, neighbor => this.getHealAmount(neighbor));\r\n            const rangedHealers = _.filter(creep.room.hostiles, hostile => hostile.pos.getRangeTo(creep) <= 3 &&\r\n                !neighbors.includes(hostile));\r\n            const rangedHealing = _.sum(rangedHealers, healer => this.getRangedHealAmount(healer));\r\n            return selfHealing + neighborHealing + rangedHealing;\r\n        });\r\n    }\r\n    /**\r\n     * Heal potential of self and possible healer neighbors\r\n     */\r\n    static avgHostileHealingTo(creeps) {\r\n        return _.max(_.map(creeps, creep => CombatIntel_1.maxHostileHealingTo(creep))) / creeps.length;\r\n    }\r\n    /**\r\n     * Heal potential of self and possible healer neighbors\r\n     */\r\n    static maxFriendlyHealingTo(friendly) {\r\n        const creep = toCreep(friendly);\r\n        return this.cache(creep, 'maxFriendlyHealing', () => {\r\n            const selfHealing = this.getHealAmount(creep);\r\n            const neighbors = _.filter(creep.room.creeps, hostile => hostile.pos.isNearTo(creep));\r\n            const neighborHealing = _.sum(neighbors, neighbor => this.getHealAmount(neighbor));\r\n            const rangedHealers = _.filter(creep.room.creeps, hostile => hostile.pos.getRangeTo(creep) <= 3 &&\r\n                !neighbors.includes(hostile));\r\n            const rangedHealing = _.sum(rangedHealers, healer => this.getHealAmount(healer));\r\n            return selfHealing + neighborHealing + rangedHealing;\r\n        });\r\n    }\r\n    /**\r\n     * Determine the predicted damage amount of a certain type of attack. Can specify if you should use predicted or\r\n     * current hits amount and whether to include predicted healing. Does not update predicted hits.\r\n     */\r\n    static predictedDamageAmount(attacker, target, attackType, useHitsPredicted = true) {\r\n        // Compute initial (gross) damage amount\r\n        let grossDamage;\r\n        if (attackType == 'attack') {\r\n            grossDamage = this.getAttackDamage(attacker);\r\n        }\r\n        else if (attackType == 'rangedAttack') {\r\n            grossDamage = this.getRangedAttackDamage(attacker);\r\n        }\r\n        else { // rangedMassAttack; not currently used\r\n            grossDamage = this.getMassAttackDamageTo(attacker, target);\r\n        }\r\n        // Adjust for remaining tough parts\r\n        let toughHits;\r\n        if (useHitsPredicted) {\r\n            if (target.hitsPredicted == undefined)\r\n                target.hitsPredicted = target.hits;\r\n            const nonToughHits = _.sum(target.body, part => part.type == TOUGH ? 0 : part.hits);\r\n            toughHits = Math.min(target.hitsPredicted - nonToughHits, 0); // predicted amount of TOUGH\r\n        }\r\n        else {\r\n            toughHits = 100 * target.getActiveBodyparts(TOUGH);\r\n        }\r\n        const damageMultiplier = this.minimumDamageTakenMultiplier(target); // assumes only 1 tier of boosts\r\n        if (grossDamage * damageMultiplier < toughHits) { // if you can't eat through armor\r\n            return grossDamage * damageMultiplier;\r\n        }\r\n        else { // if you break tough shield\r\n            grossDamage -= toughHits / damageMultiplier;\r\n            return toughHits + grossDamage;\r\n        }\r\n    }\r\n    // Creep position calculations =====================================================================================\r\n    // // Distance from a given creep to the nearest rampart or wall; Infinity if no barriers in room\r\n    // static distanceToBarrier(creep: Creep): number {\r\n    //\r\n    // }\r\n    static isApproaching(approacher, toPos) {\r\n        const previousPos = RoomIntel.getPreviousPos(approacher);\r\n        const previousRange = toPos.getRangeTo(previousPos);\r\n        const currentRange = toPos.getRangeTo(approacher.pos);\r\n        return currentRange < previousRange;\r\n    }\r\n    static isRetreating(retreater, fromPos) {\r\n        const previousPos = RoomIntel.getPreviousPos(retreater);\r\n        const previousRange = fromPos.getRangeTo(previousPos);\r\n        const currentRange = fromPos.getRangeTo(retreater.pos);\r\n        return currentRange > previousRange;\r\n    }\r\n    /**\r\n     * This method is probably expensive; use sparingly\r\n     */\r\n    static isEdgeDancing(creep, reentryThreshold = 3) {\r\n        if (!creep.room.my) {\r\n            log.warning(`isEdgeDancing should only be called in owned rooms!`);\r\n        }\r\n        const creepOccupancies = creep.room.memory[\"cr\" /* CREEPS_IN_ROOM */];\r\n        if (creepOccupancies) {\r\n            // Look to see if the creep has exited and re-entered the room a given number of times\r\n            const creepInRoomTicks = [];\r\n            for (const tick in creepOccupancies) {\r\n                if (creepOccupancies[tick].includes(creep.name)) {\r\n                    creepInRoomTicks.push(parseInt(tick, 10));\r\n                }\r\n            }\r\n            let reentries = 1;\r\n            if (creepInRoomTicks.length > 0) {\r\n                for (const i of _.range(creepInRoomTicks.length - 1)) {\r\n                    if (creepInRoomTicks[i + 1] != creepInRoomTicks[i] + 1) {\r\n                        // There was a gap between the creep's presence in the room so it must have reentered\r\n                        reentries++;\r\n                    }\r\n                }\r\n            }\r\n            return reentries >= reentryThreshold;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    static getPositionsNearEnemies(hostiles, range = 0) {\r\n        return _.unique(_.flatten(_.map(hostiles, hostile => hostile.pos.getPositionsInRange(range, false, true))));\r\n    }\r\n};\r\nCombatIntel = CombatIntel_1 = tslib_1.__decorate([\r\n    profile\r\n], CombatIntel);\r\nexport { CombatIntel };\r\n","references":["C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/directives/Directive.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/resources/map_resources.ts","C:/git/Overmind/src/utilities/Cartographer.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/intel/RoomIntel.ts"]}
