{"code":"import * as tslib_1 from \"tslib\";\r\nvar BarrierPlanner_1;\r\nimport { getCutTiles } from '../algorithms/minCut';\r\nimport { log } from '../console/log';\r\nimport { Mem } from '../memory/Memory';\r\nimport { profile } from '../profiler/decorator';\r\nimport { derefCoords, minMax } from '../utilities/utils';\r\nimport { BUNKER_RADIUS, bunkerLayout, insideBunkerBounds } from './layouts/bunker';\r\nimport { getAllStructureCoordsFromLayout, RoomPlanner, translatePositions } from './RoomPlanner';\r\nconst memoryDefaults = {\r\n    barrierLookup: {},\r\n};\r\nlet BarrierPlanner = BarrierPlanner_1 = class BarrierPlanner {\r\n    constructor(roomPlanner) {\r\n        this.roomPlanner = roomPlanner;\r\n        this.colony = roomPlanner.colony;\r\n        this.memory = Mem.wrap(this.colony.memory, 'barrierPlanner', memoryDefaults);\r\n        this.barrierPositions = [];\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(this.colony.memory, 'barrierPlanner', memoryDefaults);\r\n        this.barrierPositions = [];\r\n    }\r\n    computeBunkerBarrierPositions(bunkerPos, upgradeSitePos) {\r\n        const rectArray = [];\r\n        const padding = BarrierPlanner_1.settings.padding;\r\n        if (bunkerPos) {\r\n            const { x, y } = bunkerPos;\r\n            const r = BUNKER_RADIUS - 1;\r\n            let [x1, y1] = [Math.max(x - r - padding, 0), Math.max(y - r - padding, 0)];\r\n            let [x2, y2] = [Math.min(x + r + padding, 49), Math.min(y + r + padding, 49)];\r\n            // Make sure you don't leave open walls\r\n            x1 = minMax(x1, 3, 50 - 3);\r\n            x2 = minMax(x2, 3, 50 - 3);\r\n            y1 = minMax(y1, 3, 50 - 3);\r\n            y2 = minMax(y2, 3, 50 - 3);\r\n            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });\r\n        }\r\n        // Get Min cut\r\n        const barrierCoords = getCutTiles(this.colony.name, rectArray, false, 2, false);\r\n        let positions = _.map(barrierCoords, coord => new RoomPosition(coord.x, coord.y, this.colony.name));\r\n        positions = positions.concat(upgradeSitePos.availableNeighbors(true));\r\n        return positions;\r\n    }\r\n    computeBarrierPositions(hatcheryPos, commandCenterPos, upgradeSitePos) {\r\n        const rectArray = [];\r\n        const padding = BarrierPlanner_1.settings.padding;\r\n        if (hatcheryPos) {\r\n            const { x, y } = hatcheryPos;\r\n            const [x1, y1] = [Math.max(x - 5 - padding, 0), Math.max(y - 4 - padding, 0)];\r\n            const [x2, y2] = [Math.min(x + 5 + padding, 49), Math.min(y + 6 + padding, 49)];\r\n            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });\r\n        }\r\n        if (commandCenterPos) {\r\n            const { x, y } = commandCenterPos;\r\n            const [x1, y1] = [Math.max(x - 3 - padding, 0), Math.max(y - 0 - padding, 0)];\r\n            const [x2, y2] = [Math.min(x + 0 + padding, 49), Math.min(y + 5 + padding, 49)];\r\n            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });\r\n        }\r\n        if (upgradeSitePos) {\r\n            const { x, y } = upgradeSitePos;\r\n            const [x1, y1] = [Math.max(x - 1, 0), Math.max(y - 1, 0)];\r\n            const [x2, y2] = [Math.min(x + 1, 49), Math.min(y + 1, 49)];\r\n            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });\r\n        }\r\n        // Get Min cut\r\n        const barrierCoords = getCutTiles(this.colony.name, rectArray, true, 2, false);\r\n        return _.map(barrierCoords, coord => new RoomPosition(coord.x, coord.y, this.colony.name));\r\n    }\r\n    init() {\r\n    }\r\n    /* Write everything to memory after roomPlanner is closed */\r\n    finalize() {\r\n        this.memory.barrierLookup = {};\r\n        if (this.barrierPositions.length == 0) {\r\n            if (this.roomPlanner.bunkerPos) {\r\n                this.barrierPositions = this.computeBunkerBarrierPositions(this.roomPlanner.bunkerPos, this.colony.controller.pos);\r\n            }\r\n            else if (this.roomPlanner.storagePos && this.roomPlanner.hatcheryPos) {\r\n                this.barrierPositions = this.computeBarrierPositions(this.roomPlanner.hatcheryPos, this.roomPlanner.storagePos, this.colony.controller.pos);\r\n            }\r\n            else {\r\n                log.error(`Couldn't generate barrier plan for ${this.colony.name}!`);\r\n            }\r\n        }\r\n        for (const pos of this.barrierPositions) {\r\n            this.memory.barrierLookup[pos.coordName] = true;\r\n        }\r\n    }\r\n    /* Quick lookup for if a barrier should be in this position. Barriers returning false won't be maintained. */\r\n    barrierShouldBeHere(pos) {\r\n        if (this.colony.layout == 'bunker') {\r\n            if (this.colony.level >= BarrierPlanner_1.settings.bunkerizeRCL) {\r\n                // Once you are high level, only maintain ramparts at bunker or controller\r\n                return insideBunkerBounds(pos, this.colony) || pos.getRangeTo(this.colony.controller) == 1;\r\n            }\r\n            else {\r\n                // Otherwise keep the normal plan up\r\n                return !!this.memory.barrierLookup[pos.coordName] || pos.getRangeTo(this.colony.controller) == 1;\r\n            }\r\n        }\r\n        else {\r\n            return !!this.memory.barrierLookup[pos.coordName] || pos.getRangeTo(this.colony.controller) == 1;\r\n        }\r\n    }\r\n    /* Create construction sites for any buildings that need to be built */\r\n    buildMissingRamparts() {\r\n        // Max buildings that can be placed each tick\r\n        let count = RoomPlanner.settings.maxSitesPerColony - this.colony.constructionSites.length;\r\n        // Build missing ramparts\r\n        const barrierPositions = [];\r\n        for (const coord of _.keys(this.memory.barrierLookup)) {\r\n            barrierPositions.push(derefCoords(coord, this.colony.name));\r\n        }\r\n        // Add critical structures to barrier lookup\r\n        const criticalStructures = _.compact([...this.colony.towers,\r\n            ...this.colony.spawns,\r\n            this.colony.storage,\r\n            this.colony.terminal]);\r\n        for (const structure of criticalStructures) {\r\n            barrierPositions.push(structure.pos);\r\n        }\r\n        for (const pos of barrierPositions) {\r\n            if (count > 0 && RoomPlanner.canBuild(STRUCTURE_RAMPART, pos) && this.barrierShouldBeHere(pos)) {\r\n                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);\r\n                if (ret != OK) {\r\n                    log.warning(`${this.colony.name}: couldn't create rampart site at ${pos.print}. Result: ${ret}`);\r\n                }\r\n                else {\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    buildMissingBunkerRamparts() {\r\n        if (!this.roomPlanner.bunkerPos)\r\n            return;\r\n        const bunkerCoords = getAllStructureCoordsFromLayout(bunkerLayout, this.colony.level);\r\n        bunkerCoords.push(bunkerLayout.data.anchor); // add center bunker tile\r\n        let bunkerPositions = _.map(bunkerCoords, coord => new RoomPosition(coord.x, coord.y, this.colony.name));\r\n        bunkerPositions = translatePositions(bunkerPositions, bunkerLayout.data.anchor, this.roomPlanner.bunkerPos);\r\n        let count = RoomPlanner.settings.maxSitesPerColony - this.colony.constructionSites.length;\r\n        for (const pos of bunkerPositions) {\r\n            if (count > 0 && !pos.lookForStructure(STRUCTURE_RAMPART)\r\n                && pos.lookFor(LOOK_CONSTRUCTION_SITES).length == 0) {\r\n                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);\r\n                if (ret != OK) {\r\n                    log.warning(`${this.colony.name}: couldn't create bunker rampart at ${pos.print}. Result: ${ret}`);\r\n                }\r\n                else {\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    run() {\r\n        if (this.roomPlanner.active) {\r\n            if (this.roomPlanner.bunkerPos) {\r\n                this.barrierPositions = this.computeBunkerBarrierPositions(this.roomPlanner.bunkerPos, this.colony.controller.pos);\r\n            }\r\n            else if (this.roomPlanner.storagePos && this.roomPlanner.hatcheryPos) {\r\n                this.barrierPositions = this.computeBarrierPositions(this.roomPlanner.hatcheryPos, this.roomPlanner.storagePos, this.colony.controller.pos);\r\n            }\r\n            this.visuals();\r\n        }\r\n        else {\r\n            if (!this.roomPlanner.memory.relocating && this.colony.level >= BarrierPlanner_1.settings.buildBarriersAtRCL\r\n                && this.roomPlanner.shouldRecheck(2)) {\r\n                this.buildMissingRamparts();\r\n                if (this.colony.layout == 'bunker' && this.colony.level >= 7) {\r\n                    this.buildMissingBunkerRamparts();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    visuals() {\r\n        for (const pos of this.barrierPositions) {\r\n            this.colony.room.visual.structure(pos.x, pos.y, STRUCTURE_RAMPART);\r\n        }\r\n    }\r\n};\r\nBarrierPlanner.settings = {\r\n    buildBarriersAtRCL: 3,\r\n    padding: 3,\r\n    bunkerizeRCL: 7\r\n};\r\nBarrierPlanner = BarrierPlanner_1 = tslib_1.__decorate([\r\n    profile\r\n], BarrierPlanner);\r\nexport { BarrierPlanner };\r\n","references":["C:/git/Overmind/src/algorithms/minCut.ts","C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/roomPlanner/layouts/bunker.ts","C:/git/Overmind/src/roomPlanner/RoomPlanner.ts"]}
