{"code":"import * as tslib_1 from \"tslib\";\r\nvar PairDestroyerOverlord_1;\r\nimport { CombatSetups, Roles } from '../../creepSetups/setups';\r\nimport { DirectiveTargetSiege } from '../../directives/targeting/siegeTarget';\r\nimport { CombatIntel } from '../../intel/CombatIntel';\r\nimport { RoomIntel } from '../../intel/RoomIntel';\r\nimport { Movement } from '../../movement/Movement';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { boostResources } from '../../resources/map_resources';\r\nimport { CombatTargeting } from '../../targeting/CombatTargeting';\r\nimport { Overlord } from '../Overlord';\r\n/**\r\n *  Destroyer overlord - spawns attacker/healer pairs for combat within a hostile room\r\n */\r\nlet PairDestroyerOverlord = PairDestroyerOverlord_1 = class PairDestroyerOverlord extends Overlord {\r\n    constructor(directive, priority = OverlordPriority.offense.destroy) {\r\n        super(directive, 'destroy', priority);\r\n        this.directive = directive;\r\n        this.attackers = this.combatZerg(Roles.melee, {\r\n            notifyWhenAttacked: false,\r\n            boostWishlist: [boostResources.attack[3], boostResources.tough[3], boostResources.move[3]]\r\n        });\r\n        this.healers = this.combatZerg(Roles.healer, {\r\n            notifyWhenAttacked: false,\r\n            boostWishlist: [boostResources.heal[3], boostResources.tough[3], boostResources.move[3],]\r\n        });\r\n    }\r\n    findTarget(attacker) {\r\n        if (this.room) {\r\n            // Prioritize specifically targeted structures first\r\n            const targetingDirectives = DirectiveTargetSiege.find(this.room.flags);\r\n            const targetedStructures = _.compact(_.map(targetingDirectives, directive => directive.getTarget()));\r\n            if (targetedStructures.length > 0) {\r\n                return CombatTargeting.findClosestReachable(attacker.pos, targetedStructures);\r\n            }\r\n            else {\r\n                // Target nearby hostile creeps\r\n                const creepTarget = CombatTargeting.findClosestHostile(attacker, true);\r\n                if (creepTarget)\r\n                    return creepTarget;\r\n                // Target nearby hostile structures\r\n                const structureTarget = CombatTargeting.findClosestPrioritizedStructure(attacker);\r\n                if (structureTarget)\r\n                    return structureTarget;\r\n            }\r\n        }\r\n    }\r\n    attackActions(attacker, healer) {\r\n        const target = this.findTarget(attacker);\r\n        if (target) {\r\n            if (attacker.pos.isNearTo(target)) {\r\n                attacker.attack(target);\r\n            }\r\n            else {\r\n                Movement.pairwiseMove(attacker, healer, target);\r\n                attacker.autoMelee();\r\n            }\r\n        }\r\n    }\r\n    handleSquad(attacker) {\r\n        const healer = attacker.findPartner(this.healers);\r\n        // Case 1: you don't have an active healer\r\n        if (!healer || healer.spawning || healer.needsBoosts) {\r\n            // Wait near the colony controller if you don't have a healer\r\n            if (attacker.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5) {\r\n                attacker.goTo(this.colony.controller, { range: 5 });\r\n            }\r\n            else {\r\n                attacker.park();\r\n            }\r\n        }\r\n        // Case 2: you have an active healer\r\n        else {\r\n            // Activate retreat condition if necessary\r\n            // Handle recovery if low on HP\r\n            if (attacker.needsToRecover(PairDestroyerOverlord_1.settings.retreatHitsPercent) ||\r\n                healer.needsToRecover(PairDestroyerOverlord_1.settings.retreatHitsPercent)) {\r\n                // Healer leads retreat to fallback position\r\n                Movement.pairwiseMove(healer, attacker, CombatIntel.getFallbackFrom(this.directive.pos));\r\n            }\r\n            else {\r\n                // Move to room and then perform attacking actions\r\n                if (!attacker.inSameRoomAs(this)) {\r\n                    Movement.pairwiseMove(attacker, healer, this.pos);\r\n                }\r\n                else {\r\n                    this.attackActions(attacker, healer);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    handleHealer(healer) {\r\n        // If there are no hostiles in the designated room, run medic actions\r\n        if (this.room && this.room.hostiles.length == 0 && this.room.hostileStructures.length == 0) {\r\n            healer.doMedicActions(this.room.name);\r\n            return;\r\n        }\r\n        const attacker = healer.findPartner(this.attackers);\r\n        // Case 1: you don't have an attacker partner\r\n        if (!attacker || attacker.spawning || attacker.needsBoosts) {\r\n            if (healer.hits < healer.hitsMax) {\r\n                healer.heal(healer);\r\n            }\r\n            // Wait near the colony controller if you don't have an attacker\r\n            if (healer.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5) {\r\n                healer.goTo(this.colony.controller, { range: 5 });\r\n            }\r\n            else {\r\n                healer.park();\r\n            }\r\n        }\r\n        // Case 2: you have an attacker partner\r\n        else {\r\n            if (attacker.hitsMax - attacker.hits > healer.hitsMax - healer.hits) {\r\n                healer.heal(attacker);\r\n            }\r\n            else {\r\n                healer.heal(healer);\r\n            }\r\n        }\r\n    }\r\n    init() {\r\n        let amount;\r\n        if (this.directive.memory.amount) {\r\n            amount = this.directive.memory.amount;\r\n        }\r\n        else {\r\n            amount = 1;\r\n        }\r\n        if (RoomIntel.inSafeMode(this.pos.roomName)) {\r\n            amount = 0;\r\n        }\r\n        const attackerPriority = this.attackers.length < this.healers.length ? this.priority - 0.1 : this.priority + 0.1;\r\n        const attackerSetup = this.canBoostSetup(CombatSetups.zerglings.boosted_T3) ? CombatSetups.zerglings.boosted_T3\r\n            : CombatSetups.zerglings.default;\r\n        this.wishlist(amount, attackerSetup, { priority: attackerPriority });\r\n        const healerPriority = this.healers.length < this.attackers.length ? this.priority - 0.1 : this.priority + 0.1;\r\n        const healerSetup = this.canBoostSetup(CombatSetups.healers.boosted_T3) ? CombatSetups.healers.boosted_T3\r\n            : CombatSetups.healers.default;\r\n        this.wishlist(amount, healerSetup, { priority: healerPriority });\r\n    }\r\n    run() {\r\n        for (const attacker of this.attackers) {\r\n            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions\r\n            if (attacker.hasValidTask) {\r\n                attacker.run();\r\n            }\r\n            else {\r\n                if (attacker.needsBoosts) {\r\n                    this.handleBoosting(attacker);\r\n                }\r\n                else {\r\n                    this.handleSquad(attacker);\r\n                }\r\n            }\r\n        }\r\n        for (const healer of this.healers) {\r\n            if (healer.hasValidTask) {\r\n                healer.run();\r\n            }\r\n            else {\r\n                if (healer.needsBoosts) {\r\n                    this.handleBoosting(healer);\r\n                }\r\n                else {\r\n                    this.handleHealer(healer);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nPairDestroyerOverlord.settings = {\r\n    retreatHitsPercent: 0.85,\r\n    reengageHitsPercent: 0.95,\r\n};\r\nPairDestroyerOverlord = PairDestroyerOverlord_1 = tslib_1.__decorate([\r\n    profile\r\n], PairDestroyerOverlord);\r\nexport { PairDestroyerOverlord };\r\n","references":["C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/directives/offense/pairDestroy.ts","C:/git/Overmind/src/directives/targeting/siegeTarget.ts","C:/git/Overmind/src/intel/CombatIntel.ts","C:/git/Overmind/src/intel/RoomIntel.ts","C:/git/Overmind/src/movement/Movement.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/resources/map_resources.ts","C:/git/Overmind/src/targeting/CombatTargeting.ts","C:/git/Overmind/src/zerg/CombatZerg.ts","C:/git/Overmind/src/overlords/Overlord.ts"]}
