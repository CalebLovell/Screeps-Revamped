{"code":"import * as tslib_1 from \"tslib\";\r\nimport { isStoreStructure } from '../../declarations/typeGuards';\r\nimport { HaulingOverlord } from '../../overlords/situational/hauler';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { Directive } from '../Directive';\r\n/**\r\n * Hauling directive: spawns hauler creeps to move large amounts of resourecs from a location (e.g. draining a storage)\r\n */\r\nlet DirectiveHaul = class DirectiveHaul extends Directive {\r\n    constructor(flag) {\r\n        super(flag);\r\n    }\r\n    spawnMoarOverlords() {\r\n        this.overlords.haul = new HaulingOverlord(this);\r\n    }\r\n    get targetedBy() {\r\n        return Overmind.cache.targets[this.ref];\r\n    }\r\n    get drops() {\r\n        if (!this.pos.isVisible) {\r\n            return {};\r\n        }\r\n        if (!this._drops) {\r\n            const drops = (this.pos.lookFor(LOOK_RESOURCES) || []);\r\n            this._drops = _.groupBy(drops, drop => drop.resourceType);\r\n        }\r\n        return this._drops;\r\n    }\r\n    get hasDrops() {\r\n        return _.keys(this.drops).length > 0;\r\n    }\r\n    get storeStructure() {\r\n        if (this.pos.isVisible) {\r\n            return this.pos.lookForStructure(STRUCTURE_STORAGE) ||\r\n                this.pos.lookForStructure(STRUCTURE_TERMINAL) ||\r\n                this.pos.lookForStructure(STRUCTURE_NUKER);\r\n        }\r\n        return undefined;\r\n    }\r\n    get store() {\r\n        if (!this._store) {\r\n            // Merge the \"storage\" of drops with the store of structure\r\n            let store = {};\r\n            if (this.storeStructure) {\r\n                if (isStoreStructure(this.storeStructure)) {\r\n                    store = this.storeStructure.store;\r\n                }\r\n                else {\r\n                    store = { energy: this.storeStructure.energy };\r\n                }\r\n            }\r\n            else {\r\n                store = { energy: 0 };\r\n            }\r\n            // Merge with drops\r\n            for (const resourceType of _.keys(this.drops)) {\r\n                const totalResourceAmount = _.sum(this.drops[resourceType], drop => drop.amount);\r\n                if (store[resourceType]) {\r\n                    store[resourceType] += totalResourceAmount;\r\n                }\r\n                else {\r\n                    store[resourceType] = totalResourceAmount;\r\n                }\r\n            }\r\n            this._store = store;\r\n        }\r\n        return this._store;\r\n    }\r\n    /**\r\n     * Total amount of resources remaining to be transported; cached into memory in case room loses visibility\r\n     */\r\n    get totalResources() {\r\n        if (this.pos.isVisible) {\r\n            this.memory.totalResources = _.sum(this.store); // update total amount remaining\r\n        }\r\n        else {\r\n            if (this.memory.totalResources == undefined) {\r\n                return 1000; // pick some non-zero number so that haulers will spawn\r\n            }\r\n        }\r\n        return this.memory.totalResources;\r\n    }\r\n    init() {\r\n        this.alert(`Haul directive active - ${this.totalResources}`);\r\n    }\r\n    run() {\r\n        if (this.totalResources == 0) {\r\n            this.remove();\r\n        }\r\n    }\r\n};\r\nDirectiveHaul.directiveName = 'haul';\r\nDirectiveHaul.color = COLOR_YELLOW;\r\nDirectiveHaul.secondaryColor = COLOR_BLUE;\r\nDirectiveHaul = tslib_1.__decorate([\r\n    profile\r\n], DirectiveHaul);\r\nexport { DirectiveHaul };\r\n","references":["C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/overlords/situational/hauler.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/directives/Directive.ts"]}
