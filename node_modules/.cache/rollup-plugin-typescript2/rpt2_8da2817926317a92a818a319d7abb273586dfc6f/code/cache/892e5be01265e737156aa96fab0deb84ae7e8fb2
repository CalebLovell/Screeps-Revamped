{"code":"import * as tslib_1 from \"tslib\";\r\nvar ExtractorOverlord_1;\r\nimport { $ } from '../../caching/GlobalCache';\r\nimport { log } from '../../console/log';\r\nimport { Roles, Setups } from '../../creepSetups/setups';\r\nimport { Pathing } from '../../movement/Pathing';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { Tasks } from '../../tasks/Tasks';\r\nimport { Overlord } from '../Overlord';\r\nconst BUILD_OUTPUT_FREQUENCY = 15;\r\n/**\r\n * Spawns extractors to harvest minerals in an owned or sourcekeeper room\r\n */\r\nlet ExtractorOverlord = ExtractorOverlord_1 = class ExtractorOverlord extends Overlord {\r\n    constructor(directive, priority) {\r\n        super(directive, 'mineral', priority);\r\n        this.directive = directive;\r\n        this.priority += this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;\r\n        this.drones = this.zerg(Roles.drone);\r\n        // Populate structures\r\n        this.populateStructures();\r\n    }\r\n    populateStructures() {\r\n        if (Game.rooms[this.pos.roomName]) {\r\n            this.extractor = this.pos.lookForStructure(STRUCTURE_EXTRACTOR);\r\n            this.mineral = this.pos.lookFor(LOOK_MINERALS)[0];\r\n            this.container = this.pos.findClosestByLimitedRange(Game.rooms[this.pos.roomName].containers, 1);\r\n        }\r\n    }\r\n    refresh() {\r\n        if (!this.room && Game.rooms[this.pos.roomName]) { // if you just gained vision of this room\r\n            this.populateStructures();\r\n        }\r\n        super.refresh();\r\n        $.refresh(this, 'extractor', 'mineral', 'container');\r\n    }\r\n    registerOutputRequests() {\r\n        if (this.container) {\r\n            if (_.sum(this.container.store) > 0.5 * this.container.storeCapacity ||\r\n                (_.sum(this.container.store) > 0 && this.drones.length == 0)) {\r\n                this.colony.logisticsNetwork.requestOutput(this.container, { resourceType: 'all' });\r\n            }\r\n        }\r\n    }\r\n    /* Calculate where the container output will be built for this site */\r\n    calculateContainerPos() {\r\n        // log.debug(`Computing container position for mining overlord at ${this.pos.print}...`);\r\n        let originPos;\r\n        if (this.colony.storage) {\r\n            originPos = this.colony.storage.pos;\r\n        }\r\n        else if (this.colony.roomPlanner.storagePos) {\r\n            originPos = this.colony.roomPlanner.storagePos;\r\n        }\r\n        if (originPos) {\r\n            const path = Pathing.findShortestPath(this.pos, originPos).path;\r\n            const pos = _.find(path, pos => pos.getRangeTo(this) == 1);\r\n            if (pos)\r\n                return pos;\r\n        }\r\n        // Shouldn't ever get here\r\n        log.warning(`Last resort container position calculation for ${this.print}!`);\r\n        return _.first(this.pos.availableNeighbors(true));\r\n    }\r\n    buildOutputIfNeeded() {\r\n        // Create container if there is not already one being built and no link\r\n        if (!this.container) {\r\n            const containerSite = _.first(_.filter(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2), site => site.structureType == STRUCTURE_CONTAINER));\r\n            if (!containerSite) {\r\n                const containerPos = this.calculateContainerPos();\r\n                log.info(`${this.print}: building container at ${containerPos.print}`);\r\n                const result = containerPos.createConstructionSite(STRUCTURE_CONTAINER);\r\n                if (result != OK) {\r\n                    log.error(`${this.print}: cannot build container at ${containerPos.print}! Result: ${result}`);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    init() {\r\n        const amount = this.mineral && this.mineral.mineralAmount > 0 ? this.mineral.pos.availableNeighbors().length : 0;\r\n        this.wishlist(Math.min(amount, ExtractorOverlord_1.settings.maxDrones), Setups.drones.extractor);\r\n        this.registerOutputRequests();\r\n    }\r\n    handleDrone(drone) {\r\n        // Ensure you are in the assigned room\r\n        if (drone.room == this.room && !drone.pos.isEdge) {\r\n            if (_.sum(drone.carry) == 0) {\r\n                drone.task = Tasks.harvest(this.mineral);\r\n            }\r\n            // Else see if there is an output to depsit to or to maintain\r\n            else if (this.container) {\r\n                drone.task = Tasks.transferAll(this.container);\r\n                // Move onto the output container if you're the only drone\r\n                if (!drone.pos.isEqualTo(this.container.pos) && this.drones.length == 1) {\r\n                    drone.goTo(this.container, { range: 0 });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            drone.goTo(this);\r\n        }\r\n    }\r\n    run() {\r\n        this.autoRun(this.drones, drone => this.handleDrone(drone), drone => drone.flee());\r\n        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY == 2) {\r\n            this.buildOutputIfNeeded();\r\n        }\r\n    }\r\n};\r\nExtractorOverlord.settings = {\r\n    maxDrones: 2,\r\n};\r\nExtractorOverlord = ExtractorOverlord_1 = tslib_1.__decorate([\r\n    profile\r\n], ExtractorOverlord);\r\nexport { ExtractorOverlord };\r\n","references":["C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/directives/resource/extract.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/tasks/Tasks.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/overlords/Overlord.ts"]}
