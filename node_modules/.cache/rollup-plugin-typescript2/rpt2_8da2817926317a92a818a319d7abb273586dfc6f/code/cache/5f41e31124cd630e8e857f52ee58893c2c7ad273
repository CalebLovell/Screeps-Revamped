{"code":"// Room intel - provides information related to room structure and occupation\r\nimport * as tslib_1 from \"tslib\";\r\nimport { bodyCost } from '../creepSetups/CreepSetup';\r\nimport { isCreep } from '../declarations/typeGuards';\r\nimport { profile } from '../profiler/decorator';\r\nimport { ExpansionEvaluator } from '../strategy/ExpansionEvaluator';\r\nimport { getCacheExpiration, irregularExponentialMovingAverage } from '../utilities/utils';\r\nimport { MY_USERNAME } from '../~settings';\r\nconst RECACHE_TIME = 2500;\r\nconst OWNED_RECACHE_TIME = 1000;\r\nconst ROOM_CREEP_HISTORY_TICKS = 25;\r\nconst SCORE_RECALC_PROB = 0.05;\r\nconst FALSE_SCORE_RECALC_PROB = 0.01;\r\nconst RoomIntelMemoryDefaults = {};\r\nlet RoomIntel = class RoomIntel {\r\n    /**\r\n     * Mark a room as being visible this tick\r\n     */\r\n    static markVisible(room) {\r\n        room.memory[\"T\" /* TICK */] = Game.time;\r\n    }\r\n    /**\r\n     * Returns the last tick at which the room was visible, or -100\r\n     */\r\n    static lastVisible(roomName) {\r\n        if (Memory.rooms[roomName]) {\r\n            return Memory.rooms[roomName][\"T\" /* TICK */] || -100;\r\n        }\r\n        else {\r\n            return -100;\r\n        }\r\n    }\r\n    /**\r\n     * Records all info for permanent room objects, e.g. sources, controllers, etc.\r\n     */\r\n    static recordPermanentObjects(room) {\r\n        const savedSources = [];\r\n        for (const source of room.sources) {\r\n            const container = source.pos.findClosestByLimitedRange(room.containers, 2);\r\n            savedSources.push({\r\n                c: source.pos.coordName,\r\n                contnr: container ? container.pos.coordName : undefined\r\n            });\r\n        }\r\n        room.memory[\"s\" /* SOURCES */] = savedSources;\r\n        room.memory[\"c\" /* CONTROLLER */] = room.controller ? {\r\n            c: room.controller.pos.coordName,\r\n            [\"l\" /* LEVEL */]: room.controller.level,\r\n            [\"o\" /* OWNER */]: room.controller.owner ? room.controller.owner.username : undefined,\r\n            [\"r\" /* RESERVATION */]: room.controller.reservation ?\r\n                {\r\n                    [\"u\" /* RES_USERNAME */]: room.controller.reservation.username,\r\n                    [\"t\" /* RES_TICKSTOEND */]: room.controller.reservation.ticksToEnd,\r\n                } : undefined,\r\n            [\"s\" /* SAFEMODE */]: room.controller.safeMode,\r\n            [\"sa\" /* SAFEMODE_AVAILABLE */]: room.controller.safeModeAvailable,\r\n            [\"sc\" /* SAFEMODE_COOLDOWN */]: room.controller.safeModeCooldown,\r\n            [\"p\" /* PROGRESS */]: room.controller.progress,\r\n            [\"pt\" /* PROGRESS_TOTAL */]: room.controller.progressTotal\r\n        } : undefined;\r\n        room.memory[\"m\" /* MINERAL */] = room.mineral ? {\r\n            c: room.mineral.pos.coordName,\r\n            [\"d\" /* DENSITY */]: room.mineral.density,\r\n            [\"t\" /* MINERALTYPE */]: room.mineral.mineralType\r\n        } : undefined;\r\n        room.memory[\"k\" /* SKLAIRS */] = _.map(room.keeperLairs, lair => {\r\n            return { c: lair.pos.coordName };\r\n        });\r\n        room.memory[\"pr\" /* PORTALS */] = _.map(room.portals, portal => {\r\n            const dest = portal.destination instanceof RoomPosition ? portal.destination.name\r\n                : portal.destination;\r\n            const expiration = portal.ticksToDecay != undefined ? Game.time + portal.ticksToDecay : Game.time + 1e6;\r\n            return { c: portal.pos.coordName, dest: dest, [\"X\" /* EXPIRATION */]: expiration };\r\n        });\r\n        if (room.controller && room.controller.owner) {\r\n            room.memory[\"i\" /* IMPORTANT_STRUCTURES */] = {\r\n                [\"t\" /* TOWERS */]: _.map(room.towers, t => t.pos.coordName),\r\n                [\"sp\" /* SPAWNS */]: _.map(room.spawns, s => s.pos.coordName),\r\n                [\"s\" /* STORAGE */]: room.storage ? room.storage.pos.coordName : undefined,\r\n                [\"e\" /* TERMINAL */]: room.terminal ? room.terminal.pos.coordName : undefined,\r\n                [\"w\" /* WALLS */]: _.map(room.walls, w => w.pos.coordName),\r\n                [\"r\" /* RAMPARTS */]: _.map(room.ramparts, r => r.pos.coordName),\r\n            };\r\n        }\r\n        else {\r\n            room.memory[\"i\" /* IMPORTANT_STRUCTURES */] = undefined;\r\n        }\r\n        room.memory[\"T\" /* TICK */] = Game.time;\r\n    }\r\n    /**\r\n     * Update time-sensitive reservation and safemode info\r\n     */\r\n    static recordControllerInfo(controller) {\r\n        const savedController = controller.room.memory[\"c\" /* CONTROLLER */];\r\n        if (savedController) {\r\n            savedController[\"r\" /* RESERVATION */] = controller.reservation ? {\r\n                [\"u\" /* RES_USERNAME */]: controller.reservation.username,\r\n                [\"t\" /* RES_TICKSTOEND */]: controller.reservation.ticksToEnd,\r\n            } : undefined;\r\n            savedController[\"s\" /* SAFEMODE */] = controller.safeMode;\r\n            savedController[\"sc\" /* SAFEMODE_COOLDOWN */] = controller.safeModeCooldown;\r\n        }\r\n    }\r\n    static inSafeMode(roomName) {\r\n        if (!!Memory.rooms[roomName] && !!Memory.rooms[roomName][\"c\" /* CONTROLLER */]) {\r\n            const safemode = Memory.rooms[roomName][\"c\" /* CONTROLLER */][\"s\" /* SAFEMODE */];\r\n            const tick = Memory.rooms[roomName][\"X\" /* EXPIRATION */];\r\n            if (safemode && tick) {\r\n                return Game.time < tick + safemode;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    static safeModeCooldown(roomName) {\r\n        if (Memory.rooms[roomName] && Memory.rooms[roomName][\"c\" /* CONTROLLER */] &&\r\n            Memory.rooms[roomName][\"c\" /* CONTROLLER */][\"sc\" /* SAFEMODE_COOLDOWN */]) {\r\n            const smcooldown = Memory.rooms[roomName][\"c\" /* CONTROLLER */][\"sc\" /* SAFEMODE_COOLDOWN */];\r\n            const tick = Memory.rooms[roomName][\"X\" /* EXPIRATION */];\r\n            if (smcooldown && tick) {\r\n                return smcooldown - (Game.time - tick);\r\n            }\r\n        }\r\n    }\r\n    static recomputeScoreIfNecessary(room) {\r\n        if (room.memory[\"e\" /* EXPANSION_DATA */] == false) { // room is uninhabitable or owned\r\n            if (Math.random() < FALSE_SCORE_RECALC_PROB) {\r\n                // false scores get evaluated very occasionally\r\n                return ExpansionEvaluator.computeExpansionData(room);\r\n            }\r\n        }\r\n        else { // if the room is not uninhabitable\r\n            if (!room.memory[\"e\" /* EXPANSION_DATA */] || Math.random() < SCORE_RECALC_PROB) {\r\n                // recompute some of the time\r\n                return ExpansionEvaluator.computeExpansionData(room);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    static updateInvasionData(room) {\r\n        if (!room.memory[\"v\" /* INVASION_DATA */]) {\r\n            room.memory[\"v\" /* INVASION_DATA */] = {\r\n                harvested: 0,\r\n                lastSeen: 0,\r\n            };\r\n        }\r\n        const sources = room.sources;\r\n        const invasionData = room.memory[\"v\" /* INVASION_DATA */];\r\n        for (const source of sources) {\r\n            if (source.ticksToRegeneration == 1) {\r\n                invasionData.harvested += source.energyCapacity - source.energy;\r\n            }\r\n        }\r\n        if (room.invaders.length > 0) {\r\n            invasionData.harvested = 0;\r\n            invasionData.lastSeen = Game.time;\r\n        }\r\n    }\r\n    static updateHarvestData(room) {\r\n        if (!room.memory[\"h\" /* HARVEST */]) {\r\n            room.memory[\"h\" /* HARVEST */] = {\r\n                [\"a\" /* AMOUNT */]: 0,\r\n                [\"D\" /* AVG10K */]: _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),\r\n                [\"H\" /* AVG100K */]: _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),\r\n                [\"M\" /* AVG1M */]: _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),\r\n                [\"T\" /* TICK */]: Game.time,\r\n            };\r\n        }\r\n        const harvest = room.memory[\"h\" /* HARVEST */];\r\n        for (const source of room.sources) { // TODO: this implicitly assumes all energy is harvested by me\r\n            if (source.ticksToRegeneration == 1) {\r\n                const dEnergy = source.energyCapacity - source.energy;\r\n                const dTime = Game.time - harvest[\"T\" /* TICK */] + 1; // +1 to avoid division by zero errors\r\n                harvest[\"a\" /* AMOUNT */] += dEnergy;\r\n                harvest[\"D\" /* AVG10K */] = +(irregularExponentialMovingAverage(dEnergy / dTime, harvest[\"D\" /* AVG10K */], dTime, 10000)).toFixed(7);\r\n                harvest[\"H\" /* AVG100K */] = +(irregularExponentialMovingAverage(dEnergy / dTime, harvest[\"D\" /* AVG10K */], dTime, 100000)).toFixed(7);\r\n                harvest[\"M\" /* AVG1M */] = +(irregularExponentialMovingAverage(dEnergy / dTime, harvest[\"D\" /* AVG10K */], dTime, 1000000)).toFixed(7);\r\n                harvest[\"T\" /* TICK */] = Game.time;\r\n            }\r\n        }\r\n    }\r\n    static updateCasualtyData(room) {\r\n        if (!room.memory[\"d\" /* CASUALTIES */]) {\r\n            room.memory[\"d\" /* CASUALTIES */] = {\r\n                cost: {\r\n                    [\"a\" /* AMOUNT */]: 0,\r\n                    [\"D\" /* AVG10K */]: 0,\r\n                    [\"H\" /* AVG100K */]: 0,\r\n                    [\"M\" /* AVG1M */]: 0,\r\n                    [\"T\" /* TICK */]: Game.time,\r\n                }\r\n            };\r\n        }\r\n        const casualtiesCost = room.memory[\"d\" /* CASUALTIES */].cost;\r\n        for (const tombstone of room.tombstones) {\r\n            if (tombstone.ticksToDecay == 1) {\r\n                // record any casualties, which are my creeps which died prematurely\r\n                if ((tombstone.creep.ticksToLive || 0) > 1 && tombstone.creep.owner.username == MY_USERNAME\r\n                    && isCreep(tombstone.creep)) {\r\n                    const body = _.map(tombstone.creep.body, part => part.type);\r\n                    const lifetime = body.includes(CLAIM) ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;\r\n                    const dCost = bodyCost(body) * (tombstone.creep.ticksToLive || 0) / lifetime;\r\n                    const dTime = Game.time - casualtiesCost[\"T\" /* TICK */] + 1;\r\n                    casualtiesCost[\"a\" /* AMOUNT */] += dCost;\r\n                    casualtiesCost[\"D\" /* AVG10K */] = +(irregularExponentialMovingAverage(dCost / dTime, casualtiesCost[\"D\" /* AVG10K */], dTime, 10000)).toFixed(7);\r\n                    casualtiesCost[\"H\" /* AVG100K */] = +(irregularExponentialMovingAverage(dCost / dTime, casualtiesCost[\"H\" /* AVG100K */], dTime, 100000)).toFixed(7);\r\n                    casualtiesCost[\"M\" /* AVG1M */] = +(irregularExponentialMovingAverage(dCost / dTime, casualtiesCost[\"M\" /* AVG1M */], dTime, 1000000)).toFixed(7);\r\n                    casualtiesCost[\"T\" /* TICK */] = Game.time;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get the pos a creep was in on the previous tick\r\n     */\r\n    static getPreviousPos(creep) {\r\n        if (creep.room.memory[\"p\" /* PREV_POSITIONS */] && creep.room.memory[\"p\" /* PREV_POSITIONS */][creep.id]) {\r\n            return derefRoomPosition(creep.room.memory[\"p\" /* PREV_POSITIONS */][creep.id]);\r\n        }\r\n        else {\r\n            return creep.pos; // no data\r\n        }\r\n    }\r\n    static recordCreepPositions(room) {\r\n        room.memory[\"p\" /* PREV_POSITIONS */] = {};\r\n        for (const creep of room.find(FIND_CREEPS)) {\r\n            room.memory[\"p\" /* PREV_POSITIONS */][creep.id] = creep.pos;\r\n        }\r\n    }\r\n    static recordCreepOccupancies(room) {\r\n        if (!room.memory[\"cr\" /* CREEPS_IN_ROOM */]) {\r\n            room.memory[\"cr\" /* CREEPS_IN_ROOM */] = {};\r\n        }\r\n        const creepsInRoom = room.memory[\"cr\" /* CREEPS_IN_ROOM */];\r\n        for (const tick in creepsInRoom) {\r\n            if (parseInt(tick, 10) < Game.time - ROOM_CREEP_HISTORY_TICKS) {\r\n                delete creepsInRoom[tick];\r\n            }\r\n        }\r\n        creepsInRoom[Game.time] = _.map(room.hostiles, creep => creep.name);\r\n    }\r\n    static recordSafety(room) {\r\n        if (!room.memory[\"f\" /* SAFETY */]) {\r\n            room.memory[\"f\" /* SAFETY */] = {\r\n                safeFor: 0,\r\n                unsafeFor: 0,\r\n                safety1k: 1,\r\n                safety10k: 1,\r\n                tick: Game.time\r\n            };\r\n        }\r\n        let safety;\r\n        const safetyData = room.memory[\"f\" /* SAFETY */];\r\n        if (room.dangerousHostiles.length > 0) {\r\n            safetyData.safeFor = 0;\r\n            safetyData.unsafeFor += 1;\r\n            safety = 0;\r\n        }\r\n        else {\r\n            safetyData.safeFor += 1;\r\n            safetyData.unsafeFor = 0;\r\n            safety = 1;\r\n        }\r\n        // Compute rolling averages\r\n        const dTime = Game.time - safetyData.tick;\r\n        safetyData.safety1k = +(irregularExponentialMovingAverage(safety, safetyData.safety1k, dTime, 1000)).toFixed(5);\r\n        safetyData.safety10k = +(irregularExponentialMovingAverage(safety, safetyData.safety10k, dTime, 10000)).toFixed(5);\r\n        safetyData.tick = Game.time;\r\n    }\r\n    static getSafetyData(roomName) {\r\n        if (!Memory.rooms[roomName]) {\r\n            Memory.rooms[roomName] = {};\r\n        }\r\n        if (!Memory.rooms[roomName][\"f\" /* SAFETY */]) {\r\n            Memory.rooms[roomName][\"f\" /* SAFETY */] = {\r\n                safeFor: 0,\r\n                unsafeFor: 0,\r\n                safety1k: 1,\r\n                safety10k: 1,\r\n                tick: Game.time\r\n            };\r\n        }\r\n        return Memory.rooms[roomName][\"f\" /* SAFETY */];\r\n    }\r\n    static isInvasionLikely(room) {\r\n        const data = room.memory[\"v\" /* INVASION_DATA */];\r\n        if (!data)\r\n            return false;\r\n        if (data.lastSeen > 20000) { // maybe room is surrounded by owned/reserved rooms and invasions aren't possible\r\n            return false;\r\n        }\r\n        switch (room.sources.length) {\r\n            case 1:\r\n                return data.harvested > 90000;\r\n            case 2:\r\n                return data.harvested > 75000;\r\n            case 3:\r\n                return data.harvested > 65000;\r\n            default: // shouldn't ever get here\r\n                return false;\r\n        }\r\n    }\r\n    static roomOwnedBy(roomName) {\r\n        if (Memory.rooms[roomName] && Memory.rooms[roomName][\"c\" /* CONTROLLER */] &&\r\n            Memory.rooms[roomName][\"c\" /* CONTROLLER */][\"o\" /* OWNER */]) {\r\n            if (Game.time - (Memory.rooms[roomName][\"T\" /* TICK */] || 0) < 25000) { // ownership expires after 25k ticks\r\n                return Memory.rooms[roomName][\"c\" /* CONTROLLER */][\"o\" /* OWNER */];\r\n            }\r\n        }\r\n    }\r\n    static roomReservedBy(roomName) {\r\n        if (Memory.rooms[roomName] && Memory.rooms[roomName][\"c\" /* CONTROLLER */] &&\r\n            Memory.rooms[roomName][\"c\" /* CONTROLLER */][\"r\" /* RESERVATION */]) {\r\n            if (Game.time - (Memory.rooms[roomName][\"T\" /* TICK */] || 0) < 10000) { // reservation expires after 10k ticks\r\n                return Memory.rooms[roomName][\"c\" /* CONTROLLER */][\"r\" /* RESERVATION */][\"u\" /* RES_USERNAME */];\r\n            }\r\n        }\r\n    }\r\n    static roomReservationRemaining(roomName) {\r\n        if (Memory.rooms[roomName] && Memory.rooms[roomName][\"c\" /* CONTROLLER */] &&\r\n            Memory.rooms[roomName][\"c\" /* CONTROLLER */][\"r\" /* RESERVATION */]) {\r\n            const ticksToEnd = Memory.rooms[roomName][\"c\" /* CONTROLLER */][\"r\" /* RESERVATION */][\"t\" /* RES_TICKSTOEND */];\r\n            const timeSinceLastSeen = Game.time - (Memory.rooms[roomName][\"T\" /* TICK */] || 0);\r\n            return ticksToEnd - timeSinceLastSeen;\r\n        }\r\n        return 0;\r\n    }\r\n    static run() {\r\n        let alreadyComputedScore = false;\r\n        for (const name in Game.rooms) {\r\n            const room = Game.rooms[name];\r\n            this.markVisible(room);\r\n            this.recordSafety(room);\r\n            // Track invasion data, harvesting, and casualties for all colony rooms and outposts\r\n            if (Overmind.colonyMap[room.name]) { // if it is an owned or outpost room\r\n                this.updateInvasionData(room);\r\n                this.updateHarvestData(room);\r\n                this.updateCasualtyData(room);\r\n            }\r\n            // Record previous creep positions if needed (RoomIntel.run() is executed at end of each tick)\r\n            if (room.hostiles.length > 0) {\r\n                this.recordCreepPositions(room);\r\n                if (room.my) {\r\n                    this.recordCreepOccupancies(room);\r\n                }\r\n            }\r\n            // Record location of permanent objects in room and recompute score as needed\r\n            if (Game.time >= (room.memory[\"X\" /* EXPIRATION */] || 0)) {\r\n                this.recordPermanentObjects(room);\r\n                if (!alreadyComputedScore) {\r\n                    alreadyComputedScore = this.recomputeScoreIfNecessary(room);\r\n                }\r\n                // Refresh cache\r\n                const recacheTime = room.owner ? OWNED_RECACHE_TIME : RECACHE_TIME;\r\n                room.memory[\"X\" /* EXPIRATION */] = getCacheExpiration(recacheTime, 250);\r\n            }\r\n            if (room.controller && Game.time % 5 == 0) {\r\n                this.recordControllerInfo(room.controller);\r\n            }\r\n        }\r\n    }\r\n};\r\nRoomIntel = tslib_1.__decorate([\r\n    profile\r\n], RoomIntel);\r\nexport { RoomIntel };\r\n// For debugging purposes\r\nglobal.RoomIntel = RoomIntel;\r\n","references":["C:/git/Overmind/src/creepSetups/CreepSetup.ts","C:/git/Overmind/src/declarations/typeGuards.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/strategy/ExpansionEvaluator.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/~settings.ts"]}
