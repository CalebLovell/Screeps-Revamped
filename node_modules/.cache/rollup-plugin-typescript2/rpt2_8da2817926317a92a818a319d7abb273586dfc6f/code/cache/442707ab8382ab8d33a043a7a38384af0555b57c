{"code":"import * as tslib_1 from \"tslib\";\r\nimport { $ } from '../caching/GlobalCache';\r\nimport { ColonyStage } from '../Colony';\r\nimport { log } from '../console/log';\r\nimport { bodyCost } from '../creepSetups/CreepSetup';\r\nimport { Mem } from '../memory/Memory';\r\nimport { Movement } from '../movement/Movement';\r\nimport { Pathing } from '../movement/Pathing';\r\nimport { QueenOverlord } from '../overlords/core/queen';\r\nimport { BunkerQueenOverlord } from '../overlords/core/queen_bunker';\r\nimport { Priority } from '../priorities/priorities';\r\nimport { profile } from '../profiler/decorator';\r\nimport { energyStructureOrder, getPosFromBunkerCoord, insideBunkerBounds } from '../roomPlanner/layouts/bunker';\r\nimport { Stats } from '../stats/stats';\r\nimport { exponentialMovingAverage, hasMinerals } from '../utilities/utils';\r\nimport { Visualizer } from '../visuals/Visualizer';\r\nimport { HiveCluster } from './_HiveCluster';\r\nconst ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH = -20;\r\nconst ERR_SPECIFIED_SPAWN_BUSY = -21;\r\nconst HatcheryMemoryDefaults = {\r\n    stats: {\r\n        overload: 0,\r\n        uptime: 0,\r\n        longUptime: 0,\r\n    }\r\n};\r\n/**\r\n * The hatchery encompasses all spawning-related structures, like spawns, extensions, and some energy buffer containers,\r\n * and contains logic for spawning the creeps requested by overlords\r\n */\r\nlet Hatchery = class Hatchery extends HiveCluster {\r\n    constructor(colony, headSpawn) {\r\n        super(colony, headSpawn, 'hatchery');\r\n        // Register structure components\r\n        this.memory = Mem.wrap(this.colony.memory, 'hatchery', HatcheryMemoryDefaults, true);\r\n        if (this.colony.layout == 'twoPart')\r\n            this.colony.destinations.push({ pos: this.pos, order: -1 });\r\n        this.spawns = colony.spawns;\r\n        this.availableSpawns = _.filter(this.spawns, spawn => !spawn.spawning);\r\n        this.extensions = colony.extensions;\r\n        this.towers = colony.commandCenter ? _.difference(colony.towers, colony.commandCenter.towers) : colony.towers;\r\n        if (this.colony.layout == 'bunker') {\r\n            this.battery = _.first(_.filter(this.room.containers, cont => insideBunkerBounds(cont.pos, this.colony)));\r\n            $.set(this, 'energyStructures', () => this.computeEnergyStructures());\r\n        }\r\n        else {\r\n            this.link = this.pos.findClosestByLimitedRange(colony.availableLinks, 2);\r\n            this.colony.linkNetwork.claimLink(this.link);\r\n            this.battery = this.pos.findClosestByLimitedRange(this.room.containers, 2);\r\n            this.energyStructures = [].concat(this.spawns, this.extensions);\r\n        }\r\n        this.productionPriorities = [];\r\n        this.productionQueue = {};\r\n        this.isOverloaded = false;\r\n        this.settings = {\r\n            refillTowersBelow: 750,\r\n            linksRequestEnergyBelow: 0,\r\n            suppressSpawning: false,\r\n        };\r\n        this.transportRequests = colony.transportRequests; // hatchery always uses colony transport group\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(this.colony.memory, 'hatchery', HatcheryMemoryDefaults, true);\r\n        $.refreshRoom(this);\r\n        $.refresh(this, 'spawns', 'extensions', 'energyStructures', 'link', 'towers', 'battery');\r\n        this.availableSpawns = _.filter(this.spawns, spawn => !spawn.spawning);\r\n        this.isOverloaded = false;\r\n        this.productionPriorities = [];\r\n        this.productionQueue = {};\r\n    }\r\n    spawnMoarOverlords() {\r\n        if (this.colony.layout == 'bunker' && (this.colony.storage || this.colony.terminal)\r\n            && this.colony.assets[RESOURCE_ENERGY] > 10000) {\r\n            this.overlord = new BunkerQueenOverlord(this); // use bunker queen if has storage and enough energy\r\n        }\r\n        else {\r\n            this.overlord = new QueenOverlord(this);\r\n        }\r\n    }\r\n    // Idle position for queen\r\n    get idlePos() {\r\n        if (this.battery) {\r\n            return this.battery.pos;\r\n        }\r\n        else {\r\n            return this.spawns[0].pos.availableNeighbors(true)[0];\r\n        }\r\n    }\r\n    computeEnergyStructures() {\r\n        if (this.colony.layout == 'bunker') {\r\n            const positions = _.map(energyStructureOrder, coord => getPosFromBunkerCoord(coord, this.colony));\r\n            let spawnsAndExtensions = [];\r\n            spawnsAndExtensions = spawnsAndExtensions.concat(this.spawns, this.extensions);\r\n            const energyStructures = [];\r\n            for (const pos of positions) {\r\n                const structure = _.find(pos.lookFor(LOOK_STRUCTURES), s => s.structureType == STRUCTURE_SPAWN\r\n                    || s.structureType == STRUCTURE_EXTENSION);\r\n                if (structure) {\r\n                    energyStructures.push(_.remove(spawnsAndExtensions, s => s.id == structure.id)[0]);\r\n                }\r\n            }\r\n            return _.compact(energyStructures.concat(spawnsAndExtensions));\r\n        }\r\n        else {\r\n            // Ugly workaround to [].concat() throwing a temper tantrum\r\n            let spawnsAndExtensions = [];\r\n            spawnsAndExtensions = spawnsAndExtensions.concat(this.spawns, this.extensions);\r\n            return _.sortBy(spawnsAndExtensions, structure => structure.pos.getRangeTo(this.idlePos));\r\n        }\r\n    }\r\n    /* Request more energy when appropriate either via link or hauler */\r\n    registerEnergyRequests() {\r\n        // Register requests for input into the hatchery (goes on colony store group)\r\n        if (this.link && this.link.isEmpty) {\r\n            this.colony.linkNetwork.requestReceive(this.link);\r\n        }\r\n        if (this.battery) {\r\n            const threshold = this.colony.stage == ColonyStage.Larva ? 0.75 : 0.5;\r\n            if (this.battery.energy < threshold * this.battery.storeCapacity) {\r\n                this.colony.logisticsNetwork.requestInput(this.battery, { multiplier: 1.5 });\r\n            }\r\n            // get rid of any minerals in the container if present\r\n            if (hasMinerals(this.battery.store)) {\r\n                this.colony.logisticsNetwork.requestOutputMinerals(this.battery);\r\n            }\r\n        }\r\n        // Register energy transport requests (goes on hatchery store group, which can be colony store group)\r\n        // let refillStructures = this.energyStructures;\r\n        // if (this.colony.defcon > DEFCON.safe) {\r\n        // \tfor (let hostile of this.room.dangerousHostiles) {\r\n        // \t\t// TODO: remove tranport requests if blocked by enemies\r\n        // \t}\r\n        // }\r\n        // if (this.room.defcon > 0) {refillStructures = _.filter()}\r\n        _.forEach(this.energyStructures, struct => this.transportRequests.requestInput(struct, Priority.NormalLow));\r\n        // let refillSpawns = _.filter(this.spawns, spawn => spawn.energy < spawn.energyCapacity);\r\n        // let refillExtensions = _.filter(this.extensions, extension => extension.energy < extension.energyCapacity);\r\n        const refillTowers = _.filter(this.towers, tower => tower.energy < this.settings.refillTowersBelow);\r\n        // _.forEach(refillSpawns, spawn => this.transportRequests.requestInput(spawn, Priority.NormalLow));\r\n        // _.forEach(refillExtensions, extension => this.transportRequests.requestInput(extension, Priority.NormalLow));\r\n        _.forEach(refillTowers, tower => this.transportRequests.requestInput(tower, Priority.NormalLow));\r\n    }\r\n    // Creep queueing and spawning =====================================================================================\r\n    generateCreepName(roleName) {\r\n        // Generate a creep name based on the role and add a suffix to make it unique\r\n        let i = 0;\r\n        while (Game.creeps[(roleName + '_' + i)]) {\r\n            i++;\r\n        }\r\n        return (roleName + '_' + i);\r\n    }\r\n    spawnCreep(protoCreep, options = {}) {\r\n        // get a spawn to use\r\n        let spawnToUse;\r\n        if (options.spawn) {\r\n            spawnToUse = options.spawn;\r\n            if (spawnToUse.spawning) {\r\n                return ERR_SPECIFIED_SPAWN_BUSY;\r\n            }\r\n            else {\r\n                _.remove(this.availableSpawns, spawn => spawn.id == spawnToUse.id); // mark as used\r\n            }\r\n        }\r\n        else {\r\n            spawnToUse = this.availableSpawns.shift();\r\n        }\r\n        if (spawnToUse) { // if there is a spawn, create the creep\r\n            if (this.colony.bunker && this.colony.bunker.coreSpawn\r\n                && spawnToUse.id == this.colony.bunker.coreSpawn.id && !options.directions) {\r\n                options.directions = [TOP, RIGHT]; // don't spawn into the manager spot\r\n            }\r\n            protoCreep.name = this.generateCreepName(protoCreep.name); // modify the creep name to make it unique\r\n            if (bodyCost(protoCreep.body) > this.room.energyCapacityAvailable) {\r\n                return ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH;\r\n            }\r\n            protoCreep.memory.data.origin = spawnToUse.pos.roomName;\r\n            const result = spawnToUse.spawnCreep(protoCreep.body, protoCreep.name, {\r\n                memory: protoCreep.memory,\r\n                energyStructures: this.energyStructures,\r\n                directions: options.directions\r\n            });\r\n            if (result == OK) {\r\n                return result;\r\n            }\r\n            else {\r\n                this.availableSpawns.unshift(spawnToUse); // return the spawn to the available spawns list\r\n                return result;\r\n            }\r\n        }\r\n        else { // otherwise, return busy\r\n            return ERR_BUSY;\r\n        }\r\n    }\r\n    canSpawn(body) {\r\n        return bodyCost(body) <= this.room.energyCapacityAvailable;\r\n    }\r\n    canSpawnZerg(zerg) {\r\n        return this.canSpawn(_.map(zerg.body, part => part.type));\r\n    }\r\n    /* Generate (but not spawn) the largest creep possible, returns the protoCreep as an object */\r\n    generateProtoCreep(setup, overlord) {\r\n        // Generate the creep body\r\n        let creepBody;\r\n        // if (overlord.colony.incubator) { // if you're being incubated, build as big a creep as you want\r\n        // \tcreepBody = setup.generateBody(overlord.colony.incubator.room.energyCapacityAvailable);\r\n        // } else { // otherwise limit yourself to actual energy constraints\r\n        creepBody = setup.generateBody(this.room.energyCapacityAvailable);\r\n        // }\r\n        // Generate the creep memory\r\n        const creepMemory = {\r\n            [\"C\" /* COLONY */]: overlord.colony.name,\r\n            [\"O\" /* OVERLORD */]: overlord.ref,\r\n            role: setup.role,\r\n            task: null,\r\n            data: {\r\n                origin: '',\r\n            },\r\n        };\r\n        // Create the protocreep and return it\r\n        const protoCreep = {\r\n            body: creepBody,\r\n            name: setup.role,\r\n            memory: creepMemory,\r\n        };\r\n        return protoCreep;\r\n    }\r\n    /* Returns the approximate aggregated time at which the hatchery will next be available to spawn something */\r\n    get nextAvailability() {\r\n        if (!this._nextAvailability) {\r\n            const allQueued = _.flatten(_.values(this.productionQueue));\r\n            const queuedSpawnTime = _.sum(allQueued, order => order.protoCreep.body.length) * CREEP_SPAWN_TIME;\r\n            const activeSpawnTime = _.sum(this.spawns, spawn => spawn.spawning ? spawn.spawning.remainingTime : 0);\r\n            this._nextAvailability = (activeSpawnTime + queuedSpawnTime) / this.spawns.length;\r\n        }\r\n        return this._nextAvailability;\r\n    }\r\n    // /* Number of ticks required to make everything in spawn queue divided by number of spawns */\r\n    // get queuedSpawnTime(): number {\r\n    // \tif (!this._queuedSpawnTime) {\r\n    // \t\tlet allQueued = _.flatten(_.values(this.productionQueue)) as SpawnOrder[];\r\n    // \t\tlet queuedSpawnTime = _.sum(allQueued, order => order.protoCreep.body.length) * CREEP_SPAWN_TIME;\r\n    // \t\tthis._queuedSpawnTime = queuedSpawnTime / this.spawns.length;\r\n    // \t}\r\n    // \treturn this._queuedSpawnTime;\r\n    // }\r\n    /* Enqueues a request to the hatchery */\r\n    enqueue(request) {\r\n        const protoCreep = this.generateProtoCreep(request.setup, request.overlord);\r\n        const priority = request.priority;\r\n        if (this.canSpawn(protoCreep.body) && protoCreep.body.length > 0) {\r\n            // Spawn the creep yourself if you can\r\n            this._nextAvailability = undefined; // invalidate cache\r\n            // this._queuedSpawnTime = undefined;\r\n            if (!this.productionQueue[priority]) {\r\n                this.productionQueue[priority] = [];\r\n                this.productionPriorities.push(priority); // this is necessary because keys interpret number as string\r\n            }\r\n            this.productionQueue[priority].push({ protoCreep: protoCreep, options: request.options });\r\n        }\r\n        else {\r\n            log.debug(`${this.room.print}: cannot spawn creep ${protoCreep.name} with body ` +\r\n                `${JSON.stringify(protoCreep.body)}!`);\r\n        }\r\n    }\r\n    spawnHighestPriorityCreep() {\r\n        const sortedKeys = _.sortBy(this.productionPriorities);\r\n        for (const priority of sortedKeys) {\r\n            // if (this.colony.defcon >= DEFCON.playerInvasion\r\n            // \t&& !this.colony.controller.safeMode\r\n            // \t&& priority > OverlordPriority.warSpawnCutoff) {\r\n            // \tcontinue; // don't spawn non-critical creeps during wartime\r\n            // }\r\n            const nextOrder = this.productionQueue[priority].shift();\r\n            if (nextOrder) {\r\n                const { protoCreep, options } = nextOrder;\r\n                const result = this.spawnCreep(protoCreep, options);\r\n                if (result == OK) {\r\n                    return result;\r\n                }\r\n                else if (result == ERR_SPECIFIED_SPAWN_BUSY) {\r\n                    return result; // continue to spawn other things while waiting on specified spawn\r\n                }\r\n                else {\r\n                    // If there's not enough energyCapacity to spawn, ignore it and move on, otherwise block and wait\r\n                    if (result != ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH) {\r\n                        this.productionQueue[priority].unshift(nextOrder);\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    handleSpawns() {\r\n        // Spawn all queued creeps that you can\r\n        while (this.availableSpawns.length > 0) {\r\n            const result = this.spawnHighestPriorityCreep();\r\n            if (result == ERR_NOT_ENOUGH_ENERGY) { // if you can't spawn something you want to\r\n                this.isOverloaded = true;\r\n            }\r\n            if (result != OK && result != ERR_SPECIFIED_SPAWN_BUSY) {\r\n                // Can't spawn creep right now\r\n                break;\r\n            }\r\n        }\r\n        // Move creeps off of exit position to let the spawning creep out if necessary\r\n        for (const spawn of this.spawns) {\r\n            if (spawn.spawning && spawn.spawning.remainingTime <= 1\r\n                && spawn.pos.findInRange(FIND_MY_CREEPS, 1).length > 0) {\r\n                let directions;\r\n                if (spawn.spawning.directions) {\r\n                    directions = spawn.spawning.directions;\r\n                }\r\n                else {\r\n                    directions = _.map(spawn.pos.availableNeighbors(true), pos => spawn.pos.getDirectionTo(pos));\r\n                }\r\n                const exitPos = Pathing.positionAtDirection(spawn.pos, _.first(directions));\r\n                Movement.vacatePos(exitPos);\r\n            }\r\n        }\r\n    }\r\n    // Runtime operation ===============================================================================================\r\n    init() {\r\n        this.registerEnergyRequests();\r\n    }\r\n    run() {\r\n        if (!this.settings.suppressSpawning) {\r\n            this.handleSpawns();\r\n        }\r\n        this.recordStats();\r\n    }\r\n    recordStats() {\r\n        // Compute uptime and overload status\r\n        const spawnUsageThisTick = _.filter(this.spawns, spawn => spawn.spawning).length / this.spawns.length;\r\n        const uptime = exponentialMovingAverage(spawnUsageThisTick, this.memory.stats.uptime, CREEP_LIFE_TIME);\r\n        const longUptime = exponentialMovingAverage(spawnUsageThisTick, this.memory.stats.longUptime, 5 * CREEP_LIFE_TIME);\r\n        const overload = exponentialMovingAverage(this.isOverloaded ? 1 : 0, this.memory.stats.overload, CREEP_LIFE_TIME);\r\n        Stats.log(`colonies.${this.colony.name}.hatchery.uptime`, uptime);\r\n        Stats.log(`colonies.${this.colony.name}.hatchery.overload`, overload);\r\n        this.memory.stats = { overload, uptime, longUptime };\r\n    }\r\n    visuals(coord) {\r\n        let { x, y } = coord;\r\n        const spawning = [];\r\n        const spawnProgress = [];\r\n        _.forEach(this.spawns, function (spawn) {\r\n            if (spawn.spawning) {\r\n                spawning.push(spawn.spawning.name.split('_')[0]);\r\n                const timeElapsed = spawn.spawning.needTime - spawn.spawning.remainingTime;\r\n                spawnProgress.push([timeElapsed, spawn.spawning.needTime]);\r\n            }\r\n        });\r\n        const boxCoords = Visualizer.section(`${this.colony.name} Hatchery`, { x, y, roomName: this.room.name }, 9.5, 3 + spawning.length + .1);\r\n        const boxX = boxCoords.x;\r\n        y = boxCoords.y + 0.25;\r\n        // Log energy\r\n        Visualizer.text('Energy', { x: boxX, y: y, roomName: this.room.name });\r\n        Visualizer.barGraph([this.room.energyAvailable, this.room.energyCapacityAvailable], { x: boxX + 4, y: y, roomName: this.room.name }, 5);\r\n        y += 1;\r\n        // Log uptime\r\n        const uptime = this.memory.stats.uptime;\r\n        Visualizer.text('Uptime', { x: boxX, y: y, roomName: this.room.name });\r\n        Visualizer.barGraph(uptime, { x: boxX + 4, y: y, roomName: this.room.name }, 5);\r\n        y += 1;\r\n        // Log overload status\r\n        const overload = this.memory.stats.overload;\r\n        Visualizer.text('Overload', { x: boxX, y: y, roomName: this.room.name });\r\n        Visualizer.barGraph(overload, { x: boxX + 4, y: y, roomName: this.room.name }, 5);\r\n        y += 1;\r\n        for (const i in spawning) {\r\n            Visualizer.text(spawning[i], { x: boxX, y: y, roomName: this.room.name });\r\n            Visualizer.barGraph(spawnProgress[i], { x: boxX + 4, y: y, roomName: this.room.name }, 5);\r\n            y += 1;\r\n        }\r\n        return { x: x, y: y + .25 };\r\n    }\r\n};\r\nHatchery.restrictedRange = 6; // Don't stand idly within this range of hatchery\r\nHatchery = tslib_1.__decorate([\r\n    profile\r\n], Hatchery);\r\nexport { Hatchery };\r\n","references":["C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/creepSetups/CreepSetup.ts","C:/git/Overmind/src/logistics/TransportRequestGroup.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/movement/Movement.ts","C:/git/Overmind/src/movement/Pathing.ts","C:/git/Overmind/src/overlords/core/queen.ts","C:/git/Overmind/src/overlords/core/queen_bunker.ts","C:/git/Overmind/src/overlords/Overlord.ts","C:/git/Overmind/src/priorities/priorities.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/roomPlanner/layouts/bunker.ts","C:/git/Overmind/src/stats/stats.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/visuals/Visualizer.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/hiveClusters/_HiveCluster.ts"]}
