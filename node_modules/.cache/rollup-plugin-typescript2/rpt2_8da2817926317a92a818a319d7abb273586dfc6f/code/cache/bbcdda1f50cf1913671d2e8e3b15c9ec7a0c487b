{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Roles, Setups } from '../../creepSetups/setups';\r\nimport { TERMINAL_STATE_REBUILD } from '../../directives/terminalState/terminalState_rebuild';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { Tasks } from '../../tasks/Tasks';\r\nimport { DEFAULT_PRESPAWN, Overlord } from '../Overlord';\r\n/**\r\n * Spawns a dedicated hatchery attendant to refill spawns and extensions\r\n */\r\nlet QueenOverlord = class QueenOverlord extends Overlord {\r\n    constructor(hatchery, priority = OverlordPriority.core.queen) {\r\n        super(hatchery, 'supply', priority);\r\n        this.hatchery = hatchery;\r\n        this.queenSetup = this.colony.storage ? Setups.queens.default : Setups.queens.early;\r\n        if (this.colony.terminalState == TERMINAL_STATE_REBUILD) {\r\n            this.queenSetup = Setups.queens.early;\r\n        }\r\n        this.queens = this.zerg(Roles.queen);\r\n        this.settings = {\r\n            refillTowersBelow: 500,\r\n        };\r\n    }\r\n    init() {\r\n        const amount = 1;\r\n        const prespawn = this.hatchery.spawns.length <= 1 ? 100 : DEFAULT_PRESPAWN;\r\n        this.wishlist(amount, this.queenSetup, { prespawn: prespawn });\r\n    }\r\n    supplyActions(queen) {\r\n        // Select the closest supply target out of the highest priority and refill it\r\n        const request = this.hatchery.transportRequests.getPrioritizedClosestRequest(queen.pos, 'supply');\r\n        if (request) {\r\n            queen.task = Tasks.transfer(request.target);\r\n        }\r\n        else {\r\n            this.rechargeActions(queen); // if there are no targets, refill yourself\r\n        }\r\n    }\r\n    rechargeActions(queen) {\r\n        if (this.hatchery.link && !this.hatchery.link.isEmpty) {\r\n            queen.task = Tasks.withdraw(this.hatchery.link);\r\n        }\r\n        else if (this.hatchery.battery && this.hatchery.battery.energy > 0) {\r\n            queen.task = Tasks.withdraw(this.hatchery.battery);\r\n        }\r\n        else {\r\n            queen.task = Tasks.recharge();\r\n        }\r\n    }\r\n    idleActions(queen) {\r\n        if (this.hatchery.link) {\r\n            // Can energy be moved from the link to the battery?\r\n            if (this.hatchery.battery && !this.hatchery.battery.isFull && !this.hatchery.link.isEmpty) {\r\n                // Move energy to battery as needed\r\n                if (queen.carry.energy < queen.carryCapacity) {\r\n                    queen.task = Tasks.withdraw(this.hatchery.link);\r\n                }\r\n                else {\r\n                    queen.task = Tasks.transfer(this.hatchery.battery);\r\n                }\r\n            }\r\n            else {\r\n                if (queen.carry.energy < queen.carryCapacity) { // make sure you're recharged\r\n                    if (!this.hatchery.link.isEmpty) {\r\n                        queen.task = Tasks.withdraw(this.hatchery.link);\r\n                    }\r\n                    else if (this.hatchery.battery && !this.hatchery.battery.isEmpty) {\r\n                        queen.task = Tasks.withdraw(this.hatchery.battery);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (this.hatchery.battery && queen.carry.energy < queen.carryCapacity) {\r\n                queen.task = Tasks.withdraw(this.hatchery.battery);\r\n            }\r\n        }\r\n    }\r\n    handleQueen(queen) {\r\n        if (queen.carry.energy > 0) {\r\n            this.supplyActions(queen);\r\n        }\r\n        else {\r\n            this.rechargeActions(queen);\r\n        }\r\n        // If there aren't any tasks that need to be done, recharge the battery from link\r\n        if (queen.isIdle) {\r\n            this.idleActions(queen);\r\n        }\r\n        // // If all of the above is done and hatchery is not in emergencyMode, move to the idle point and renew as needed\r\n        // if (!this.emergencyMode && queen.isIdle) {\r\n        // \tif (queen.pos.isEqualTo(this.idlePos)) {\r\n        // \t\t// If queen is at idle position, renew her as needed\r\n        // \t\tif (queen.ticksToLive < this.settings.renewQueenAt && this.availableSpawns.length > 0) {\r\n        // \t\t\tthis.availableSpawns[0].renewCreep(queen.creep);\r\n        // \t\t}\r\n        // \t} else {\r\n        // \t\t// Otherwise, travel back to idle position\r\n        // \t\tqueen.goTo(this.idlePos);\r\n        // \t}\r\n        // }\r\n    }\r\n    run() {\r\n        for (const queen of this.queens) {\r\n            // Get a task\r\n            this.handleQueen(queen);\r\n            // Run the task if you have one; else move back to idle pos\r\n            if (queen.hasValidTask) {\r\n                queen.run();\r\n            }\r\n            else {\r\n                if (this.queens.length > 1) {\r\n                    queen.goTo(this.hatchery.idlePos, { range: 1 });\r\n                }\r\n                else {\r\n                    queen.goTo(this.hatchery.idlePos);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nQueenOverlord = tslib_1.__decorate([\r\n    profile\r\n], QueenOverlord);\r\nexport { QueenOverlord };\r\n","references":["C:/git/Overmind/src/creepSetups/CreepSetup.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/directives/terminalState/terminalState_rebuild.ts","C:/git/Overmind/src/hiveClusters/hatchery.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/tasks/Tasks.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/overlords/Overlord.ts"]}
