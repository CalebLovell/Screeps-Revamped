{"code":"/**\r\n * Creep tasks setup instructions\r\n *\r\n * Javascript:\r\n * 1. In main.js:   require(\"tasks/prototypes.js\");\r\n * 2. As needed:    var Tasks = require(\"<path to Tasks.js>\");\r\n *\r\n * Typescript:\r\n * 1. In main.ts:   import \"./tasks/prototypes\";\r\n * 2. As needed:    import {Tasks} from \"<path to Tasks.ts>\"\r\n *\r\n * If you use Travler, change all occurrences of creep.moveTo() to creep.goTo()\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { log } from '../console/log';\r\nimport { profile } from '../profiler/decorator';\r\nimport { initializeTask } from './initializer';\r\n/**\r\n * An abstract class for encapsulating creep actions. This generalizes the concept of \"do action X to thing Y until\r\n * condition Z is met\" and saves a lot of convoluted and duplicated code in creep logic. A Task object contains\r\n * the necessary logic for traveling to a target, performing a task, and realizing when a task is no longer sensible\r\n * to continue.\r\n */\r\nlet Task = class Task {\r\n    constructor(taskName, target, options = {}) {\r\n        // Parameters for the task\r\n        this.name = taskName;\r\n        this._creep = {\r\n            name: '',\r\n        };\r\n        if (target) { // Handles edge cases like when you're done building something and target disappears\r\n            this._target = {\r\n                ref: target.ref,\r\n                _pos: target.pos,\r\n            };\r\n        }\r\n        else {\r\n            this._target = {\r\n                ref: '',\r\n                _pos: {\r\n                    x: -1,\r\n                    y: -1,\r\n                    roomName: '',\r\n                }\r\n            };\r\n        }\r\n        this._parent = null;\r\n        this.settings = {\r\n            targetRange: 1,\r\n            workOffRoad: false,\r\n            oneShot: false,\r\n            timeout: Infinity,\r\n            blind: true,\r\n        };\r\n        this.tick = Game.time;\r\n        this.options = options;\r\n        this.data = {};\r\n    }\r\n    /**\r\n     * Get a serialized ProtoTask from the current task\r\n     */\r\n    get proto() {\r\n        return {\r\n            name: this.name,\r\n            _creep: this._creep,\r\n            _target: this._target,\r\n            _parent: this._parent,\r\n            tick: this.tick,\r\n            options: this.options,\r\n            data: this.data,\r\n        };\r\n    }\r\n    /**\r\n     * Set the current task from a serialized ProtoTask\r\n     */\r\n    set proto(protoTask) {\r\n        // Don't write to this.name; used in task switcher\r\n        this._creep = protoTask._creep;\r\n        this._target = protoTask._target;\r\n        this._parent = protoTask._parent;\r\n        this.tick = protoTask.tick;\r\n        this.options = protoTask.options;\r\n        this.data = protoTask.data;\r\n    }\r\n    /**\r\n     * Return the wrapped creep which is executing this task\r\n     */\r\n    get creep() {\r\n        // Returns zerg wrapper instead of creep to use monkey-patched functions\r\n        return Overmind.zerg[this._creep.name];\r\n    }\r\n    /**\r\n     * Set the creep which is executing this task\r\n     */\r\n    set creep(creep) {\r\n        this._creep.name = creep.name;\r\n        if (this._parent) {\r\n            this.parent.creep = creep;\r\n        }\r\n    }\r\n    /**\r\n     * Dereferences the Task's target\r\n     */\r\n    get target() {\r\n        return deref(this._target.ref);\r\n    }\r\n    /**\r\n     * Dereferences the saved target position; useful for situations where you might lose vision\r\n     */\r\n    get targetPos() {\r\n        // refresh if you have visibility of the target\r\n        if (!this._targetPos) {\r\n            if (this.target) {\r\n                this._target._pos = this.target.pos;\r\n            }\r\n            this._targetPos = derefRoomPosition(this._target._pos);\r\n        }\r\n        return this._targetPos;\r\n    }\r\n    /**\r\n     * Get the Task's parent\r\n     */\r\n    get parent() {\r\n        return (this._parent ? initializeTask(this._parent) : null);\r\n    }\r\n    /**\r\n     * Set the Task's parent\r\n     */\r\n    set parent(parentTask) {\r\n        this._parent = parentTask ? parentTask.proto : null;\r\n        // If the task is already assigned to a creep, update their memory\r\n        if (this.creep) {\r\n            this.creep.task = this;\r\n        }\r\n    }\r\n    /**\r\n     * Return a list of [this, this.parent, this.parent.parent, ...] as tasks\r\n     */\r\n    get manifest() {\r\n        const manifest = [this];\r\n        let parent = this.parent;\r\n        while (parent) {\r\n            manifest.push(parent);\r\n            parent = parent.parent;\r\n        }\r\n        return manifest;\r\n    }\r\n    /**\r\n     * Return a list of [this.target, this.parent.target, ...] without fully instantiating the list of tasks\r\n     */\r\n    get targetManifest() {\r\n        const targetRefs = [this._target.ref];\r\n        let parent = this._parent;\r\n        while (parent) {\r\n            targetRefs.push(parent._target.ref);\r\n            parent = parent._parent;\r\n        }\r\n        return _.map(targetRefs, ref => deref(ref));\r\n    }\r\n    /**\r\n     * Return a list of [this.targetPos, this.parent.targetPos, ...] without fully instantiating the list of tasks\r\n     */\r\n    get targetPosManifest() {\r\n        const targetPositions = [this._target._pos];\r\n        let parent = this._parent;\r\n        while (parent) {\r\n            targetPositions.push(parent._target._pos);\r\n            parent = parent._parent;\r\n        }\r\n        return _.map(targetPositions, protoPos => derefRoomPosition(protoPos));\r\n    }\r\n    /**\r\n     * Fork the task, assigning a new task to the creep with this task as its parent\r\n     */\r\n    fork(newTask) {\r\n        newTask.parent = this;\r\n        if (this.creep) {\r\n            this.creep.task = newTask;\r\n        }\r\n        return newTask;\r\n    }\r\n    /**\r\n     * Test if the task is valid; if it is not, automatically remove task and transition to parent\r\n     */\r\n    isValid() {\r\n        let validTask = false;\r\n        if (this.creep) {\r\n            validTask = this.isValidTask() && Game.time - this.tick < this.settings.timeout;\r\n        }\r\n        let validTarget = false;\r\n        if (this.target) {\r\n            validTarget = this.isValidTarget();\r\n        }\r\n        else if ((this.settings.blind || this.options.blind) && !Game.rooms[this.targetPos.roomName]) {\r\n            // If you can't see the target's room but you have blind enabled, then that's okay\r\n            validTarget = true;\r\n        }\r\n        // Return if the task is valid; if not, finalize/delete the task and return false\r\n        if (validTask && validTarget) {\r\n            return true;\r\n        }\r\n        else {\r\n            // Switch to parent task if there is one\r\n            this.finish();\r\n            const isValid = this.parent ? this.parent.isValid() : false;\r\n            return isValid;\r\n        }\r\n    }\r\n    /**\r\n     * Move to within range of the target\r\n     */\r\n    moveToTarget(range = this.settings.targetRange) {\r\n        return this.creep.goTo(this.targetPos, { range: range });\r\n    }\r\n    /**\r\n     * Moves to the next position on the agenda if specified - call this in some tasks after work() is completed\r\n     */\r\n    moveToNextPos() {\r\n        if (this.options.nextPos) {\r\n            const nextPos = derefRoomPosition(this.options.nextPos);\r\n            return this.creep.goTo(nextPos);\r\n        }\r\n    }\r\n    /**\r\n     * Return expected number of ticks until creep arrives at its first destination\r\n     */\r\n    get eta() {\r\n        if (this.creep && this.creep.memory._go && this.creep.memory._go.path) {\r\n            return this.creep.memory._go.path.length;\r\n        }\r\n    }\r\n    /**\r\n     * Execute this task each tick. Returns nothing unless work is done.\r\n     */\r\n    run() {\r\n        if (this.isWorking) {\r\n            delete this.creep.memory._go;\r\n            // if (this.settings.workOffRoad) { // this is disabled as movement priorities makes it unnecessary\r\n            // \t// Move to somewhere nearby that isn't on a road\r\n            // \tthis.creep.park(this.targetPos, true);\r\n            // }\r\n            const result = this.work();\r\n            if (this.settings.oneShot && result === OK) {\r\n                this.finish();\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            this.moveToTarget();\r\n        }\r\n    }\r\n    /**\r\n     * Return whether the creep is currently performing its task action near the target\r\n     */\r\n    get isWorking() {\r\n        return this.creep.pos.inRangeToPos(this.targetPos, this.settings.targetRange) && !this.creep.pos.isEdge;\r\n    }\r\n    /**\r\n     * Finalize the task and switch to parent task (or null if there is none)\r\n     */\r\n    finish() {\r\n        this.moveToNextPos();\r\n        if (this.creep) {\r\n            this.creep.task = this.parent;\r\n        }\r\n        else {\r\n            log.debug(`No creep executing ${this.name}! Proto: ${JSON.stringify(this.proto)}`);\r\n        }\r\n    }\r\n};\r\nTask = tslib_1.__decorate([\r\n    profile\r\n], Task);\r\nexport { Task };\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/zerg/Zerg.ts","C:/git/Overmind/src/tasks/initializer.ts"]}
