{"code":"import * as tslib_1 from \"tslib\";\r\nvar CommandCenter_1;\r\nimport { $ } from '../caching/GlobalCache';\r\nimport { TransportRequestGroup } from '../logistics/TransportRequestGroup';\r\nimport { Mem } from '../memory/Memory';\r\nimport { CommandCenterOverlord } from '../overlords/core/manager';\r\nimport { Priority } from '../priorities/priorities';\r\nimport { profile } from '../profiler/decorator';\r\nimport { Abathur } from '../resources/Abathur';\r\nimport { Cartographer } from '../utilities/Cartographer';\r\nimport { Visualizer } from '../visuals/Visualizer';\r\nimport { HiveCluster } from './_HiveCluster';\r\nexport const MAX_OBSERVE_DISTANCE = 7;\r\n/**\r\n * The command center groups the high-level structures at the core of the bunker together, including storage, terminal,\r\n * link, power spawn, observer, and nuker.\r\n */\r\nlet CommandCenter = CommandCenter_1 = class CommandCenter extends HiveCluster {\r\n    constructor(colony, storage) {\r\n        super(colony, storage, 'commandCenter');\r\n        this.memory = Mem.wrap(this.colony.memory, 'commandCenter');\r\n        // Register physical components\r\n        this.storage = storage;\r\n        this.terminal = colony.terminal;\r\n        this.powerSpawn = colony.powerSpawn;\r\n        this.nuker = colony.nuker;\r\n        this.observer = colony.observer;\r\n        if (this.colony.bunker) {\r\n            this.link = this.colony.bunker.anchor.findClosestByLimitedRange(colony.availableLinks, 1);\r\n            this.colony.linkNetwork.claimLink(this.link);\r\n            this.towers = this.colony.bunker.anchor.findInRange(colony.towers, 1);\r\n        }\r\n        else {\r\n            this.link = this.pos.findClosestByLimitedRange(colony.availableLinks, 2);\r\n            this.colony.linkNetwork.claimLink(this.link);\r\n            this.towers = this.pos.findInRange(colony.towers, 3);\r\n        }\r\n        this.terminalNetwork = Overmind.terminalNetwork;\r\n        this.transportRequests = new TransportRequestGroup(); // commandCenter always gets its own request group\r\n        this.observeRoom = undefined;\r\n    }\r\n    refresh() {\r\n        this.memory = Mem.wrap(this.colony.memory, 'commandCenter');\r\n        $.refreshRoom(this);\r\n        $.refresh(this, 'storage', 'terminal', 'powerSpawn', 'nuker', 'observer', 'link', 'towers');\r\n        this.transportRequests.refresh();\r\n        this.observeRoom = undefined;\r\n    }\r\n    spawnMoarOverlords() {\r\n        if (this.link || this.terminal) {\r\n            this.overlord = new CommandCenterOverlord(this);\r\n        }\r\n    }\r\n    // Idle position\r\n    get idlePos() {\r\n        if (this.colony.bunker) {\r\n            return this.colony.bunker.anchor;\r\n        }\r\n        if (!this.memory.idlePos || Game.time % 25 == 0) {\r\n            this.memory.idlePos = this.findIdlePos();\r\n        }\r\n        return derefRoomPosition(this.memory.idlePos);\r\n    }\r\n    /* Find the best idle position */\r\n    findIdlePos() {\r\n        // Try to match as many other structures as possible\r\n        const proximateStructures = _.compact([this.link,\r\n            this.terminal,\r\n            this.powerSpawn,\r\n            this.nuker,\r\n            ...this.towers]);\r\n        const numNearbyStructures = (pos) => _.filter(proximateStructures, s => s.pos.isNearTo(pos) && !s.pos.isEqualTo(pos)).length;\r\n        return _.last(_.sortBy(this.storage.pos.neighbors, pos => numNearbyStructures(pos)));\r\n    }\r\n    /* Register a link transfer store if the link is sufficiently full */\r\n    registerLinkTransferRequests() {\r\n        if (this.link) {\r\n            if (this.link.energy > CommandCenter_1.settings.linksTransmitAt) {\r\n                this.colony.linkNetwork.requestTransmit(this.link);\r\n            }\r\n        }\r\n    }\r\n    registerRequests() {\r\n        // Supply requests:\r\n        // If the link is empty and can send energy and something needs energy, fill it up\r\n        if (this.link && this.link.energy < 0.9 * this.link.energyCapacity && this.link.cooldown <= 1) {\r\n            if (this.colony.linkNetwork.receive.length > 0) { // If something wants energy\r\n                this.transportRequests.requestInput(this.link, Priority.Critical);\r\n            }\r\n        }\r\n        // Refill towers as needed with variable priority\r\n        const refillTowers = _.filter(this.towers, tower => tower.energy < CommandCenter_1.settings.refillTowersBelow);\r\n        _.forEach(refillTowers, tower => this.transportRequests.requestInput(tower, Priority.High));\r\n        // Refill core spawn (only applicable to bunker layouts)\r\n        if (this.colony.bunker && this.colony.bunker.coreSpawn) {\r\n            if (this.colony.bunker.coreSpawn.energy < this.colony.bunker.coreSpawn.energyCapacity) {\r\n                this.transportRequests.requestInput(this.colony.bunker.coreSpawn, Priority.Normal);\r\n            }\r\n        }\r\n        // Refill power spawn\r\n        if (this.powerSpawn && this.powerSpawn.energy < this.powerSpawn.energyCapacity) {\r\n            this.transportRequests.requestInput(this.powerSpawn, Priority.NormalLow);\r\n        }\r\n        // Refill nuker with low priority\r\n        if (this.nuker) {\r\n            if (this.nuker.energy < this.nuker.energyCapacity && this.storage.energy > 200000) {\r\n                this.transportRequests.requestInput(this.nuker, Priority.Low);\r\n            }\r\n            if (this.nuker.ghodium < this.nuker.ghodiumCapacity\r\n                && (this.colony.assets[RESOURCE_GHODIUM] || 0) >= 2 * Abathur.settings.maxBatchSize) {\r\n                this.transportRequests.requestInput(this.nuker, Priority.Low, { resourceType: RESOURCE_GHODIUM });\r\n            }\r\n        }\r\n        // Withdraw requests:\r\n        // If the link has energy and nothing needs it, empty it\r\n        if (this.link && this.link.energy > 0) {\r\n            if (this.colony.linkNetwork.receive.length == 0 || this.link.cooldown > 3) {\r\n                this.transportRequests.requestOutput(this.link, Priority.High);\r\n            }\r\n        }\r\n    }\r\n    requestRoomObservation(roomName) {\r\n        this.observeRoom = roomName;\r\n    }\r\n    runObserver() {\r\n        if (this.observer) {\r\n            if (this.observeRoom) {\r\n                this.observer.observeRoom(this.observeRoom);\r\n            }\r\n            else if (CommandCenter_1.settings.enableIdleObservation) {\r\n                const dx = Game.time % MAX_OBSERVE_DISTANCE;\r\n                const dy = Game.time % (MAX_OBSERVE_DISTANCE ** 2);\r\n                const roomToObserve = Cartographer.findRelativeRoomName(this.pos.roomName, dx, dy);\r\n                this.observer.observeRoom(roomToObserve);\r\n            }\r\n        }\r\n    }\r\n    // Initialization and operation ====================================================================================\r\n    init() {\r\n        this.registerLinkTransferRequests();\r\n        this.registerRequests();\r\n    }\r\n    run() {\r\n        this.runObserver();\r\n    }\r\n    visuals(coord) {\r\n        let { x, y } = coord;\r\n        const height = this.storage && this.terminal ? 2 : 1;\r\n        const titleCoords = Visualizer.section(`${this.colony.name} Command Center`, { x, y, roomName: this.room.name }, 9.5, height + .1);\r\n        const boxX = titleCoords.x;\r\n        y = titleCoords.y + 0.25;\r\n        if (this.storage) {\r\n            Visualizer.text('Storage', { x: boxX, y: y, roomName: this.room.name });\r\n            Visualizer.barGraph(_.sum(this.storage.store) / this.storage.storeCapacity, { x: boxX + 4, y: y, roomName: this.room.name }, 5);\r\n            y += 1;\r\n        }\r\n        if (this.terminal) {\r\n            Visualizer.text('Terminal', { x: boxX, y: y, roomName: this.room.name });\r\n            Visualizer.barGraph(_.sum(this.terminal.store) / this.terminal.storeCapacity, { x: boxX + 4, y: y, roomName: this.room.name }, 5);\r\n            y += 1;\r\n        }\r\n        return { x: x, y: y + .25 };\r\n    }\r\n};\r\nCommandCenter.settings = {\r\n    enableIdleObservation: true,\r\n    linksTransmitAt: LINK_CAPACITY - 100,\r\n    refillTowersBelow: 750,\r\n};\r\nCommandCenter = CommandCenter_1 = tslib_1.__decorate([\r\n    profile\r\n], CommandCenter);\r\nexport { CommandCenter };\r\n","references":["C:/git/Overmind/src/caching/GlobalCache.ts","C:/git/Overmind/src/Colony.ts","C:/git/Overmind/src/logistics/TerminalNetwork.ts","C:/git/Overmind/src/logistics/TransportRequestGroup.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/overlords/core/manager.ts","C:/git/Overmind/src/priorities/priorities.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/resources/Abathur.ts","C:/git/Overmind/src/utilities/Cartographer.ts","C:/git/Overmind/src/visuals/Visualizer.ts","C:/git/Overmind/src/hiveClusters/_HiveCluster.ts"]}
