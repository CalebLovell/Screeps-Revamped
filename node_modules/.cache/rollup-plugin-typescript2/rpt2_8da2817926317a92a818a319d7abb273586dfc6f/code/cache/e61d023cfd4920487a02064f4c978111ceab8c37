{"code":"import * as tslib_1 from \"tslib\";\r\nvar SourceReaperOverlord_1;\r\nimport { debug, log } from '../../console/log';\r\nimport { CombatSetups, Roles } from '../../creepSetups/setups';\r\nimport { RoomIntel } from '../../intel/RoomIntel';\r\nimport { Mem } from '../../memory/Memory';\r\nimport { Movement } from '../../movement/Movement';\r\nimport { OverlordPriority } from '../../priorities/priorities_overlords';\r\nimport { profile } from '../../profiler/decorator';\r\nimport { CombatTargeting } from '../../targeting/CombatTargeting';\r\nimport { minBy } from '../../utilities/utils';\r\nimport { Visualizer } from '../../visuals/Visualizer';\r\nimport { CombatOverlord } from '../CombatOverlord';\r\n/**\r\n * SourceReaperOverlord -- spawns offensive creeps to allow source keeper mining\r\n */\r\nlet SourceReaperOverlord = SourceReaperOverlord_1 = class SourceReaperOverlord extends CombatOverlord {\r\n    constructor(directive, priority = OverlordPriority.remoteSKRoom.sourceReaper) {\r\n        super(directive, 'sourceReaper', priority, SourceReaperOverlord_1.requiredRCL);\r\n        this.directive = directive;\r\n        this.priority += this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;\r\n        this.reapers = this.combatZerg(Roles.melee);\r\n        this.defenders = this.combatZerg(Roles.ranged);\r\n        this.memory = Mem.wrap(this.directive.memory, 'sourceReaper');\r\n        this.computeTargetLair();\r\n    }\r\n    computeTargetLair() {\r\n        this.targetLair = this.memory.targetLairID ? deref(this.memory.targetLairID) : undefined;\r\n        if (!this.targetLair || (this.targetLair.ticksToSpawn || Infinity) >= 299) {\r\n            this.targetLair = this.getNextTargetLair();\r\n        }\r\n    }\r\n    refresh() {\r\n        super.refresh();\r\n        this.memory = Mem.wrap(this.directive.memory, 'sourceReaper');\r\n        this.computeTargetLair();\r\n    }\r\n    init() {\r\n        const defenderAmount = this.room && (this.room.invaders.length > 0\r\n            || RoomIntel.isInvasionLikely(this.room)) ? 1 : 0;\r\n        this.wishlist(1, CombatSetups.zerglings.sourceKeeper);\r\n        this.wishlist(defenderAmount, CombatSetups.hydralisks.sourceKeeper);\r\n    }\r\n    getNextTargetLair() {\r\n        if (!this.room)\r\n            return;\r\n        // If any lairs have an active keeper, target that\r\n        const activeLair = _.find(this.room.keeperLairs, lair => lair.pos.findInRange(lair.room.sourceKeepers, 5).length > 0);\r\n        if (activeLair)\r\n            return activeLair;\r\n        // Otherwise target whatever is closest to spawning\r\n        return minBy(this.room.keeperLairs, lair => lair.ticksToSpawn || Infinity); // not sure why ticksToSpawn is number | undefined\r\n    }\r\n    handleReaper(reaper) {\r\n        // Go to keeper room\r\n        if (!this.targetLair || !this.room || reaper.room != this.room || reaper.pos.isEdge) {\r\n            // log.debugCreep(reaper, `Going to room!`);\r\n            reaper.healSelfIfPossible();\r\n            reaper.goTo(this.pos);\r\n            return;\r\n        }\r\n        if (this.room.invaders.length > 0) {\r\n            // Handle invader actions\r\n            // log.debugCreep(reaper, `Handling invader actions!`);\r\n            if (reaper.hits >= reaper.hitsMax * .5) {\r\n                const result = reaper.autoMelee(this.room.invaders);\r\n                if (result == undefined) { // didn't attack\r\n                    reaper.autoHeal();\r\n                }\r\n            }\r\n            else {\r\n                reaper.healSelfIfPossible();\r\n            }\r\n            // Kite around ranged invaders until a defender arrives\r\n            if (this.room.invaders.length > 2 && _.filter(this.defenders, def => def.room == this.room).length == 0) {\r\n                reaper.kite(_.filter(this.room.hostiles, hostile => hostile.getActiveBodyparts(RANGED_ATTACK) > 0));\r\n                reaper.healSelfIfPossible();\r\n            }\r\n            // If defender is already here or a small invasion\r\n            else {\r\n                const target = CombatTargeting.findTarget(reaper, this.room.invaders);\r\n                if (target) {\r\n                    Movement.invasionMove(reaper, target);\r\n                }\r\n                else {\r\n                    log.warning(`KeeperReaper@${reaper.pos.print}: no invader target!`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // log.debugCreep(reaper, `Standard keeperReaper actions`);\r\n            // Standard keeperReaper actions\r\n            const nearestHostile = reaper.pos.findClosestByRange(this.room.hostiles);\r\n            if (nearestHostile && reaper.pos.isNearTo(nearestHostile)) {\r\n                reaper.attack(nearestHostile);\r\n                reaper.move(reaper.pos.getDirectionTo(nearestHostile));\r\n            }\r\n            else {\r\n                const keeper = this.targetLair.pos.findClosestByLimitedRange(this.room.sourceKeepers, 7);\r\n                if (keeper) { // attack the source keeper\r\n                    // stop and heal at range 4 if needed\r\n                    const approachRange = (reaper.hits == reaper.hitsMax || reaper.pos.getRangeTo(keeper) <= 3) ? 1 : 4;\r\n                    reaper.goTo(keeper, { range: approachRange });\r\n                }\r\n                else { // travel to next lair\r\n                    reaper.goTo(this.targetLair, { range: 1 });\r\n                }\r\n            }\r\n            reaper.healSelfIfPossible();\r\n        }\r\n    }\r\n    handleDefender(defender) {\r\n        // Go to keeper room\r\n        if (!this.targetLair || !this.room || defender.room != this.room || defender.pos.isEdge) {\r\n            debug(defender, `Going to room!`);\r\n            defender.healSelfIfPossible();\r\n            defender.goToRoom(this.pos.roomName);\r\n            return;\r\n        }\r\n        if (this.room.invaders.length > 0) {\r\n            // Handle invader actions\r\n            debug(defender, `AutoCombat`);\r\n            defender.autoSkirmish(this.room.name);\r\n        }\r\n        else {\r\n            debug(defender, `Standard duty`);\r\n            const minKeepersToHelp = this.reapers.length == 0 ? 1 : 2;\r\n            if (this.room.sourceKeepers.length >= minKeepersToHelp) {\r\n                // Help out with keeper reaping\r\n                defender.autoRanged();\r\n                defender.autoHeal(false);\r\n                const reaper = defender.pos.findClosestByRange(this.reapers);\r\n                if (reaper) {\r\n                    defender.goTo(reaper, {\r\n                        movingTarget: defender.pos.getRangeTo(reaper) > 8,\r\n                        maxRooms: 1,\r\n                        repath: 0.1\r\n                    });\r\n                }\r\n                else {\r\n                    const keeper = this.targetLair.pos.findClosestByLimitedRange(this.room.sourceKeepers, 7);\r\n                    if (keeper) { // attack the source keeper\r\n                        const range = defender.pos.getRangeTo(keeper);\r\n                        const keepAtRange = defender.hits < defender.hitsMax * .9 ? 4 : 3;\r\n                        if (range < keepAtRange) {\r\n                            defender.kite(this.room.hostiles, { range: keepAtRange });\r\n                        }\r\n                        else if (range > keepAtRange) {\r\n                            defender.goTo(keeper, { maxRooms: 1, range: keepAtRange });\r\n                        }\r\n                    }\r\n                    else { // travel to next lair\r\n                        defender.goTo(this.targetLair, { range: 5 });\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Do medic actions\r\n                debug(defender, `Medic actions`);\r\n                defender.doMedicActions(this.room.name);\r\n            }\r\n        }\r\n    }\r\n    run() {\r\n        this.autoRun(this.reapers, reaper => this.handleReaper(reaper));\r\n        this.autoRun(this.defenders, defender => this.handleDefender(defender));\r\n    }\r\n    visuals() {\r\n        if (this.room && this.targetLair) {\r\n            Visualizer.marker(this.targetLair.pos);\r\n        }\r\n    }\r\n};\r\nSourceReaperOverlord.requiredRCL = 7;\r\nSourceReaperOverlord = SourceReaperOverlord_1 = tslib_1.__decorate([\r\n    profile\r\n], SourceReaperOverlord);\r\nexport { SourceReaperOverlord };\r\n","references":["C:/git/Overmind/src/console/log.ts","C:/git/Overmind/src/creepSetups/setups.ts","C:/git/Overmind/src/directives/colony/outpostSK.ts","C:/git/Overmind/src/intel/RoomIntel.ts","C:/git/Overmind/src/memory/Memory.ts","C:/git/Overmind/src/movement/Movement.ts","C:/git/Overmind/src/priorities/priorities_overlords.ts","C:/git/Overmind/src/profiler/decorator.ts","C:/git/Overmind/src/targeting/CombatTargeting.ts","C:/git/Overmind/src/utilities/utils.ts","C:/git/Overmind/src/visuals/Visualizer.ts","C:/git/Overmind/src/zerg/CombatZerg.ts","C:/git/Overmind/src/overlords/CombatOverlord.ts","C:/git/Overmind/src/overlords/Overlord.ts"]}
