{"code":"import { hasPos } from '../declarations/typeGuards';\r\n/**\r\n * Returns destination.pos if destination has a position, or destination if destination is a RoomPosition\r\n */\r\nexport function normalizePos(destination) {\r\n    if (hasPos(destination)) {\r\n        return destination.pos;\r\n    }\r\n    else {\r\n        return destination;\r\n    }\r\n}\r\n/**\r\n * Returns if the coordinate is on an exit tile\r\n */\r\nexport function isExit(pos) {\r\n    return pos.x == 0 || pos.y == 0 || pos.x == 49 || pos.y == 49;\r\n}\r\n/**\r\n * Checks if the coordinates of two room positions are the same\r\n */\r\nexport function sameCoord(pos1, pos2) {\r\n    return pos1.x == pos2.x && pos1.y == pos2.y;\r\n}\r\n/**\r\n * Returns the number of move parts and number of weight-generating parts in a creep\r\n */\r\nexport function getCreepWeightInfo(creep, analyzeCarry = true) {\r\n    // Compute number of weighted and unweighted bodyparts\r\n    const unweightedParts = analyzeCarry ? [MOVE, CARRY] : [MOVE];\r\n    const bodyParts = _.countBy(creep.body, p => _.contains(unweightedParts, p.type) ? p.type : 'weighted');\r\n    bodyParts.move = bodyParts.move || 0;\r\n    bodyParts.weighted = bodyParts.weighted || 0;\r\n    if (bodyParts[CARRY]) {\r\n        bodyParts.weighted += Math.ceil(_.sum(creep.carry) / CARRY_CAPACITY);\r\n    }\r\n    // Account for boosts\r\n    for (const part of creep.body) {\r\n        if (part.type == MOVE && part.boost) {\r\n            bodyParts.move += (BOOSTS.move[part.boost].fatigue - 1);\r\n        }\r\n    }\r\n    return bodyParts;\r\n}\r\n/**\r\n * Get terrain costs which take into account a creep's individual fatigue stats\r\n */\r\nexport function getTerrainCosts(creep) {\r\n    const data = getCreepWeightInfo(creep);\r\n    const ratio = data.weighted / data.move;\r\n    return {\r\n        plainCost: Math.ceil(ratio),\r\n        swampCost: 5 * Math.ceil(ratio),\r\n    };\r\n}\r\n","references":["C:/git/Overmind/src/declarations/typeGuards.ts"]}
